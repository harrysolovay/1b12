import type * as HttpClient from "@effect/platform/HttpClient"
import * as HttpClientError from "@effect/platform/HttpClientError"
import * as HttpClientRequest from "@effect/platform/HttpClientRequest"
import * as HttpClientResponse from "@effect/platform/HttpClientResponse"
import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { ParseError } from "effect/ParseResult"
import * as S from "effect/Schema"

export class B2BBrokerAccountDetailsRequest
  extends S.Class<B2BBrokerAccountDetailsRequest>("B2BBrokerAccountDetailsRequest")({
    /**
     * Auth token that allows connecting to the target institution.
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * The Id which uniquely identifies the integration.
     */
    integrationId: S.String,
  })
{}

export class ApiResultStatus
  extends S.Literal(
    "ok",
    "serverFailure",
    "permissionDenied",
    "badRequest",
    "notFound",
    "conflict",
    "tooManyRequest",
    "locked",
    "unavailableForLegalReasons",
  )
{}

export class UserIdentificationType extends S.Literal("none", "idCard", "driversLicense", "passport") {}

export class B2BBrokerAccountDetailsResponse
  extends S.Class<B2BBrokerAccountDetailsResponse>("B2BBrokerAccountDetailsResponse")({
    integrationName: S.optionalWith(S.String, { nullable: true }),
    firstName: S.optionalWith(S.String, { nullable: true }),
    middleName: S.optionalWith(S.String, { nullable: true }),
    lastName: S.optionalWith(S.String, { nullable: true }),
    accountNumber: S.optionalWith(S.String, { nullable: true }),
    email: S.optionalWith(S.String, { nullable: true }),
    mobileNumber: S.optionalWith(S.String, { nullable: true }),
    companyName: S.optionalWith(S.String, { nullable: true }),
    countryCode: S.optionalWith(S.String, { nullable: true }),
    city: S.optionalWith(S.String, { nullable: true }),
    postalCode: S.optionalWith(S.String, { nullable: true }),
    address: S.optionalWith(S.String, { nullable: true }),
    idType: S.optionalWith(UserIdentificationType, { nullable: true }),
    idNumber: S.optionalWith(S.String, { nullable: true }),
    dateOfBirth: S.optionalWith(S.Int, { nullable: true }),
  })
{}

export class B2BBrokerAccountDetailsResponseApiResult
  extends S.Class<B2BBrokerAccountDetailsResponseApiResult>("B2BBrokerAccountDetailsResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerAccountDetailsResponse, { nullable: true }),
  })
{}

export class ApiResult extends S.Class<ApiResult>("ApiResult")({
  status: S.optionalWith(ApiResultStatus, { nullable: true }),
  /**
   * A message generated by the API
   */
  message: S.optionalWith(S.String, { nullable: true }),
  /**
   * User-friendly display message that can be presented to the end user
   */
  displayMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType: S.optionalWith(S.String, { nullable: true }),
}) {}

export class ApiV1AccountVerify401 extends S.Struct({}) {}

export class ApiV1AccountVerify403 extends S.Struct({}) {}

export class AccountInfoType
  extends S.Literal(
    "firstName",
    "middleName",
    "lastName",
    "accountNumber",
    "email",
    "mobileNumber",
    "companyName",
    "countryCode",
    "city",
    "postalCode",
    "address",
    "id",
    "dateOfBirth",
  )
{}

/**
 * Exchange account info request.
 */
export class ExchangeAccountInfoRequest extends S.Class<ExchangeAccountInfoRequest>("ExchangeAccountInfoRequest")({
  /**
   * Auth token that allows connecting to the target institution.
   */
  authToken: S.optionalWith(S.String, { nullable: true }),
  /**
   * The Id which uniquely identifies the integration.
   */
  integrationId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Account information to return.
   */
  accountInfo: S.optionalWith(S.Array(AccountInfoType), { nullable: true }),
}) {}

export class ApiV1ExchangeVerify401 extends S.Struct({}) {}

export class ApiV1ExchangeVerify403 extends S.Struct({}) {}

export class ApiV1AssetsAssetTypeParams extends S.Struct({
  Search: S.optionalWith(S.String, { nullable: true }),
  Count: S.optionalWith(S.Int, { nullable: true }),
  Offset: S.optionalWith(S.Int, { nullable: true }),
}) {}

export class AssetType extends S.Literal("equity", "cryptocurrency") {}

export class Asset extends S.Class<Asset>("Asset")({
  symbol: S.optionalWith(S.String, { nullable: true }),
  name: S.optionalWith(S.String, { nullable: true }),
  type: S.optionalWith(AssetType, { nullable: true }),
}) {}

export class AssetPaginationResponse extends S.Class<AssetPaginationResponse>("AssetPaginationResponse")({
  /**
   * list of items
   */
  items: S.optionalWith(S.Array(Asset), { nullable: true }),
  /**
   * Total number of items
   */
  total: S.optionalWith(S.Int, { nullable: true }),
}) {}

export class AssetPaginationResponseApiResult
  extends S.Class<AssetPaginationResponseApiResult>("AssetPaginationResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(AssetPaginationResponse, { nullable: true }),
  })
{}

export class ApiV1AssetsAssetType401 extends S.Struct({}) {}

export class BrokerType
  extends S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  )
{}

export class BalanceBrokerBaseRequest extends S.Class<BalanceBrokerBaseRequest>("BalanceBrokerBaseRequest")({
  /**
   * Auth token that allows connecting to the target institution
   */
  authToken: S.String.pipe(S.minLength(1)),
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```Coinbase```
   * ```Kraken```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```KuCoinDirect```
   * ```OkxOAuth```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BitsoDirect```
   * ```BybitDirect```
   * ```ParibuOAuth```
   * ```BinanceTrDirect```
   * ```BybitDirectMobile```
   */
  type: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
}) {}

export class B2BBrokerAccountBalance extends S.Class<B2BBrokerAccountBalance>("B2BBrokerAccountBalance")({
  /**
   * Withdrawable cash amount on the account.
   */
  cash: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Buying power indicating the maximum amount the user can spend to buy assets. E.g. available margin.
   */
  buyingPower: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Buying power available for placing cryptocurrency orders.
   */
  cryptocurrencyBuyingPower: S.optionalWith(S.Number, { nullable: true }),
  /**
   * ISO 4217 currency code.
   */
  currencyCode: S.optionalWith(S.String, { nullable: true }),
}) {}

export class B2BBrokerAccountBalanceModel
  extends S.Class<B2BBrokerAccountBalanceModel>("B2BBrokerAccountBalanceModel")({
    balances: S.optionalWith(S.Array(B2BBrokerAccountBalance), { nullable: true }),
    /**
     * Total USD value of all currencies
     */
    totalCashUsdValue: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Total USD value of all Buying Power
     */
    totalBuyingPowerUsdValue: S.optionalWith(S.Number, { nullable: true }),
  })
{}

export class B2BBrokerAccountBalanceModelApiResult
  extends S.Class<B2BBrokerAccountBalanceModelApiResult>("B2BBrokerAccountBalanceModelApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerAccountBalanceModel, { nullable: true }),
  })
{}

export class ApiV1BalanceGet401 extends S.Struct({}) {}

export class ApiV1BalanceGet403 extends S.Struct({}) {}

export class ApiV1BalancePortfolioParams extends S.Struct({
  UserId: S.optionalWith(S.String, { nullable: true }),
}) {}

export class PortfolioFiatBalance extends S.Class<PortfolioFiatBalance>("PortfolioFiatBalance")({
  /**
   * Balance currency
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Amount of money in a specific currency from all brokers
   */
  cash: S.optionalWith(S.Number, { nullable: true }),
  /**
   * BuyingPower from all brokers, it indicates total amount of money the user can spend on buying stock.
   * Always includes cash and can also include margin
   */
  buyingPower: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class B2BFiatPortfolioModel extends S.Class<B2BFiatPortfolioModel>("B2BFiatPortfolioModel")({
  /**
   * List of aggregated fiat balances
   */
  fiatBalances: S.optionalWith(S.Array(PortfolioFiatBalance), { nullable: true }),
}) {}

export class B2BFiatPortfolioModelApiResult
  extends S.Class<B2BFiatPortfolioModelApiResult>("B2BFiatPortfolioModelApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BFiatPortfolioModel, { nullable: true }),
  })
{}

export class ApiV1BalancePortfolio401 extends S.Struct({}) {}

export class ApiV1BalancePortfolio403 extends S.Struct({}) {}

export class ApiV1CataloglinkParams extends S.Struct({
  UserId: S.String.pipe(S.maxLength(50)),
  BrokerType: S.optionalWith(BrokerType, { nullable: true }),
  EnableTransfers: S.optionalWith(S.Boolean, { nullable: true }),
  RestrictMultipleAccounts: S.optionalWith(S.Boolean, { nullable: true }),
  DisableApiKeyGeneration: S.optionalWith(S.Boolean, { nullable: true }),
}) {}

export class CatalogLink extends S.Class<CatalogLink>("CatalogLink")({
  /**
   * Url to open Front catalog that should be presented to the end user.
   */
  url: S.optionalWith(S.String, { nullable: true }),
  /**
   * Url to open Front catalog in iFrame that should be presented to the end user.
   */
  iFrameUrl: S.optionalWith(S.String, { nullable: true }),
}) {}

export class CatalogLinkApiResult extends S.Class<CatalogLinkApiResult>("CatalogLinkApiResult")({
  status: S.optionalWith(
    S.Literal(
      "ok",
      "serverFailure",
      "permissionDenied",
      "badRequest",
      "notFound",
      "conflict",
      "tooManyRequest",
      "locked",
      "unavailableForLegalReasons",
    ),
    { nullable: true },
  ),
  /**
   * A message generated by the API
   */
  message: S.optionalWith(S.String, { nullable: true }),
  /**
   * User-friendly display message that can be presented to the end user
   */
  displayMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType: S.optionalWith(S.String, { nullable: true }),
  content: S.optionalWith(CatalogLink, { nullable: true }),
}) {}

export class ApiV1Cataloglink401 extends S.Struct({}) {}

export class TransferToAddressWithAmount extends S.Class<TransferToAddressWithAmount>("TransferToAddressWithAmount")({
  /**
   * The Id of the network in Front system. The list of all available networks can be obtained by
   * using `GET /transfers/managed/networks` endpoint.
   */
  networkId: S.optionalWith(S.String, { nullable: true }),
  /**
   * The symbol of the digital asset.
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * The address to send the asset to.
   */
  address: S.optionalWith(S.String, { nullable: true }),
  /**
   * Secondary address identifier for coins like XRP,XMR etc.
   */
  addressTag: S.optionalWith(S.String, { nullable: true }),
  /**
   * Amount of tokens to transfer by specified network.
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Transfer amount in fiat which is requested by client to be shown as amount in fiat.
   * It will be shown to end-user if and only if it's difference with actual amount in fiat is less that 1%.
   */
  displayAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class TransferTypeEnum extends S.Literal("deposit", "payment", "onramp") {}

export class GoodsDetails extends S.Class<GoodsDetails>("GoodsDetails")({
  /**
   * The type of the goods for the order (01: Tangible Goods, 02: Virtual Goods).
   */
  goodsType: S.optionalWith(S.String, { nullable: true }),
  /**
   * The category of goods (e.g., Electronics, Food).
   */
  goodsCategory: S.optionalWith(S.String, { nullable: true }),
  /**
   * A unique reference ID to identify the goods.
   */
  referenceGoodsId: S.optionalWith(S.String, { nullable: true }),
  /**
   * The name of the goods.
   */
  goodsName: S.optionalWith(S.String, { nullable: true }),
  /**
   * Additional details about the goods (optional).
   */
  goodsDetail: S.optionalWith(S.String, { nullable: true }),
}) {}

export class InitializeTransfersForLinkRequest
  extends S.Class<InitializeTransfersForLinkRequest>("InitializeTransfersForLinkRequest")({
    /**
     * The list of destination addresses with corresponding networks are asset symbols that
     * can be used to initiate incoming transfers.
     */
    toAddresses: S.optionalWith(S.Array(TransferToAddressWithAmount), { nullable: true }),
    /**
     * Amount in USD to transfer. If not provided users can specify amount by themselves.
     */
    amountInFiat: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Transaction ID Provided by client to track transaction in future calls
     */
    transactionId: S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
    /**
     * A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments to your company.
     * This will override any default fee entered in your Mesh dashboard for an individual transaction.
     * Please note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),
     * and not for Deposits (when the transfer destination is an address owned by the end user).
     * If used for Deposits, it will increase the size of the user's Deposit by the fee amount,
     * but will incorrectly show to the user as a fee.
     */
    clientFee: S.optionalWith(S.Number.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(1)), { nullable: true }),
    /**
     * Deposit (default): The user is transferring crypto to a wallet they own on your platform.
     * Payment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.
     * Onramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.
     */
    transferType: S.optionalWith(TransferTypeEnum, { nullable: true }),
    /**
     * Transaction description. (Binance Pay)
     */
    description: S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(256)), { nullable: true }),
    /**
     * Goods details for the transaction. (Binance Pay)
     */
    goodsDetails: S.optionalWith(S.Array(GoodsDetails), { nullable: true }),
  })
{}

export class TransferCryptocurrencyFundingOptions
  extends S.Class<TransferCryptocurrencyFundingOptions>("TransferCryptocurrencyFundingOptions")({
    /**
     * Indicates whether the Link is permitted to use the end user's available buying power
     * and/or payment methods to supplement the cryptocurrency balance if it is insufficient
     * for the transfer.
     */
    enabled: S.optionalWith(S.Boolean, { nullable: true }),
  })
{}

export class LinkTokenTransferOptions extends S.Class<LinkTokenTransferOptions>("LinkTokenTransferOptions")({
  /**
   * The list of destination addresses with corresponding networks are asset symbols that
   * can be used to initiate incoming transfers. If this parameter is present, the Link
   * session will continue to transfer flow after connecting the origin account.
   */
  toAddresses: S.optionalWith(S.Array(TransferToAddressWithAmount), { nullable: true }),
  /**
   * Amount in USD to transfer. If not provided users can specify amount by themselves.
   */
  amountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Transaction ID Provided by client to track transaction in future calls
   */
  transactionId: S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
  /**
   * A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments to your company.
   * This will override any default fee entered in your Mesh dashboard for an individual transaction.
   * Please note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),
   * and not for Deposits (when the transfer destination is an address owned by the end user).
   * If used for Deposits, it will increase the size of the user's Deposit by the fee amount,
   * but will incorrectly show to the user as a fee.
   */
  clientFee: S.optionalWith(S.Number.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(1)), { nullable: true }),
  /**
   * Deposit: The user is transferring crypto to a wallet they own on your platform.
   * Payment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.
   * Onramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.
   */
  transferType: S.optionalWith(TransferTypeEnum, { nullable: true }),
  /**
   * Specifies the permitted options to use the end user's available buying power
   * and/or payment methods to supplement the cryptocurrency balance if it is insufficient
   * for the transfer.
   */
  fundingOptions: S.optionalWith(TransferCryptocurrencyFundingOptions, { nullable: true }),
  /**
   * Specifies if all the fees are included in the amount to transfer.
   */
  isInclusiveFeeEnabled: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Transaction description. (Binance Pay)
   */
  description: S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(256)), { nullable: true }),
  /**
   * Goods details for the transaction. (Binance Pay)
   */
  goodsDetails: S.optionalWith(S.Array(GoodsDetails), { nullable: true }),
  /**
   * Link presents the user with the option to generate a unique payment link for Mesh pay scenarios.
   * If this param is true, a unique payment link will be returned.
   */
  generatePayLink: S.optionalWith(S.Boolean, { nullable: true }),
}) {}

/**
 * Verification method.
 */
export class WalletVerificationMethod extends S.Literal("signedMessage") {}

export class NetworkType
  extends S.Literal(
    "unknown",
    "evm",
    "solana",
    "bitcoin",
    "cardano",
    "tron",
    "avalancheX",
    "tezos",
    "dogecoin",
    "ripple",
    "stellar",
    "litecoin",
    "sui",
    "aptos",
    "tvm",
    "injective",
  )
{}

/**
 * DeFi wallet verification options.
 */
export class VerifyWalletOptions extends S.Class<VerifyWalletOptions>("VerifyWalletOptions")({
  /**
   * Verification message to sign.
   * Required if `signedMessage` is provided in <paramref name="VerificationMethods">VerificationMethods</paramref> list.
   */
  message: S.optionalWith(S.String, { nullable: true }),
  /**
   * List or required verification methods. By default - sign message with wallet key.
   */
  verificationMethods: S.optionalWith(S.Array(WalletVerificationMethod), { nullable: true }),
  /**
   * Addresses list to verify. If user verifies another address then verification will be failed.
   */
  addresses: S.optionalWith(S.Array(S.String), { nullable: true }),
  /**
   * Network to verify. If user verifies another network address then verification will be failed.
   * Checked only if Addresses is provided.
   */
  networkId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Network type to verify. If user verifies another network address then verification will be failed.
   * Checked only if Addresses is provided.
   */
  networkType: S.optionalWith(NetworkType, { nullable: true }),
}) {}

export class GetLinkTokenRequest extends S.Class<GetLinkTokenRequest>("GetLinkTokenRequest")({
  /**
   * A unique Id representing the end user. Typically this will be a user Id from the
   * client application. Personally identifiable information, such as an email address or phone number,
   * should not be used. 300 characters length maximum.
   */
  userId: S.String.pipe(S.minLength(1), S.maxLength(300)),
  /**
   * Type of integration to redirect to. Will redirect to catalog if not provided.
   * Not supported types: DeFiWallet, CryptocurrencyAddress, CryptocurrencyWallet.
   */
  brokerType: S.optionalWith(BrokerType, { nullable: true }),
  /**
   * The final screen of Link allows users to “continue” back to your app or “Link another account.”
   * If this param is present then this button will be hidden.
   */
  restrictMultipleAccounts: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Encapsulates transaction-related parameters, including destination addresses and the amount to transfer in fiat currency.
   */
  transferOptions: S.optionalWith(LinkTokenTransferOptions, { nullable: true }),
  /**
   * A unique identifier representing a specific integration obtained from the list of available integrations.
   */
  integrationId: S.optionalWith(S.String, { nullable: true }),
  /**
   * For direct integrations that also support API keys, Link presents the user with the option to generate an API key for seamless access.
   * If this param is true, this feature will be disabled.
   */
  disableApiKeyGeneration: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Encapsulates verify DeFi wallet parameters.
   */
  verifyWalletOptions: S.optionalWith(VerifyWalletOptions, { nullable: true }),
  /**
   * Sub Client ID, for B2B2B clients to tailor Link experience for their clients.
   */
  subClientId: S.optionalWith(S.String, { nullable: true }),
}) {}

export class LinkTokenModel extends S.Class<LinkTokenModel>("LinkTokenModel")({
  linkToken: S.optionalWith(S.String, { nullable: true }),
  paymentLink: S.optionalWith(S.String, { nullable: true }),
}) {}

export class LinkTokenModelApiResult extends S.Class<LinkTokenModelApiResult>("LinkTokenModelApiResult")({
  status: S.optionalWith(
    S.Literal(
      "ok",
      "serverFailure",
      "permissionDenied",
      "badRequest",
      "notFound",
      "conflict",
      "tooManyRequest",
      "locked",
      "unavailableForLegalReasons",
    ),
    { nullable: true },
  ),
  /**
   * A message generated by the API
   */
  message: S.optionalWith(S.String, { nullable: true }),
  /**
   * User-friendly display message that can be presented to the end user
   */
  displayMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType: S.optionalWith(S.String, { nullable: true }),
  content: S.optionalWith(LinkTokenModel, { nullable: true }),
}) {}

export class ApiV1Linktoken401 extends S.Struct({}) {}

export class BrokerRefreshTokenRequest extends S.Class<BrokerRefreshTokenRequest>("BrokerRefreshTokenRequest")({
  type: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
  refreshToken: S.String.pipe(S.minLength(1)),
  /**
   * Optional, used when we the refresh token should be refreshed.
   * Currently this flow is supported by TD Ameritrade
   */
  createNewRefreshToken: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Some institutions may require accessToken to be provided as well.
   * It's currently required by WeBull and Vanguard
   */
  accessToken: S.optionalWith(S.String, { nullable: true }),
  /**
   * Currently used to update WeBull trade token.
   */
  tradeToken: S.optionalWith(S.String, { nullable: true }),
  /**
   * Optional, currently used by Vanguard if account has enforced MFA enabled.
   */
  mfaCode: S.optionalWith(S.String, { nullable: true }),
  /**
   * Additional metadata
   */
  metadata: S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true }),
}) {}

export class B2BBrokerAuthStatus extends S.Literal("failed", "succeeded", "mfaRequired") {}

export class BrokerFiatBalance extends S.Class<BrokerFiatBalance>("BrokerFiatBalance")({
  /**
   * Account balance currency
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * BuyingPower indicates total amount of money the user can spend for buying stock. Always includes cash and
   * can also include margin
   */
  buyingPower: S.optionalWith(S.Number, { nullable: true }),
  /**
   * BuyingPower indicates total amount of money the user can spend for buying crypto.
   */
  cryptoBuyingPower: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Account cash indicates total amount of money
   */
  cash: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class BrokerAccount extends S.Class<BrokerAccount>("BrokerAccount")({
  meshAccountId: S.optionalWith(S.String, { nullable: true }),
  frontAccountId: S.optionalWith(S.String, { nullable: true }),
  accountId: S.optionalWith(S.String, { nullable: true }),
  accountName: S.optionalWith(S.String, { nullable: true }),
  /**
   * Buying power of the account. Typically consists of cash plus available margin.
   * For non-margin accounts fund contains cash only
   */
  fund: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Cash balance in USD
   */
  cash: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Indicates if this account was already connected by the current user and device.
   * Can be null.
   */
  isReconnected: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * The list of all asset balances of account
   */
  balances: S.optionalWith(S.Array(BrokerFiatBalance), { nullable: true }),
}) {}

export class BrokerAccountTokens extends S.Class<BrokerAccountTokens>("BrokerAccountTokens")({
  account: S.optionalWith(BrokerAccount, { nullable: true }),
  accessToken: S.optionalWith(S.String, { nullable: true }),
  refreshToken: S.optionalWith(S.String, { nullable: true }),
  /**
   * Token identifier provided by Mesh when the actual integration's token is managed by Mesh's Token Management System.
   */
  tokenId: S.optionalWith(S.String, { nullable: true }),
}) {}

export class B2BBrokerRefreshTokenResponse
  extends S.Class<B2BBrokerRefreshTokenResponse>("B2BBrokerRefreshTokenResponse")({
    status: S.optionalWith(S.Literal("failed", "succeeded", "mfaRequired"), { nullable: true }),
    errorMessage: S.optionalWith(S.String, { nullable: true }),
    account: S.optionalWith(BrokerAccount, { nullable: true }),
    accessToken: S.optionalWith(S.String, { nullable: true }),
    refreshToken: S.optionalWith(S.String, { nullable: true }),
    expiresInSeconds: S.optionalWith(S.Int, { nullable: true }),
    refreshTokenExpiresInSeconds: S.optionalWith(S.Int, { nullable: true }),
    brokerAccountTokens: S.optionalWith(S.Array(BrokerAccountTokens), { nullable: true }),
  })
{}

export class B2BBrokerRefreshTokenResponseApiResult
  extends S.Class<B2BBrokerRefreshTokenResponseApiResult>("B2BBrokerRefreshTokenResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerRefreshTokenResponse, { nullable: true }),
  })
{}

export class ApiV1TokenRefresh401 extends S.Struct({}) {}

export class BrokerBaseRequest extends S.Class<BrokerBaseRequest>("BrokerBaseRequest")({
  /**
   * Auth token that allows connecting to the target institution
   */
  authToken: S.String.pipe(S.minLength(1)),
  /**
   * Type of the institution to connect
   */
  type: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
}) {}

export class ApiV1Account401 extends S.Struct({}) {}

export class BrokerFeature
  extends S.Literal(
    "holdings",
    "balance",
    "orders",
    "transfers",
    "identity",
    "cryptocurrencyDepositAddresses",
    "accountNumber",
    "paymentMethods",
    "conversions",
  )
{}

export class DeFiWalletHealthStatusInfo extends S.Class<DeFiWalletHealthStatusInfo>("DeFiWalletHealthStatusInfo")({
  id: S.String,
  name: S.NullOr(S.String),
}) {}

export class B2BBrokersHealthStatus extends S.Class<B2BBrokersHealthStatus>("B2BBrokersHealthStatus")({
  /**
   * Type of the integration
   */
  type: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  /**
   * Name of the integration
   */
  name: S.optionalWith(S.String, { nullable: true }),
  /**
   * Is the communication with the integration up
   */
  isUp: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Description of the outage
   */
  description: S.optionalWith(S.String, { nullable: true }),
  /**
   * Unix timestamp in seconds indicating when the outage occurred
   */
  downTimeStart: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Unix timestamp in seconds indicating expected end of the outage
   */
  downTimeEnd: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Get products supported by the financial institution
   */
  supportedProducts: S.optionalWith(S.Array(BrokerFeature), { nullable: true }),
  /**
   * Short information about DeFiWallet
   */
  deFiWalletData: S.NullOr(DeFiWalletHealthStatusInfo),
}) {}

export class B2BBrokersHealthStatusListApiResult
  extends S.Class<B2BBrokersHealthStatusListApiResult>("B2BBrokersHealthStatusListApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(S.Array(B2BBrokersHealthStatus), { nullable: true }),
  })
{}

export class ApiV1Status401 extends S.Struct({}) {}

export class AuthenticationSchemeType
  extends S.Literal("usernamePassword", "oAuth", "apiKey", "blockchainAddress", "trueAuth")
{}

export class BrokerAuthStatus
  extends S.Literal(
    "failed",
    "challengeFailed",
    "succeeded",
    "challengeIssued",
    "mfaRequired",
    "openInBrokerModule",
    "delayed",
    "deviceConfirmationRequired",
    "emailVerification",
    "emailReceived",
    "captchaChallenge",
    "faceVerification",
    "bindMfaRequired",
    "apiKeyGenerationError",
    "qrCodeRequired",
    "qrCodeExpired",
    "deviceLoginVerified",
  )
{}

export class MfaType
  extends S.Literal(
    "phone",
    "email",
    "totp",
    "phoneAndEmail",
    "requireNextSecurityQuestion",
    "readEmail",
    "face",
    "tradingPin",
    "qrCode",
    "password",
    "roaming",
    "mobile",
  )
{}

export class AuthFlowStep
  extends S.Literal("loginPassword", "mfaFlow", "faceVerification", "createAPIKey", "loginQrCode")
{}

export class B2BBrokerAuthResponse extends S.Class<B2BBrokerAuthResponse>("B2BBrokerAuthResponse")({
  /**
   * Status of the request
   */
  status: S.optionalWith(
    S.Literal(
      "failed",
      "challengeFailed",
      "succeeded",
      "challengeIssued",
      "mfaRequired",
      "openInBrokerModule",
      "delayed",
      "deviceConfirmationRequired",
      "emailVerification",
      "emailReceived",
      "captchaChallenge",
      "faceVerification",
      "bindMfaRequired",
      "apiKeyGenerationError",
      "qrCodeRequired",
      "qrCodeExpired",
      "deviceLoginVerified",
    ),
    { nullable: true },
  ),
  mfaType: S.optionalWith(MfaType, { nullable: true }),
  /**
   * The AuthFlowStep is used to determine which state the authentication is in, for initial requests without MFA verification the value should be LoginPassword and when calling with MFA code it should be MfaFlow (currently used for BinanceInternationalDirect only).
   */
  authFlowStep: S.optionalWith(AuthFlowStep, { nullable: true }),
  /**
   * Qr code used to scan and solve facial verification (currently used for BinanceInternationalDirect only).
   */
  qrCode: S.optionalWith(S.String, { nullable: true }),
  qrCodeLink: S.optionalWith(S.String, { nullable: true }),
  qrCodeLinkIOS: S.optionalWith(S.String, { nullable: true }),
  /**
   * Id of the challenge, relevant when the status is `ChallengeIssued`
   */
  challengeId: S.optionalWith(S.String, { nullable: true }),
  challengeText: S.optionalWith(S.String, { nullable: true }),
  /**
   * Life span of the challenge
   */
  challengeExpiresInSeconds: S.optionalWith(S.Int, { nullable: true }),
  errorMessage: S.optionalWith(S.String, { nullable: true }),
  accessToken: S.optionalWith(S.String, { nullable: true }),
  refreshToken: S.optionalWith(S.String, { nullable: true }),
  expiresInSeconds: S.optionalWith(S.Int, { nullable: true }),
  refreshTokenExpiresInSeconds: S.optionalWith(S.Int, { nullable: true }),
  account: S.optionalWith(BrokerAccount, { nullable: true }),
  accountTokens: S.optionalWith(S.Array(BrokerAccountTokens), { nullable: true }),
  requiresReauthentication: S.optionalWith(S.Boolean, { nullable: true }),
  email: S.optionalWith(S.String, { nullable: true }),
  allocatedIPAddress: S.optionalWith(S.String, { nullable: true }),
}) {}

export class AuthenticationFieldDescription
  extends S.Class<AuthenticationFieldDescription>("AuthenticationFieldDescription")({
    /**
     * Name of the field, as expected from the API
     */
    name: S.optionalWith(S.String, { nullable: true }),
    description: S.optionalWith(S.String, { nullable: true }),
  })
{}

export class AuthenticationModel extends S.Class<AuthenticationModel>("AuthenticationModel")({
  authResponse: S.optionalWith(B2BBrokerAuthResponse, { nullable: true }),
  /**
   * Set of fields that are expected to be provided based on the status of the AuthResponse
   */
  fields: S.optionalWith(S.Array(AuthenticationFieldDescription), { nullable: true }),
}) {}

export class MfaScheme extends S.Literal("mfaCode", "challenge", "deviceConfirmation", "securityQuestion") {}

export class BrokerTrueAuthAuthenticationScheme
  extends S.Class<BrokerTrueAuthAuthenticationScheme>("BrokerTrueAuthAuthenticationScheme")({
    /**
     * The login url page to show in the webview.
     */
    loginUrl: S.NullOr(S.String),
    /**
     * The login page to check against for successful login
     */
    successfulLoginUri: S.NullOr(S.String),
    /**
     * The urls from where cookies are fetched.
     */
    cookieDomains: S.NullOr(S.Array(S.String)),
    /**
     * The headers that are required for authentication.
     */
    requiredHeaderNames: S.optionalWith(S.Array(S.String), { nullable: true }),
  })
{}

export class BrokerAuthenticationScheme extends S.Class<BrokerAuthenticationScheme>("BrokerAuthenticationScheme")({
  brokerType: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  /**
   * Type of authentication for the integration.
   */
  authenticationSchemeType: S.optionalWith(
    S.Literal("usernamePassword", "oAuth", "apiKey", "blockchainAddress", "trueAuth"),
    { nullable: true },
  ),
  /**
   * Set of fields that should be provided in the initial POST `authenticate` request.
   */
  initialAuthenticationModel: S.optionalWith(AuthenticationModel, { nullable: true }),
  /**
   * Set of fields that should be provided depending on the status of the response of the first POST `authenticate` request.
   */
  authenticationSteps: S.optionalWith(S.Array(AuthenticationModel), { nullable: true }),
  /**
   * Supported MFA schemes, can be none or multiple.
   */
  mfaSchemes: S.optionalWith(S.Array(MfaScheme), { nullable: true }),
  /**
   * Optional URL with the instructions explaining how to create a set of API key/secret for the integration, can be shown to the end user.
   */
  instructionsUrl: S.optionalWith(S.String, { nullable: true }),
  trueAuthAuthenticaion: S.optionalWith(BrokerTrueAuthAuthenticationScheme, { nullable: true }),
}) {}

export class BrokerAuthenticationSchemeIReadOnlyCollectionApiResult
  extends S.Class<BrokerAuthenticationSchemeIReadOnlyCollectionApiResult>(
    "BrokerAuthenticationSchemeIReadOnlyCollectionApiResult",
  )({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(S.Array(BrokerAuthenticationScheme), { nullable: true }),
  })
{}

export class ApiV1AuthenticationSchemes401 extends S.Struct({}) {}

export class ApiV1AuthenticateParams extends S.Struct({
  userId: S.String.pipe(S.maxLength(50)),
}) {}

export class CountryInfo extends S.Class<CountryInfo>("CountryInfo")({
  countryCode: S.optionalWith(S.String, { nullable: true }),
  countryNumber: S.optionalWith(S.String, { nullable: true }),
  description: S.optionalWith(S.String, { nullable: true }),
}) {}

export class TrueAuthAuthRequest extends S.Class<TrueAuthAuthRequest>("TrueAuthAuthRequest")({
  requestHeaders: S.NullOr(S.Record({ key: S.String, value: S.Unknown })),
  cookies: S.NullOr(S.Array(S.Record({ key: S.String, value: S.Unknown }))),
  userAgent: S.NullOr(S.String),
}) {}

export class B2BBrokerAuthRequest extends S.Class<B2BBrokerAuthRequest>("B2BBrokerAuthRequest")({
  type: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
  phone: S.optionalWith(S.String, { nullable: true }),
  username: S.optionalWith(S.String, { nullable: true }),
  password: S.optionalWith(S.String, { nullable: true }),
  tradePin: S.optionalWith(S.String, { nullable: true }),
  countryInfo: S.optionalWith(CountryInfo, { nullable: true }),
  challengeId: S.optionalWith(S.String, { nullable: true }),
  challengeCode: S.optionalWith(S.String, { nullable: true }),
  challengeType: S.optionalWith(S.String, { nullable: true }),
  /**
   * Used to provide answers to security questions
   */
  challengeAnswer: S.optionalWith(S.String, { nullable: true }),
  mfaCode: S.optionalWith(S.String, { nullable: true }),
  mfaType: S.optionalWith(
    S.Literal(
      "phone",
      "email",
      "totp",
      "phoneAndEmail",
      "requireNextSecurityQuestion",
      "readEmail",
      "face",
      "tradingPin",
      "qrCode",
      "password",
      "roaming",
      "mobile",
    ),
    { nullable: true },
  ),
  deviceInfo: S.optionalWith(S.String, { nullable: true }),
  webData: S.optionalWith(S.String, { nullable: true }),
  authFlowStep: S.optionalWith(AuthFlowStep, { nullable: true }),
  key: S.optionalWith(S.String, { nullable: true }),
  authToken: S.optionalWith(S.String, { nullable: true }),
  redirectLink: S.optionalWith(S.String, { nullable: true }),
  confirmationEmail: S.optionalWith(S.String, { nullable: true }),
  trueAuthAuthRequest: S.optionalWith(TrueAuthAuthRequest, { nullable: true }),
  /**
   * Indicates whether the sensitive fields in this request are encrypted.
   * When set to true, the following fields should be encrypted using Base64 encoding:
   * - Username
   * - Password
   * - Phone
   * - TradePin
   * - ChallengeAnswer
   * - MfaCode
   * - DeviceInfo
   * - ConfirmationEmail
   *
   * Base64 encoding is used to encode these fields into a format that can be safely transmitted and stored.
   */
  isSensitiveFieldsEncrypted: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Flag indicating that the user is attempting to switch to the next available 2FA
   * method (e.g., Email, Google Authenticator) after failing to complete or canceling
   * the current verification method (e.g., Roaming 2FA).
   *
   * This field is primarily used for Robinhood and BinanceInternationalDirect on the DeviceConfirmationPage
   * when a user clicks the "Try Another Way" button. It informs the backend to move to the next
   * MFA method instead of retrying the current one.
   */
  isTryingAnotherWay: S.optionalWith(S.Boolean, { nullable: true }),
}) {}

export class B2BBrokerAuthResponseApiResult
  extends S.Class<B2BBrokerAuthResponseApiResult>("B2BBrokerAuthResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerAuthResponse, { nullable: true }),
  })
{}

export class ProblemDetails extends S.Class<ProblemDetails>("ProblemDetails")({
  type: S.optionalWith(S.String, { nullable: true }),
  title: S.optionalWith(S.String, { nullable: true }),
  status: S.optionalWith(S.Int, { nullable: true }),
  detail: S.optionalWith(S.String, { nullable: true }),
  instance: S.optionalWith(S.String, { nullable: true }),
}) {}

export class ApiV1AuthenticateBrokerTypeParams extends S.Struct({
  userId: S.String,
}) {}

export class BrokerAuthPromptStatus extends S.Literal("failed", "redirect", "openInBrokerModule") {}

export class B2BBrokerAuthPromptResponse extends S.Class<B2BBrokerAuthPromptResponse>("B2BBrokerAuthPromptResponse")({
  status: S.optionalWith(S.Literal("failed", "redirect", "openInBrokerModule"), { nullable: true }),
  redirectLink: S.optionalWith(S.String, { nullable: true }),
  linkToken: S.optionalWith(S.String, { nullable: true }),
  errorMessage: S.optionalWith(S.String, { nullable: true }),
}) {}

export class B2BBrokerAuthPromptResponseApiResult
  extends S.Class<B2BBrokerAuthPromptResponseApiResult>("B2BBrokerAuthPromptResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerAuthPromptResponse, { nullable: true }),
  })
{}

export class FinancialInstitutionIntegrationType
  extends S.Literal("brokerage", "bank", "exchange", "wallet", "address", "nftMarketplace", "deFiWallet")
{}

/**
 * Integration style
 */
export class IntegrationStyle extends S.Class<IntegrationStyle>("IntegrationStyle")({
  /**
   * Field Active Light Hex Color
   */
  fieldActiveLight: S.optionalWith(S.String, { nullable: true }),
  /**
   * Button Primary Light Hex Color
   */
  buttonPrimaryLight: S.optionalWith(S.String, { nullable: true }),
  /**
   * Button Hover Light Hex Color
   */
  buttonHoverLight: S.optionalWith(S.String, { nullable: true }),
  /**
   * Button Text Light Hex Color
   */
  buttonTextLight: S.optionalWith(S.String, { nullable: true }),
  /**
   * Button Text Hover Light Hex Color
   */
  buttonTextHoverLight: S.optionalWith(S.String, { nullable: true }),
  /**
   * Field Active Dark Hex Color
   */
  fieldActiveDark: S.optionalWith(S.String, { nullable: true }),
  /**
   * Button Primary Dark Hex Color
   */
  buttonPrimaryDark: S.optionalWith(S.String, { nullable: true }),
  /**
   * Button Hover Dark Hex Color
   */
  buttonHoverDark: S.optionalWith(S.String, { nullable: true }),
  /**
   * Button Text Dark Hex Color
   */
  buttonTextDark: S.optionalWith(S.String, { nullable: true }),
  /**
   * Button Text Hover Dark Hex Color
   */
  buttonTextHoverDark: S.optionalWith(S.String, { nullable: true }),
}) {}

/**
 * Integreation logos.
 */
export class IntegrationLogo extends S.Class<IntegrationLogo>("IntegrationLogo")({
  /**
   * Light logo url.
   */
  logoLightUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Dark logo url.
   */
  logoDarkUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * White logo url.
   */
  logoWhiteUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Black logo url.
   */
  logoBlackUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Colored logo url.
   */
  logoColorUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * White icon url.
   */
  iconLightUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Light icon url.
   */
  iconDarkUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Dark icon url.
   */
  iconWhiteUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Balck icon url.
   */
  iconBlackUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Colored logo url.
   */
  iconColorUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Base64 PNG logo.
   */
  base64Logo: S.optionalWith(S.String, { nullable: true }),
}) {}

/**
 * Integration model.
 */
export class IntegrationModel extends S.Class<IntegrationModel>("IntegrationModel")({
  /**
   * Integration unique identifier.
   */
  id: S.optionalWith(S.String, { nullable: true }),
  /**
   * Integration name.
   */
  name: S.optionalWith(S.String, { nullable: true }),
  /**
   * Integration type.
   */
  type: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  /**
   * DeFi wallet provider identifier.
   */
  deFiWalletProviderId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Integration categories.
   */
  categories: S.optionalWith(S.Array(FinancialInstitutionIntegrationType), { nullable: true }),
  /**
   * Style object.
   */
  style: S.optionalWith(IntegrationStyle, { nullable: true }),
  /**
   * Logo object.
   */
  logo: S.optionalWith(IntegrationLogo, { nullable: true }),
  /**
   * Forgot Password Link.
   */
  forgotPasswordLink: S.optionalWith(S.String, { nullable: true }),
  /**
   * Indicates if crypto transfers supported by integration.
   */
  cryptoTransfersSupported: S.optionalWith(S.Boolean, { nullable: true }),
}) {}

/**
 * Integration response.
 */
export class IntegrationsResponse extends S.Class<IntegrationsResponse>("IntegrationsResponse")({
  /**
   * Integrations list.
   */
  items: S.optionalWith(S.Array(IntegrationModel), { nullable: true }),
}) {}

export class IntegrationsResponseApiResult
  extends S.Class<IntegrationsResponseApiResult>("IntegrationsResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    /**
     * Integration response.
     */
    content: S.optionalWith(IntegrationsResponse, { nullable: true }),
  })
{}

export class NetworkResponseToken extends S.Class<NetworkResponseToken>("NetworkResponseToken")({
  symbol: S.optionalWith(S.String, { nullable: true }),
  logoUrl: S.optionalWith(S.String, { nullable: true }),
}) {}

/**
 * Crypto network.
 */
export class NetworkResponseWithIntegrations
  extends S.Class<NetworkResponseWithIntegrations>("NetworkResponseWithIntegrations")({
    /**
     * The Id of the network in Mesh system. Should be used to initiate transfers.
     */
    id: S.optionalWith(S.String, { nullable: true }),
    /**
     * The name if the network.
     */
    name: S.optionalWith(S.String, { nullable: true }),
    /**
     * The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137.
     */
    chainId: S.optionalWith(S.String, { nullable: true }),
    /**
     * Network logo URL.
     */
    logoUrl: S.optionalWith(S.String, { nullable: true }),
    /**
     * The list of tokens that are currently supported to be transferred using the network.
     */
    supportedTokens: S.optionalWith(S.Array(S.String), { nullable: true }),
    /**
     * The symbol of the network's native cryptocurrency.
     */
    nativeSymbol: S.optionalWith(S.String, { nullable: true }),
    /**
     * Network type.
     */
    networkType: S.optionalWith(
      S.Literal(
        "unknown",
        "evm",
        "solana",
        "bitcoin",
        "cardano",
        "tron",
        "avalancheX",
        "tezos",
        "dogecoin",
        "ripple",
        "stellar",
        "litecoin",
        "sui",
        "aptos",
        "tvm",
        "injective",
      ),
      { nullable: true },
    ),
    /**
     * The list of tokens that are currently supported to be transferred using the network.
     */
    tokens: S.optionalWith(S.Array(NetworkResponseToken), { nullable: true }),
    /**
     * The list of types of integrations that are currently supported to perform transfers over the network.
     */
    supportedBrokerTypes: S.optionalWith(S.Array(BrokerType), { nullable: true }),
  })
{}

export class NetworkModelResponse extends S.Class<NetworkModelResponse>("NetworkModelResponse")({
  networks: S.optionalWith(S.Array(NetworkResponseWithIntegrations), { nullable: true }),
}) {}

export class NetworkModelResponseApiResult
  extends S.Class<NetworkModelResponseApiResult>("NetworkModelResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(NetworkModelResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedNetworks401 extends S.Struct({}) {}

export class DeviceType extends S.Literal("unknown", "android", "ios", "web") {}

export class NetworkResponseWithSupportedDevices
  extends S.Class<NetworkResponseWithSupportedDevices>("NetworkResponseWithSupportedDevices")({
    /**
     * The Id of the network in Mesh system. Should be used to initiate transfers.
     */
    id: S.optionalWith(S.String, { nullable: true }),
    /**
     * The name if the network.
     */
    name: S.optionalWith(S.String, { nullable: true }),
    /**
     * The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137.
     */
    chainId: S.optionalWith(S.String, { nullable: true }),
    /**
     * Network logo URL.
     */
    logoUrl: S.optionalWith(S.String, { nullable: true }),
    /**
     * The list of tokens that are currently supported to be transferred using the network.
     */
    supportedTokens: S.optionalWith(S.Array(S.String), { nullable: true }),
    /**
     * The symbol of the network's native cryptocurrency.
     */
    nativeSymbol: S.optionalWith(S.String, { nullable: true }),
    supportedDevices: S.optionalWith(S.Array(DeviceType), { nullable: true }),
  })
{}

export class IntegrationNetworksModelResponse
  extends S.Class<IntegrationNetworksModelResponse>("IntegrationNetworksModelResponse")({
    /**
     * Integration unique identifier.
     */
    id: S.optionalWith(S.String, { nullable: true }),
    /**
     * Type of the integration.
     */
    type: S.optionalWith(
      S.Literal(
        "robinhood",
        "eTrade",
        "alpaca",
        "tdAmeritrade",
        "weBull",
        "stash",
        "interactiveBrokers",
        "public",
        "coinbase",
        "kraken",
        "coinbasePro",
        "cryptoCom",
        "openSea",
        "binanceUs",
        "gemini",
        "cryptocurrencyAddress",
        "cryptocurrencyWallet",
        "okCoin",
        "bittrex",
        "kuCoin",
        "etoro",
        "cexIo",
        "binanceInternational",
        "bitstamp",
        "gateIo",
        "acorns",
        "okx",
        "bitFlyer",
        "coinlist",
        "huobi",
        "bitfinex",
        "deFiWallet",
        "krakenDirect",
        "vanguard",
        "binanceInternationalDirect",
        "bitfinexDirect",
        "bybit",
        "paxos",
        "coinbasePrime",
        "btcTurkDirect",
        "kuCoinDirect",
        "okxOAuth",
        "paribuDirect",
        "robinhoodConnect",
        "blockchainCom",
        "bitsoDirect",
        "binanceConnect",
        "binanceOAuth",
        "revolutConnect",
        "binancePay",
        "bybitDirect",
        "paribuOAuth",
        "payPalConnect",
        "binanceTrDirect",
        "coinbaseRamp",
        "bybitDirectMobile",
      ),
      { nullable: true },
    ),
    /**
     * Name of the integration.
     */
    name: S.optionalWith(S.String, { nullable: true }),
    /**
     * The list of supported networks and corresponding tokens for the integration.
     */
    networks: S.optionalWith(S.Array(NetworkResponseWithSupportedDevices), { nullable: true }),
    /**
     * Specifies if the integration supports outgoing transfers.
     */
    supportsOutgoingTransfers: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Specifies if the integration supports incoming transfers.
     */
    supportsIncomingTransfers: S.optionalWith(S.Boolean, { nullable: true }),
  })
{}

export class IntegrationNetworkResponse extends S.Class<IntegrationNetworkResponse>("IntegrationNetworkResponse")({
  integrations: S.optionalWith(S.Array(IntegrationNetworksModelResponse), { nullable: true }),
}) {}

export class IntegrationNetworkResponseApiResult
  extends S.Class<IntegrationNetworkResponseApiResult>("IntegrationNetworkResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(IntegrationNetworkResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedIntegrations401 extends S.Struct({}) {}

/**
 * Crypto network.
 */
export class NetworkResponseBase extends S.Class<NetworkResponseBase>("NetworkResponseBase")({
  /**
   * The Id of the network in Mesh system. Should be used to initiate transfers.
   */
  id: S.optionalWith(S.String, { nullable: true }),
  /**
   * The name if the network.
   */
  name: S.optionalWith(S.String, { nullable: true }),
  /**
   * The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137.
   */
  chainId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Network logo URL.
   */
  logoUrl: S.optionalWith(S.String, { nullable: true }),
}) {}

export class IntegrationNetwork extends S.Class<IntegrationNetwork>("IntegrationNetwork")({
  networkId: S.optionalWith(S.String, { nullable: true }),
  netwokName: S.optionalWith(S.String, { nullable: true }),
  innerNetworkId: S.optionalWith(S.String, { nullable: true }),
  networkLogo: S.optionalWith(S.String, { nullable: true }),
  brokerType: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
}) {}

export class TokenNetworksModel extends S.Class<TokenNetworksModel>("TokenNetworksModel")({
  token: S.optionalWith(S.String, { nullable: true }),
  networks: S.optionalWith(S.Array(NetworkResponseBase), { nullable: true }),
  supportedIntegrations: S.optionalWith(S.Array(BrokerType), { nullable: true }),
  integrationNetworks: S.optionalWith(S.Array(IntegrationNetwork), { nullable: true }),
  tokenLogoUrl: S.optionalWith(S.String, { nullable: true }),
}) {}

export class TokenNetworksResponse extends S.Class<TokenNetworksResponse>("TokenNetworksResponse")({
  tokens: S.optionalWith(S.Array(TokenNetworksModel), { nullable: true }),
}) {}

export class TokenNetworksResponseApiResult
  extends S.Class<TokenNetworksResponseApiResult>("TokenNetworksResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(TokenNetworksResponse, { nullable: true }),
  })
{}

export class TransferVerificationRequest extends S.Class<TransferVerificationRequest>("TransferVerificationRequest")({
  integrationId: S.optionalWith(S.String, { nullable: true }),
  token: S.optionalWith(S.String, { nullable: true }),
  networkId: S.optionalWith(S.String, { nullable: true }),
  targetAddress: S.optionalWith(S.String, { nullable: true }),
}) {}

export class TransferVerifyStatus extends S.Literal("succeeded", "failed") {}

export class FailureReason
  extends S.Literal("notSupportedOnIntegration", "notSupportedOnNetwork", "invalidAddressFormat", "notSupportedOnToken")
{}

export class TransferVerificationResponse
  extends S.Class<TransferVerificationResponse>("TransferVerificationResponse")({
    status: S.optionalWith(S.Literal("succeeded", "failed"), { nullable: true }),
    errorMessage: S.optionalWith(S.String, { nullable: true }),
    failureReason: S.optionalWith(FailureReason, { nullable: true }),
  })
{}

export class TransferVerificationResponseApiResult
  extends S.Class<TransferVerificationResponseApiResult>("TransferVerificationResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(TransferVerificationResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedVerify401 extends S.Struct({}) {}

export class TransferToAddress extends S.Class<TransferToAddress>("TransferToAddress")({
  /**
   * The Id of the network in Front system. The list of all available networks can be obtained by
   * using `GET /transfers/managed/networks` endpoint.
   */
  networkId: S.optionalWith(S.String, { nullable: true }),
  /**
   * The symbol of the digital asset.
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * The address to send the asset to.
   */
  address: S.optionalWith(S.String, { nullable: true }),
  /**
   * Secondary address identifier for coins like XRP,XMR etc.
   */
  addressTag: S.optionalWith(S.String, { nullable: true }),
}) {}

export class ConfigureTransferRequest extends S.Class<ConfigureTransferRequest>("ConfigureTransferRequest")({
  /**
   * The authentication token to send assets from.
   */
  fromAuthToken: S.String.pipe(S.minLength(1)),
  /**
   * The type of the integration to send assets from.
   */
  fromType: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
  /**
   * The authentication token of the target integration. Can be used alternatively to the list of requested address (`toAddresses`).
   * If used, `toType` should also be provided.
   */
  toAuthToken: S.optionalWith(S.String, { nullable: true }),
  /**
   * The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `toAddresses`.
   */
  toType: S.optionalWith(BrokerType, { nullable: true }),
  /**
   * A list of available addresses provided by the API client. The list can contain all supported addresses by the client.
   * Front API validates the addresses and returns the list of supported tokens and networks as the result of the operation.
   */
  toAddresses: S.optionalWith(S.Array(TransferToAddress), { nullable: true }),
  /**
   * If provided, Front API returns only networks that support transferring of this symbol.
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * If provided, Front API configures the response to only return holdings with enough amount of this crypto for the transfer
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * If provided, Front API configures the response to only contain holdings with enough value (converted to fiat) for the transfer.
   */
  amountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`.
   */
  fiatCurrency: S.optionalWith(S.String, { nullable: true }),
  /**
   * If provided, from API configures the response to include the requested network only.
   */
  networkId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Specifies if all the fees are included in the amount to transfer.
   */
  isInclusiveFeeEnabled: S.optionalWith(S.Boolean, { nullable: true }),
}) {}

export class ConfigureTransferStatus
  extends S.Literal(
    "succeeded",
    "failed",
    "validationFailed",
    "notAuthorizedTo",
    "notAuthorizedFrom",
    "kycRequired",
    "fromIntegrationNotSupported",
    "toIntegrationNotSupported",
  )
{}

export class TransferFee extends S.Class<TransferFee>("TransferFee")({
  /**
   * The amount of the fee.
   */
  fee: S.optionalWith(S.Number, { nullable: true }),
  /**
   * The currency of the fee. Does not match the currency of the transfer in some cases.
   */
  feeCurrency: S.optionalWith(S.String, { nullable: true }),
  /**
   * The value of the fee converted to the fiat currency.
   */
  feeInFiat: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class NetworkTransferIneligibilityReason
  extends S.Literal(
    "amountNotSufficient",
    "gasFeeAssetBalanceNotEnough",
    "noTargetNetworkFound",
    "refusedByInstitution",
    "eligibleWithFunding",
    "balanceBelowRequestedAmount",
    "requestedAmountBelowMinimum",
    "balanceBelowMinimum",
    "requestedAmountBelowFees",
    "requestedAmountBelowClientMinimum",
    "requestedAmountAboveClientMaximum",
    "noPrice",
    "nyCoinbaseUserRestrictions",
  )
{}

export class ConfigureTransferResultNetwork
  extends S.Class<ConfigureTransferResultNetwork>("ConfigureTransferResultNetwork")({
    /**
     * The name of the network.
     */
    name: S.optionalWith(S.String, { nullable: true }),
    /**
     * The Id of the network in Front system.
     */
    id: S.optionalWith(S.String, { nullable: true }),
    /**
     * Then minimum amount that can be withdrawn using this network.
     */
    minimumAmount: S.optionalWith(S.Number, { nullable: true }),
    /**
     * The maximum amount that can be withdrawn using this network.
     */
    maximumAmount: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Total estimated transfer fee converted to fiat. Can consist of the fee taken by the financial institution and the
     * gas fee.
     */
    totalEstimatedTransferFeeInFiat: S.optionalWith(S.Number, { nullable: true }),
    /**
     * The minimum amount that can be withdrawn using this network, converted to fiat currency.
     */
    minimumAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
    /**
     * The maximum amount that can be withdrawn using this network, converted to fiat currency.
     */
    maximumAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
    /**
     * The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be
     * covered by the `InstitutionTransferFee`.
     */
    estimatedNetworkGasFee: S.optionalWith(TransferFee, { nullable: true }),
    /**
     * The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not
     * take the transfer fee and only network fee is used for the transfer.
     */
    institutionTransferFee: S.optionalWith(TransferFee, { nullable: true }),
    /**
     * Specifies if the asset is eligible for a transfer over the current network.
     */
    eligibleForTransfer: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * The reason indicating why the transfer cannot be performed over this network.
     */
    ineligibilityReason: S.optionalWith(NetworkTransferIneligibilityReason, { nullable: true }),
    eligibleForTransferWithFunding: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * The designated destination for sending the asset.
     */
    toAddress: S.optionalWith(S.String, { nullable: true }),
    /**
     * Token's amount to transfer specified by the client.
     */
    transferAmount: S.optionalWith(S.Number, { nullable: true }),
    /**
     * The minimum amount of cryptocurrency that is required to be present in the account to perform the transfer.
     * Unlike `minimum` field that indicates the minimum amount that can generally be transferred, this field indicates the minimum
     * that can be transferred given the current transfer configuration values, such as `amountInFiat` and `clientFee`.
     */
    minimumRequiredForTransferAmount: S.optionalWith(S.Number, { nullable: true }),
    caipNetworkId: S.optionalWith(S.String, { nullable: true }),
    /**
     * Logo url for network.
     */
    logoUrl: S.optionalWith(S.String, { nullable: true }),
  })
{}

export class HoldingTransferIneligibilityReason
  extends S.Literal(
    "noEligibleNetworks",
    "symbolDoesNotMatch",
    "notSupportedForTransferByTarget",
    "notSupportedForTransferBySource",
    "eligibleWithFunding",
    "amountNotSufficient",
    "noPrice",
  )
{}

export class ConfigureTransferResultHolding
  extends S.Class<ConfigureTransferResultHolding>("ConfigureTransferResultHolding")({
    /**
     * The symbol of the digital asset on the source account.
     */
    symbol: S.optionalWith(S.String, { nullable: true }),
    /**
     * The available balance of the digital asset.
     */
    availableBalance: S.optionalWith(S.Number, { nullable: true }),
    /**
     * The available balance of the digital asset, converted to fiat currency.
     */
    availableBalanceInFiat: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Specifies if the asset is eligible for a transfer.
     */
    eligibleForTransfer: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Supported networks.
     */
    networks: S.optionalWith(S.Array(ConfigureTransferResultNetwork), { nullable: true }),
    /**
     * The reason indicating why the transfer of the current asset cannot be performed.
     */
    ineligibilityReason: S.optionalWith(HoldingTransferIneligibilityReason, { nullable: true }),
    /**
     * Indicates that the asset is not eligible for a transfer with the current holding balance,
     * but can be made eligible after funding the balance using the cryptocurrency balance funding feature.
     */
    eligibleForTransferWithFunding: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Logo url for holding.
     */
    logoUrl: S.optionalWith(S.String, { nullable: true }),
    /**
     * Specifies if the asset is used for bridging between networks.
     */
    isBridgingAsset: S.optionalWith(S.Boolean, { nullable: true }),
  })
{}

export class TransferBalanceFundingAvailabilityStatus
  extends S.Literal("disabled", "available", "requiresAmountLowering", "notApplicable", "unavailable")
{}

export class TransferBalanceFundingAvailabilityBase
  extends S.Class<TransferBalanceFundingAvailabilityBase>("TransferBalanceFundingAvailabilityBase")({
    status: S.optionalWith(
      S.Literal("disabled", "available", "requiresAmountLowering", "notApplicable", "unavailable"),
      { nullable: true },
    ),
  })
{}

export class ConfigureTransferResponse extends S.Class<ConfigureTransferResponse>("ConfigureTransferResponse")({
  /**
   * Status of the operation.
   */
  status: S.optionalWith(
    S.Literal(
      "succeeded",
      "failed",
      "validationFailed",
      "notAuthorizedTo",
      "notAuthorizedFrom",
      "kycRequired",
      "fromIntegrationNotSupported",
      "toIntegrationNotSupported",
    ),
    { nullable: true },
  ),
  /**
   * List of holdings on the source account.
   */
  holdings: S.optionalWith(S.Array(ConfigureTransferResultHolding), { nullable: true }),
  /**
   * Amount in USD to transfer.
   */
  amountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Used fiat currency.
   */
  fiatCurrency: S.optionalWith(S.String, { nullable: true }),
  /**
   * Minimum transfer amount in fiat.
   */
  minimumTransferAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Maximum transfer amount in fiat
   */
  maximumTransferAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Supported fiat currencies for this transfer
   */
  supportedFiatCurrencies: S.optionalWith(S.Array(S.String), { nullable: true }),
  transferBalanceFundingAvailability: S.optionalWith(TransferBalanceFundingAvailabilityBase, { nullable: true }),
}) {}

export class ConfigureTransferResponseApiResult
  extends S.Class<ConfigureTransferResponseApiResult>("ConfigureTransferResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(ConfigureTransferResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedConfigure401 extends S.Struct({}) {}

export class ApiV1TransfersManagedConfigure403 extends S.Struct({}) {}

export class PreviewTransferRequest extends S.Class<PreviewTransferRequest>("PreviewTransferRequest")({
  /**
   * The authentication token to send the asset from.
   */
  fromAuthToken: S.String.pipe(S.minLength(1)),
  /**
   * The type of the integration to send the asset from.
   */
  fromType: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
  /**
   * The authentication token of the target integration. Can be used alternatively to the address in the `ToAddress` field.
   * If used, `toType` should also be provided.
   */
  toAuthToken: S.optionalWith(S.String, { nullable: true }),
  /**
   * The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `ToAddress`.
   */
  toType: S.optionalWith(BrokerType, { nullable: true }),
  /**
   * The network to send the asset over.
   */
  networkId: S.optionalWith(S.String, { nullable: true }),
  /**
   * The symbol of the digital asset to send.
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * The target address to send the asset to.
   */
  toAddress: S.optionalWith(S.String, { nullable: true }),
  /**
   * Secondary address identifier for coins like XRP,XMR etc.
   */
  addressTag: S.optionalWith(S.String, { nullable: true }),
  /**
   * The amount to send, in crypto.
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * The amount to send, in fiat currency. Can be used alternatively to `Amount`.
   */
  amountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`.
   */
  fiatCurrency: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transaction ID Provided by client to track transaction in future calls.
   */
  transactionId: S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
  /**
   * Indicates that the transfer is a bridging transfer.
   */
  isBridging: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Specifies if all the fees are included in the amount to transfer.
   */
  isInclusiveFeeEnabled: S.optionalWith(S.Boolean, { nullable: true }),
}) {}

export class PreviewTransferStatus extends S.Literal("succeeded", "failed", "requiresFunding") {}

export class TransferFeeDetails extends S.Class<TransferFeeDetails>("TransferFeeDetails")({
  /**
   * Units of gas used
   */
  gasLimit: S.optionalWith(S.Number, { nullable: true }),
  /**
   * The max amount of tip to be paid to validator
   */
  maxPriorityFeePerGas: S.optionalWith(S.Number, { nullable: true }),
  /**
   * The max amount of fee to be paid per gas
   */
  maxFeePerGas: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class ProcessingFeeRetainType extends S.Literal("default", "smartDeposit") {}

export class ProcessingFeeRetainMethod extends S.Class<ProcessingFeeRetainMethod>("ProcessingFeeRetainMethod")({
  type: S.optionalWith(S.Literal("default", "smartDeposit"), { nullable: true }),
  processingFeeAddress: S.optionalWith(S.String, { nullable: true }),
}) {}

export class BridgingDetails extends S.Class<BridgingDetails>("BridgingDetails")({
  /**
   * The ID of the bridging direction that was used to generate the preview.
   */
  bridgingDirectionId: S.optionalWith(S.String, { nullable: true }),
  targetAddress: S.optionalWith(S.String, { nullable: true }),
}) {}

export class PreviewTransferResult extends S.Class<PreviewTransferResult>("PreviewTransferResult")({
  /**
   * The Id of the preview of the transfer. Should be used to commit the transfer using `Execute` endpoint.
   */
  previewId: S.optionalWith(S.String, { nullable: true }),
  /**
   * The period of time in seconds during which the transfer can be committed.
   */
  previewExpiresIn: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Obtained address that will be used to send the transfer. Not guaranteed to be returned by some of integrations.
   */
  fromAddress: S.optionalWith(S.String, { nullable: true }),
  /**
   * Obtained address that will be used to refund the transfer. Not guaranteed to be returned by some of integrations.
   */
  refundAddress: S.optionalWith(S.String, { nullable: true }),
  /**
   * The target address to send the asset to.
   */
  toAddress: S.optionalWith(S.String, { nullable: true }),
  /**
   * Secondary address identifier for coins like XRP, XMR etc.
   */
  addressTag: S.optionalWith(S.String, { nullable: true }),
  /**
   * Symbol of the asset to be sent.
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Amount in symbol. If the transfer was requested using `AmountInFiat` field, this field represents the exact amount
   * of the asset that will be transferred.
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Transfer amount in fiat. If the transfer was requested in crypto amount using the `Amount` field,
   * this field contains the corresponding converted to fiat value.
   */
  amountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total estimated amount of the transfer including all fees, in cryptocurrency.
   */
  totalEstimatedAmount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total estimated amount of the transfer including all fees, converted to fiat.
   */
  totalEstimatedAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Id of the network in Front system.
   */
  networkId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Name of the network in Front system.
   */
  networkName: S.optionalWith(S.String, { nullable: true }),
  /**
   * Blockchain address of the transferred token's contract
   */
  contractAddress: S.optionalWith(S.String, { nullable: true }),
  /**
   * The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not
   * take the transfer fee and only network fee is used for the transfer.
   */
  institutionTransferFee: S.optionalWith(TransferFee, { nullable: true }),
  /**
   * The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be
   * covered by the `InstitutionTransferFee`.
   */
  estimatedNetworkGasFee: S.optionalWith(TransferFee, { nullable: true }),
  /**
   * The gas fee values in EIP 1559 standard that is estimated to be taken by the network.
   */
  estimatedNetworkGasFeeDetails: S.optionalWith(TransferFeeDetails, { nullable: true }),
  /**
   * Number of decimal places used to represent the token's smallest unit
   */
  decimalPlaces: S.optionalWith(S.Int, { nullable: true }),
  /**
   * The price of the cryptocurrency asset in the fiat currency.
   */
  unitPrice: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Transaction id provided by the client
   */
  clientTransactionId: S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
  /**
   * A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments.
   * This will override any default fee entered in your Mesh dashboard for an individual transaction.
   * Please note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),
   * and not for Deposits (when the transfer destination is an address owned by the end user).
   * If used for Deposits, it will increase the size of the user's Deposit by the fee amount,
   * but will incorrectly show to the user as a fee.
   */
  clientFee: S.optionalWith(S.Number.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(1)), { nullable: true }),
  /**
   * The client fee that is estimated to be added to the total estimated transfer amount, based on the user's requested transfer amount and client fee percentage.
   */
  customClientFee: S.optionalWith(TransferFee, { nullable: true }),
  processingFeeRetainMethod: S.optionalWith(ProcessingFeeRetainMethod, { nullable: true }),
  /**
   * Deposit: The user is transferring crypto to a wallet they own on your platform.
   * Payment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.
   * Onramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.
   */
  transferType: S.optionalWith(S.Literal("deposit", "payment", "onramp"), { nullable: true }),
  isCustomClientFeeProvided: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Amount in symbol after the client fees are applied. This field represents the exact amount
   * of the asset that will be requested for transfer.
   */
  amountWithCustomClientFee: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Indicates if all the fees are included in the amount. For example, if this field's value is `true`
   * and the user wants to send 1 BTC and the sum of all fees is 0.1 BTC, the user will be charged 1 BTC, and
   * the target address will receive 0.9 BTC.
   * If the fees are no inclusive, the user will be charged 1.1 BTC and the target address will receive 1 BTC.
   */
  isFeeIncluded: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Indicates the final amount to receive after all fees are applied. In case fees are not inclusive (`IsFeeIncluded` is `false`),
   * this field will be equal to the `Amount` field.
   */
  amountToReceive: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Indicates the final amount in fiat to receive after all fees are applied. In case fees are not inclusive (`IsFeeIncluded` is `false`),
   * this field will be equal to the `AmountInFiat` field.
   */
  amountToReceiveInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Exact amount in cryptocurrency requested to transfer to the destination address using the target integration.
   */
  transferAmountToRequest: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Indicates if the transfer's intention is to transfer all available assets using the requested network and symbol.
   */
  isMaximumAmount: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Indicates the fiat currency that is used to calculate transfer amounts.
   */
  fiatCurrency: S.optionalWith(S.String, { nullable: true }),
  /**
   * Indicates if the transfer is a bridging transfer, meaning that the transfer will be swapped between two different networks.
   */
  isBridging: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Details of the bridging operation, in case the transfer is a bridging transfer.
   */
  bridgingDetails: S.optionalWith(BridgingDetails, { nullable: true }),
}) {}

export class TransferBalanceFundingAvailability
  extends S.Class<TransferBalanceFundingAvailability>("TransferBalanceFundingAvailability")({
    status: S.optionalWith(TransferBalanceFundingAvailabilityStatus, { nullable: true }),
    /**
     * The total transfer amount in crypto after all fees are applied
     */
    transferTotalAmount: S.optionalWith(S.Number, { nullable: true }),
    /**
     * The price of the cryptocurrency asset in the fiat currency.
     */
    unitPrice: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Represents the safety margin amount to cover gas fee volatility.
     */
    gasFeeBuffer: S.optionalWith(TransferFee, { nullable: true }),
    symbol: S.optionalWith(S.String, { nullable: true }),
    /**
     * The total transfer amount in fiat after all fees are applied.
     */
    transferTotalAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
  })
{}

export class TransferFromAnotherAccountAvailabilityInfo
  extends S.Class<TransferFromAnotherAccountAvailabilityInfo>("TransferFromAnotherAccountAvailabilityInfo")({
    transferFromAnotherAccountNeeded: S.optionalWith(S.Boolean, { nullable: true }),
    transferFromAnotherAccountAmount: S.optionalWith(S.Number, { nullable: true }),
    anotherAccountName: S.optionalWith(S.String, { nullable: true }),
  })
{}

export class PreviewTransferResponse extends S.Class<PreviewTransferResponse>("PreviewTransferResponse")({
  /**
   * The status of the operation.
   */
  status: S.optionalWith(S.Literal("succeeded", "failed", "requiresFunding"), { nullable: true }),
  /**
   * Result of the preview.
   */
  previewResult: S.optionalWith(PreviewTransferResult, { nullable: true }),
  transferBalanceFundingAvailability: S.optionalWith(TransferBalanceFundingAvailability, { nullable: true }),
  /**
   * For instance if not enough assets in Spot account, and we can fill it from Funding account
   */
  transferFromAnotherAccountAvailabilityInfo: S.optionalWith(TransferFromAnotherAccountAvailabilityInfo, {
    nullable: true,
  }),
}) {}

export class PreviewTransferResponseApiResult
  extends S.Class<PreviewTransferResponseApiResult>("PreviewTransferResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(PreviewTransferResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedPreview401 extends S.Struct({}) {}

export class ApiV1TransfersManagedPreview403 extends S.Struct({}) {}

export class ExecuteTransferRequest extends S.Class<ExecuteTransferRequest>("ExecuteTransferRequest")({
  /**
   * The authentication token to send the asset from.
   */
  fromAuthToken: S.String.pipe(S.minLength(1)),
  /**
   * The type of the integration to send the asset from.
   */
  fromType: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
  /**
   * Id of the Preview of the transfer.
   */
  previewId: S.String,
  /**
   * Multi-factor auth code that should be provided if the status of the transfer was `MfaRequired`.
   */
  mfaCode: S.optionalWith(S.String, { nullable: true }),
  /**
   * When user is unable to provide the primary Mfa this should be passed in to use fallback Mfa.
   */
  tryAnotherMfa: S.optionalWith(S.Boolean, { nullable: true }),
  challengeId: S.optionalWith(S.String, { nullable: true }),
}) {}

export class ExecuteTransferStatus
  extends S.Literal(
    "succeeded",
    "inProgress",
    "failed",
    "mfaRequired",
    "emailConfirmationRequired",
    "deviceConfirmationRequired",
    "mfaFailed",
    "addressWhitelistRequired",
    "secondMfaRequired",
    "deFiWalletConfirmationRequired",
    "emailConfirmationApprovalRequired",
  )
{}

export class ExecuteTransferMfaType
  extends S.Literal("unspecified", "phone", "email", "totp", "face", "tradingPin", "mobile")
{}

export class BrokerCryptocurrencyTransactionStatus
  extends S.Literal(
    "unknown",
    "failed",
    "frozen",
    "succeeded",
    "mfaRequired",
    "pending",
    "expired",
    "canceled",
    "waitingForSignature",
    "waitingForClearing",
    "awaitingApproval",
    "awaitingConfirmation",
    "awaitingVerification",
    "rejected",
    "pendingCancel",
    "emailVerification",
    "deviceConfirmationRequired",
    "mfaFailed",
    "addressWhitelistRequired",
    "secondMfaRequired",
    "emailConfirmationApprovalRequired",
    "travelRuleRequired",
  )
{}

export class SmartContractTransferAllocation
  extends S.Class<SmartContractTransferAllocation>("SmartContractTransferAllocation")({
    /**
     * Blockchain address of the Smart Contract
     */
    address: S.optionalWith(S.String, { nullable: true }),
    /**
     * The timestamp by which the transfer must be completely initiated. Currently, this means solving the MFA steps
     */
    expirationTimestamp: S.optionalWith(S.Int, { nullable: true }),
  })
{}

export class ExecuteTransferResultResponse
  extends S.Class<ExecuteTransferResultResponse>("ExecuteTransferResultResponse")({
    /**
     * The Id of the transfer by the integration.
     */
    transferId: S.optionalWith(S.String, { nullable: true }),
    /**
     * The current status of the transfer.
     */
    status: S.optionalWith(
      S.Literal(
        "unknown",
        "failed",
        "frozen",
        "succeeded",
        "mfaRequired",
        "pending",
        "expired",
        "canceled",
        "waitingForSignature",
        "waitingForClearing",
        "awaitingApproval",
        "awaitingConfirmation",
        "awaitingVerification",
        "rejected",
        "pendingCancel",
        "emailVerification",
        "deviceConfirmationRequired",
        "mfaFailed",
        "addressWhitelistRequired",
        "secondMfaRequired",
        "emailConfirmationApprovalRequired",
        "travelRuleRequired",
      ),
      { nullable: true },
    ),
    /**
     * Details of the current status of the transfer, as provided by the integration.
     */
    statusDetails: S.optionalWith(S.String, { nullable: true }),
    /**
     * The address of the source account or wallet.
     */
    fromAddress: S.optionalWith(S.String, { nullable: true }),
    /**
     * The address of the target account or wallet.
     */
    toAddress: S.optionalWith(S.String, { nullable: true }),
    /**
     * Transferred symbol.
     */
    symbol: S.optionalWith(S.String, { nullable: true }),
    /**
     * The name of the used network.
     */
    networkName: S.optionalWith(S.String, { nullable: true }),
    /**
     * The Id of the used network in Front system.
     */
    networkId: S.optionalWith(S.String, { nullable: true }),
    /**
     * The hash of the blockchain transaction.
     */
    hash: S.optionalWith(S.String, { nullable: true }),
    /**
     * The transferred amount, in the symbol of the transfer.
     */
    amount: S.optionalWith(S.Number, { nullable: true }),
    /**
     * The transferred amount, converted to the fiat currency.
     */
    amountInFiat: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Total amount of the transfer including all fees, converted to fiat.
     */
    totalAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Current number of network confirmations.
     */
    completedConfirmations: S.optionalWith(S.Int, { nullable: true }),
    /**
     * The fee that was taken by the institution.
     */
    institutionTransferFee: S.optionalWith(TransferFee, { nullable: true }),
    /**
     * The gas fee that was taken by the network. Depending on the integration, the network gas fee might be
     * covered by the `InstitutionTransferFee`.
     */
    networkGasFee: S.optionalWith(TransferFee, { nullable: true }),
    /**
     * Details of the allocated Smart Contract in case of 'Deposit' type transfers.
     */
    smartContract: S.optionalWith(SmartContractTransferAllocation, { nullable: true }),
  })
{}

export class ExecuteTransferResponse extends S.Class<ExecuteTransferResponse>("ExecuteTransferResponse")({
  /**
   * The status of the transfer.
   */
  status: S.optionalWith(
    S.Literal(
      "succeeded",
      "inProgress",
      "failed",
      "mfaRequired",
      "emailConfirmationRequired",
      "deviceConfirmationRequired",
      "mfaFailed",
      "addressWhitelistRequired",
      "secondMfaRequired",
      "deFiWalletConfirmationRequired",
      "emailConfirmationApprovalRequired",
    ),
    { nullable: true },
  ),
  /**
   * The type of the MFA when the status is `MfaRequired`.
   */
  mfaType: S.optionalWith(ExecuteTransferMfaType, { nullable: true }),
  /**
   * The type of the MFA when the status is `MfaRequired`.
   */
  verificationSteps: S.optionalWith(S.Array(ExecuteTransferMfaType), { nullable: true }),
  /**
   * The transaction number for Travel rule required clients (optional, depends on an integration).
   */
  travelRuleTransactionId: S.optionalWith(S.Int, { nullable: true }),
  qrCode: S.optionalWith(S.String, { nullable: true }),
  qrCodeLink: S.optionalWith(S.String, { nullable: true }),
  /**
   * Error message, if the operation did not complete successfully.
   */
  errorMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * Result of the transfer initiation.
   */
  executeTransferResult: S.optionalWith(ExecuteTransferResultResponse, { nullable: true }),
  fallbackMfaAvailable: S.optionalWith(S.Boolean, { nullable: true }),
  challengeId: S.optionalWith(S.String, { nullable: true }),
}) {}

export class ExecuteTransferResponseApiResult
  extends S.Class<ExecuteTransferResponseApiResult>("ExecuteTransferResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(ExecuteTransferResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedExecute401 extends S.Struct({}) {}

export class ApiV1TransfersManagedExecute403 extends S.Struct({}) {}

export class CryptocurrencyAddressType
  extends S.Literal(
    "ethAddress",
    "btcAddress",
    "ltcAddress",
    "solAddress",
    "algoAddress",
    "celoAddress",
    "cardanoAddress",
    "polygonAddress",
    "bnbAddress",
    "elrondAddress",
    "neoAddress",
    "xrpAddress",
    "flowAddress",
    "harmonyOneAddress",
    "tronAddress",
    "dogeAddress",
    "opAddress",
  )
{}

export class ManagedBrokerCryptocurrencyDepositAddressRequest
  extends S.Class<ManagedBrokerCryptocurrencyDepositAddressRequest>("ManagedBrokerCryptocurrencyDepositAddressRequest")(
    {
      /**
       * Auth token that allows connecting to the target institution
       */
      authToken: S.String.pipe(S.minLength(1)),
      /**
       * Type of the institution to connect
       */
      type: S.Literal(
        "robinhood",
        "eTrade",
        "alpaca",
        "tdAmeritrade",
        "weBull",
        "stash",
        "interactiveBrokers",
        "public",
        "coinbase",
        "kraken",
        "coinbasePro",
        "cryptoCom",
        "openSea",
        "binanceUs",
        "gemini",
        "cryptocurrencyAddress",
        "cryptocurrencyWallet",
        "okCoin",
        "bittrex",
        "kuCoin",
        "etoro",
        "cexIo",
        "binanceInternational",
        "bitstamp",
        "gateIo",
        "acorns",
        "okx",
        "bitFlyer",
        "coinlist",
        "huobi",
        "bitfinex",
        "deFiWallet",
        "krakenDirect",
        "vanguard",
        "binanceInternationalDirect",
        "bitfinexDirect",
        "bybit",
        "paxos",
        "coinbasePrime",
        "btcTurkDirect",
        "kuCoinDirect",
        "okxOAuth",
        "paribuDirect",
        "robinhoodConnect",
        "blockchainCom",
        "bitsoDirect",
        "binanceConnect",
        "binanceOAuth",
        "revolutConnect",
        "binancePay",
        "bybitDirect",
        "paribuOAuth",
        "payPalConnect",
        "binanceTrDirect",
        "coinbaseRamp",
        "bybitDirectMobile",
      ),
      /**
       * Symbol of the required cryptocurrency, e.g. ETH or BTC.
       * Can be used instead of the `AddressType` field.
       */
      symbol: S.optionalWith(S.String, { nullable: true }),
      /**
       * Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.
       * Can be used instead of `Symbol` field.
       */
      addressType: S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
      /**
       * Specifies which the network to use to obtain the deposit address of the `Symbol` asset.
       */
      networkId: S.optionalWith(S.String, { nullable: true }),
      /**
       * Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect
       */
      mfaCode: S.optionalWith(S.String, { nullable: true }),
    },
  )
{}

export class BrokerResponseStatus extends S.Literal("unknown", "mfaRequired", "kycRequired") {}

export class B2BBrokerCryptocurrencyDepositAddressResponse
  extends S.Class<B2BBrokerCryptocurrencyDepositAddressResponse>("B2BBrokerCryptocurrencyDepositAddressResponse")({
    symbol: S.optionalWith(S.String, { nullable: true }),
    address: S.optionalWith(S.String, { nullable: true }),
    chain: S.optionalWith(S.String, { nullable: true }),
    memo: S.optionalWith(S.String, { nullable: true }),
    minimumDepositAmount: S.optionalWith(S.String, { nullable: true }),
    networkId: S.optionalWith(S.String, { nullable: true }),
    brokerResponseStatus: S.optionalWith(BrokerResponseStatus, { nullable: true }),
    errorMessage: S.optionalWith(S.String, { nullable: true }),
  })
{}

export class B2BBrokerCryptocurrencyDepositAddressResponseApiResult
  extends S.Class<B2BBrokerCryptocurrencyDepositAddressResponseApiResult>(
    "B2BBrokerCryptocurrencyDepositAddressResponseApiResult",
  )({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerCryptocurrencyDepositAddressResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedAddressGet401 extends S.Struct({}) {}

export class QuoteTransferRequest extends S.Class<QuoteTransferRequest>("QuoteTransferRequest")({
  /**
   * Base amount of fiat currency being transferred
   */
  amountInFiat: S.Number,
  /**
   * 3 character currency code, e.g. USD
   */
  fiatCurrency: S.String.pipe(S.minLength(0), S.maxLength(3)),
  /**
   * Symbol of destination cryptocurrency, e.g. ETH
   */
  symbol: S.String.pipe(S.minLength(0), S.maxLength(10)),
  /**
   * Unique id of destination network
   */
  networkId: S.String,
  /**
   * The designated destination for sending the asset.
   */
  toAddress: S.String.pipe(S.minLength(0), S.maxLength(1024)),
  /**
   * The type of the integration to send the asset from
   */
  brokerType: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
  /**
   * Flat fee in crypto to be charged as a partner fee
   */
  feeFlat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Percentage of transfer amount to be charged as a partner fee, expressed as decimal (ie 0.1 = 10%)
   */
  feePercentage: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class QuoteFeesInFiat extends S.Class<QuoteFeesInFiat>("QuoteFeesInFiat")({
  /**
   * Max fee charged if funded by payment method
   */
  paymentMethodFeeMaxFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Max fee charged to buy crypto
   */
  tradingFeeMaxFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Fee charged to withdraw crypto
   */
  withdrawalFeeFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Fee charged by partner
   */
  partnerFeeFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Fee charged for network transaction
   */
  networkFeeFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Min of total fees charged in fiat
   */
  minFeesFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Max of total fees charged in fiat
   */
  maxFeesFiat: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class QuoteFeesInCrypto extends S.Class<QuoteFeesInCrypto>("QuoteFeesInCrypto")({
  /**
   * Max fee charged if funded by payment method
   */
  paymentMethodFeeMax: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Max fee charged to buy crypto
   */
  tradingFeeMax: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Fee charged to withdraw crypto
   */
  withdrawalFee: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Fee charged by partner
   */
  partnerFee: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Fee charged for network transaction
   */
  networkFee: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Min of total fees charged in crypto
   */
  minFees: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Max of total fees charged in crypto
   */
  maxFees: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class QuoteFees extends S.Class<QuoteFees>("QuoteFees")({
  /**
   * Summary of all possible transfer fees in fiat
   */
  inFiat: S.optionalWith(QuoteFeesInFiat, { nullable: true }),
  /**
   * Summary of all possible transfer fees in crypto
   */
  inCrypto: S.optionalWith(QuoteFeesInCrypto, { nullable: true }),
}) {}

export class CryptocurrencyFundingOptionType
  extends S.Literal(
    "existingCryptocurrencyBalance",
    "buyingPowerPurchase",
    "paymentMethodDepositUsage",
    "cryptocurrencyConversion",
    "stableCoinNoFeeConversion",
    "cryptocurrencyBuyingPowerConversion",
    "cryptocurrencyMultiStepConversion",
  )
{}

export class BrokerPaymentMethodType extends S.Literal("card", "bankAccount", "digitalWallet", "unknown") {}

export class QuoteFundingOption extends S.Class<QuoteFundingOption>("QuoteFundingOption")({
  /**
   * Funding option being quoted
   */
  fundingOption: S.optionalWith(
    S.Literal(
      "existingCryptocurrencyBalance",
      "buyingPowerPurchase",
      "paymentMethodDepositUsage",
      "cryptocurrencyConversion",
      "stableCoinNoFeeConversion",
      "cryptocurrencyBuyingPowerConversion",
      "cryptocurrencyMultiStepConversion",
    ),
    { nullable: true },
  ),
  /**
   * Payment method being quoted for PaymentMethodDepositUsage funding option
   */
  paymentMethodType: S.optionalWith(BrokerPaymentMethodType, { nullable: true }),
  /**
   * Fee charged for this payment method
   */
  paymentMethodFeeFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Fee charged to buy crypto if necessary for this funding option
   */
  tradingFeeFiat: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class QuoteTransferResponse extends S.Class<QuoteTransferResponse>("QuoteTransferResponse")({
  /**
   * Base amount of fiat currency being transferred (provided in request)
   */
  amountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * 3 character currency code (provided in request)
   */
  fiatCurrency: S.optionalWith(S.String, { nullable: true }),
  /**
   * Symbol of destination cryptocurrency (provided in request)
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Unique id of destination network (provided in request)
   */
  networkId: S.optionalWith(S.String, { nullable: true }),
  /**
   * The designated destination for sending the asset.
   */
  toAddress: S.optionalWith(S.String, { nullable: true }),
  /**
   * The type of the integration to send the asset from (provided in request)
   */
  brokerType: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  /**
   * Is the transaction is possible based on the minimum transfer amount of the selected exchange
   */
  isEligible: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Minimum amount eligible to transfer with selected asset, exchange, and network
   */
  minEligibleAmount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Minimum amount in fiat eligible to transfer with selected asset, exchange, and network
   */
  minEligibleAmountFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Maximum amount eligible to transfer with selected asset, exchange, and network
   */
  maxEligibleAmount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Maximum amount eligible in fiat to transfer with selected asset, exchange, and network
   */
  maxEligibleAmountFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * The reason a transaction is ineligible, returns none if eligible
   */
  ineligibilityReason: S.optionalWith(NetworkTransferIneligibilityReason, { nullable: true }),
  /**
   * Price quote from the broker, falls back to reference price
   */
  brokerPrice: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Reference price
   */
  price: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Min amount transferred in fiat
   */
  minAmountFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Max amount transferred in fiat
   */
  maxAmountFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Min amount of crypto transferred
   */
  minAmount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Max amount of crypto transferred
   */
  maxAmount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Summary of all possible transfer fees
   */
  fees: S.optionalWith(QuoteFees, { nullable: true }),
  /**
   * Summary of all possible funding options
   */
  fundingOptions: S.optionalWith(S.Array(QuoteFundingOption), { nullable: true }),
}) {}

export class QuoteTransferResponseApiResult
  extends S.Class<QuoteTransferResponseApiResult>("QuoteTransferResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(QuoteTransferResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedQuote401 extends S.Struct({}) {}

export class TransferStatus extends S.Literal("pending", "succeeded", "failed") {}

export class TransferOrderByFields
  extends S.Literal(
    "id",
    "clientTransferId",
    "userId",
    "fromType",
    "amountInFiat",
    "status",
    "createdTimestamp",
    "symbol",
    "networkName",
  )
{}

export class ApiV1TransfersManagedMeshParams extends S.Struct({
  Count: S.optionalWith(S.Int, { nullable: true }),
  Offset: S.optionalWith(S.Int, { nullable: true }),
  Id: S.optionalWith(S.String, { nullable: true }),
  ClientTransactionId: S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
  UserId: S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(50)), { nullable: true }),
  IntegrationIds: S.optionalWith(S.Array(S.String).pipe(S.maxItems(100)), { nullable: true }),
  Statuses: S.optionalWith(S.Array(TransferStatus).pipe(S.maxItems(5)), { nullable: true }),
  FromTimestamp: S.optionalWith(S.Int, { nullable: true }),
  ToTimestamp: S.optionalWith(S.Int, { nullable: true }),
  MinAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
  MaxAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
  OrderBy: S.optionalWith(TransferOrderByFields, { nullable: true }),
  Hash: S.optionalWith(S.String, { nullable: true }),
  SubClientId: S.optionalWith(S.String, { nullable: true }),
  DescendingOrder: S.optionalWith(S.Boolean, { nullable: true }),
}) {}

export class TransferIntegrationWithLogoModel
  extends S.Class<TransferIntegrationWithLogoModel>("TransferIntegrationWithLogoModel")({
    /**
     * Unique identifier of integration.
     */
    id: S.optionalWith(S.String, { nullable: true }),
    /**
     * Type of integration.
     */
    type: S.optionalWith(
      S.Literal(
        "robinhood",
        "eTrade",
        "alpaca",
        "tdAmeritrade",
        "weBull",
        "stash",
        "interactiveBrokers",
        "public",
        "coinbase",
        "kraken",
        "coinbasePro",
        "cryptoCom",
        "openSea",
        "binanceUs",
        "gemini",
        "cryptocurrencyAddress",
        "cryptocurrencyWallet",
        "okCoin",
        "bittrex",
        "kuCoin",
        "etoro",
        "cexIo",
        "binanceInternational",
        "bitstamp",
        "gateIo",
        "acorns",
        "okx",
        "bitFlyer",
        "coinlist",
        "huobi",
        "bitfinex",
        "deFiWallet",
        "krakenDirect",
        "vanguard",
        "binanceInternationalDirect",
        "bitfinexDirect",
        "bybit",
        "paxos",
        "coinbasePrime",
        "btcTurkDirect",
        "kuCoinDirect",
        "okxOAuth",
        "paribuDirect",
        "robinhoodConnect",
        "blockchainCom",
        "bitsoDirect",
        "binanceConnect",
        "binanceOAuth",
        "revolutConnect",
        "binancePay",
        "bybitDirect",
        "paribuOAuth",
        "payPalConnect",
        "binanceTrDirect",
        "coinbaseRamp",
        "bybitDirectMobile",
      ),
      { nullable: true },
    ),
    /**
     * Name of integration.
     */
    name: S.optionalWith(S.String, { nullable: true }),
    /**
     * Integration logo URL.
     */
    logoUrl: S.optionalWith(S.String, { nullable: true }),
  })
{}

/**
 * Funding method model.
 */
export class TransferFundingModel extends S.Class<TransferFundingModel>("TransferFundingModel")({
  /**
   * Type of the funding method.
   */
  type: S.optionalWith(
    S.Literal(
      "existingCryptocurrencyBalance",
      "buyingPowerPurchase",
      "paymentMethodDepositUsage",
      "cryptocurrencyConversion",
      "stableCoinNoFeeConversion",
      "cryptocurrencyBuyingPowerConversion",
      "cryptocurrencyMultiStepConversion",
    ),
    { nullable: true },
  ),
  /**
   * Amount funded.
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Amount in fiat.
   */
  amountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Symbol purchased.
   */
  toSymbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Amount used.
   */
  fromAmount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Symbol used.
   */
  fromSymbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Payment method type
   */
  paymentMethodType: S.optionalWith(BrokerPaymentMethodType, { nullable: true }),
  /**
   * Fee of funding.
   */
  fee: S.optionalWith(TransferFee, { nullable: true }),
}) {}

export class BridgingOperationStatus
  extends S.Literal(
    "recordCreated",
    "registeredInProvider",
    "sourceTransferStarted",
    "inReview",
    "providerAwaitingSourceTransfer",
    "providerFundsReceived",
    "providerProcessingPayment",
    "providerProcessedPayment",
    "providerSetUndeliverable",
    "returned",
    "refunded",
    "canceled",
    "succeeded",
    "failed",
  )
{}

export class BridgingTransferSide extends S.Class<BridgingTransferSide>("BridgingTransferSide")({
  networkName: S.optionalWith(S.String, { nullable: true }),
  symbol: S.optionalWith(S.String, { nullable: true }),
  amount: S.optionalWith(S.Number, { nullable: true }),
  transactionHash: S.optionalWith(S.String, { nullable: true }),
  infoUrl: S.optionalWith(S.String, { nullable: true }),
}) {}

export class BridgingTimelineEvent extends S.Class<BridgingTimelineEvent>("BridgingTimelineEvent")({
  eventType: S.optionalWith(S.String, { nullable: true }),
  description: S.optionalWith(S.String, { nullable: true }),
  timestamp: S.optionalWith(S.Int, { nullable: true }),
}) {}

export class BridgingTransferDetailsModel
  extends S.Class<BridgingTransferDetailsModel>("BridgingTransferDetailsModel")({
    status: S.optionalWith(
      S.Literal(
        "recordCreated",
        "registeredInProvider",
        "sourceTransferStarted",
        "inReview",
        "providerAwaitingSourceTransfer",
        "providerFundsReceived",
        "providerProcessingPayment",
        "providerProcessedPayment",
        "providerSetUndeliverable",
        "returned",
        "refunded",
        "canceled",
        "succeeded",
        "failed",
      ),
      { nullable: true },
    ),
    statusDescription: S.optionalWith(S.String, { nullable: true }),
    targetSide: S.optionalWith(BridgingTransferSide, { nullable: true }),
    sourceSide: S.optionalWith(BridgingTransferSide, { nullable: true }),
    timeline: S.optionalWith(S.Array(BridgingTimelineEvent), { nullable: true }),
  })
{}

export class TransferModel extends S.Class<TransferModel>("TransferModel")({
  /**
   * Mesh transfer identifier.
   */
  id: S.String,
  /**
   * Client transaction identifier.
   */
  clientTransactionId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Integration transaction identifier.
   */
  institutionTransactionId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Client's user identifier.
   */
  userId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer status.
   */
  status: S.optionalWith(S.Literal("pending", "succeeded", "failed"), { nullable: true }),
  /**
   * Transfer amount in fiat.
   */
  amountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Actual transfer amount without fees in fiat.
   */
  amountToReceiveInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Transfer amount in fiat currency code.
   */
  amountInFiatCurrencyCode: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer amount.
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Actual transfer amount without fees.
   */
  amountToReceive: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Transfer cryptocurrency symbol.
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer cryptocurrency token contract address (e.g., for ERC20s).
   */
  tokenAddress: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer network name.
   */
  networkName: S.optionalWith(S.String, { nullable: true }),
  /**
   * Id of the transfer network.
   */
  networkId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Network logo URL.
   */
  networkLogoUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Created timestamp.
   */
  createdTimestamp: S.optionalWith(S.Int, { nullable: true }),
  /**
   * From integration.
   */
  from: S.optionalWith(TransferIntegrationWithLogoModel, { nullable: true }),
  /**
   * Transfer hash.
   */
  hash: S.optionalWith(S.String, { nullable: true }),
  /**
   * Sub-client identifier.
   */
  subClientId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer info url on blockchain explorer.
   */
  infoUrl: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer network gas fee.
   */
  gasFee: S.optionalWith(TransferFee, { nullable: true }),
  /**
   * Financial insitution withdrawal fee.
   */
  withdrawalFee: S.optionalWith(TransferFee, { nullable: true }),
  /**
   * Transfer processing fee.
   */
  processingFee: S.optionalWith(TransferFee, { nullable: true }),
  /**
   * Transfer executed Unix timestamp.
   */
  executedTimestamp: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Type of a transfer.
   */
  transferType: S.optionalWith(TransferTypeEnum, { nullable: true }),
  /**
   * Is fee included.
   */
  isFeeIncluded: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Amount what was actually transferred from source account.
   */
  sourceAmount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Amount what destination actually received.
   */
  destinationAmount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Amount in fiat what destination actually received.
   */
  destinationAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total fees paid by user to execute this transaction.
   */
  totalFeesAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total fiat transaction amount in origin integration.
   */
  totalTransactionAmountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * The funding methods that were used to fund the transaction.
   */
  fundingMethods: S.optionalWith(S.Array(TransferFundingModel), { nullable: true }),
  /**
   * Transfer Destination Address.
   */
  destinationAddress: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer Refund Address.
   */
  refundAddress: S.optionalWith(S.String, { nullable: true }),
  /**
   * Bridging operation details.
   */
  bridgingDetails: S.optionalWith(BridgingTransferDetailsModel, { nullable: true }),
}) {}

export class TransferModelPaginationResponse
  extends S.Class<TransferModelPaginationResponse>("TransferModelPaginationResponse")({
    /**
     * list of items
     */
    items: S.optionalWith(S.Array(TransferModel), { nullable: true }),
    /**
     * Total number of items
     */
    total: S.optionalWith(S.Int, { nullable: true }),
  })
{}

export class TransferModelPaginationResponseApiResult
  extends S.Class<TransferModelPaginationResponseApiResult>("TransferModelPaginationResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(TransferModelPaginationResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedMesh401 extends S.Struct({}) {}

export class UpdateTransferStatusRequest extends S.Class<UpdateTransferStatusRequest>("UpdateTransferStatusRequest")({
  /**
   * Auth token that allows connecting to the target institution
   */
  authToken: S.String.pipe(S.minLength(1)),
  /**
   * Type of the institution to connect
   */
  type: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
  /**
   * Id of the executed transfer.
   */
  transactionId: S.String.pipe(S.minLength(1)),
}) {}

/**
 * Integration model.
 */
export class TransferIntegrationModel extends S.Class<TransferIntegrationModel>("TransferIntegrationModel")({
  /**
   * Unique identifier of integration.
   */
  id: S.optionalWith(S.String, { nullable: true }),
  /**
   * Type of integration.
   */
  type: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  /**
   * Name of integration.
   */
  name: S.optionalWith(S.String, { nullable: true }),
}) {}

export class UpdateTransferModel extends S.Class<UpdateTransferModel>("UpdateTransferModel")({
  /**
   * Mesh transfer identifier.
   */
  id: S.optionalWith(S.String, { nullable: true }),
  /**
   * Client transaction identifier.
   */
  clientTransactionId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Integration transaction identifier.
   */
  institutionTransactionId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Client's user identifier.
   */
  userId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer status.
   */
  status: S.optionalWith(S.Literal("pending", "succeeded", "failed"), { nullable: true }),
  /**
   * Transfer amount in fiat.
   */
  amountInFiat: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Transfer amount in fiat currency code.
   */
  amountInFiatCurrencyCode: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer amount.
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Transfer cryptocurrency symbol.
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer network name.
   */
  networkName: S.optionalWith(S.String, { nullable: true }),
  /**
   * Created timestamp.
   */
  createdTimestamp: S.optionalWith(S.Int, { nullable: true }),
  /**
   * From integration.
   */
  from: S.optionalWith(TransferIntegrationModel, { nullable: true }),
  /**
   * Transfer hash.
   */
  hash: S.optionalWith(S.String, { nullable: true }),
  /**
   * Transfer executed Unix timestamp.
   */
  executedTimestamp: S.optionalWith(S.Int, { nullable: true }),
}) {}

export class UpdateTransferResponse extends S.Class<UpdateTransferResponse>("UpdateTransferResponse")({
  /**
   * The status of the transfer.
   */
  status: S.optionalWith(S.Literal("pending", "succeeded", "failed"), { nullable: true }),
  /**
   * The status details of the transfer.
   */
  statusDetails: S.optionalWith(
    S.Literal(
      "unknown",
      "failed",
      "frozen",
      "succeeded",
      "mfaRequired",
      "pending",
      "expired",
      "canceled",
      "waitingForSignature",
      "waitingForClearing",
      "awaitingApproval",
      "awaitingConfirmation",
      "awaitingVerification",
      "rejected",
      "pendingCancel",
      "emailVerification",
      "deviceConfirmationRequired",
      "mfaFailed",
      "addressWhitelistRequired",
      "secondMfaRequired",
      "emailConfirmationApprovalRequired",
      "travelRuleRequired",
    ),
    { nullable: true },
  ),
  /**
   * Error message, if the operation did not complete successfully.
   */
  errorMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * Result of the transfer initiation.
   */
  transferResult: S.optionalWith(UpdateTransferModel, { nullable: true }),
}) {}

export class UpdateTransferResponseApiResult
  extends S.Class<UpdateTransferResponseApiResult>("UpdateTransferResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(UpdateTransferResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersManagedUpdate401 extends S.Struct({}) {}

export class ApiV1TransfersManagedUpdate403 extends S.Struct({}) {}

export class PortfolioHoldingsRequest extends S.Class<PortfolioHoldingsRequest>("PortfolioHoldingsRequest")({
  /**
   * Auth token that allows connecting to the target institution
   */
  authToken: S.String.pipe(S.minLength(1)),
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```Coinbase```
   * ```Kraken```
   * ```CryptoCom```
   * ```OpenSea```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```KuCoinDirect```
   * ```OkxOAuth```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BitsoDirect```
   * ```BinanceOAuth```
   * ```BybitDirect```
   * ```ParibuOAuth```
   * ```BinanceTrDirect```
   * ```BybitDirectMobile```
   * ```DeFiWallet```
   */
  type: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
  includeMarketValue: S.optionalWith(S.Boolean, { nullable: true }),
}) {}

export class BrokerRequestStatus extends S.Literal("succeeded", "failed", "notAuthorized") {}

/**
 * Represents the distribution of a DeFi position across different networks and addresses.
 * This class holds the network-specific information, wallet address, and the amount of cryptocurrency
 * allocated to each network and address for self-custody (DeFi) wallets.
 */
export class DeFiPositionDistribution extends S.Class<DeFiPositionDistribution>("DeFiPositionDistribution")({
  /**
   * Cryptocurrency CAIP-2 network ID associated with this distribution.
   */
  caipNetworkId: S.NullOr(S.String),
  /**
   * The wallet address on the specific network.
   */
  address: S.NullOr(S.String),
  /**
   * Amount of cryptocurrency allocated to this network and address.
   */
  amount: S.Number,
}) {}

export class Position extends S.Class<Position>("Position")({
  /**
   * Name of the asset
   */
  name: S.optionalWith(S.String, { nullable: true }),
  /**
   * Symbol of the asset
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Amount of the asset
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * The total original value (or purchase price) of the asset
   */
  costBasis: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Breakdown of crypto distribution across different networks and addresses.
   * This data is populated only for self-custody (DeFi) wallets.
   */
  distribution: S.optionalWith(S.Array(DeFiPositionDistribution), { nullable: true }),
}) {}

export class B2BNftPosition extends S.Class<B2BNftPosition>("B2BNftPosition")({
  amount: S.optionalWith(S.Number, { nullable: true }),
  costBasis: S.optionalWith(S.Number, { nullable: true }),
  contractAddress: S.optionalWith(S.String, { nullable: true }),
  name: S.optionalWith(S.String, { nullable: true }),
  description: S.optionalWith(S.String, { nullable: true }),
  marketplaceId: S.optionalWith(S.String, { nullable: true }),
  tokenId: S.optionalWith(S.String, { nullable: true }),
  marketplacePermalink: S.optionalWith(S.String, { nullable: true }),
  addressType: S.optionalWith(
    S.Literal(
      "ethAddress",
      "btcAddress",
      "ltcAddress",
      "solAddress",
      "algoAddress",
      "celoAddress",
      "cardanoAddress",
      "polygonAddress",
      "bnbAddress",
      "elrondAddress",
      "neoAddress",
      "xrpAddress",
      "flowAddress",
      "harmonyOneAddress",
      "tronAddress",
      "dogeAddress",
      "opAddress",
    ),
    { nullable: true },
  ),
}) {}

export class BrokerOptionDirection
  extends S.Literal("unknown", "buyToOpen", "buyToClose", "sellToOpen", "sellToClose", "buyToCover", "sellShort")
{}

export class BrokerOptionType extends S.Literal("unknown", "call", "put") {}

export class B2BOptionPosition extends S.Class<B2BOptionPosition>("B2BOptionPosition")({
  /**
   * Symbol of the underlying stock
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Amount of options
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total average paid price
   */
  averageOpenPrice: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Side of the option, buy or sell
   */
  direction: S.optionalWith(
    S.Literal("unknown", "buyToOpen", "buyToClose", "sellToOpen", "sellToClose", "buyToCover", "sellShort"),
    { nullable: true },
  ),
  createdTimestamp: S.optionalWith(S.Int, { nullable: true }),
  updatedTimestamp: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Number of shares of the underlying stock
   */
  numberOfSharesInContract: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Type of the option, put or call
   */
  optionType: S.optionalWith(S.Literal("unknown", "call", "put"), { nullable: true }),
  /**
   * The last day that the option contract is valid
   */
  expirationTimestamp: S.optionalWith(S.Int, { nullable: true }),
  /**
   * The price at which a put or call option can be exercised
   */
  strikePrice: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class PositionWithMarketValue extends S.Class<PositionWithMarketValue>("PositionWithMarketValue")({
  /**
   * Name of the asset
   */
  name: S.optionalWith(S.String, { nullable: true }),
  /**
   * Symbol of the asset
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Amount of the asset
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * The total original value (or purchase price) of the asset
   */
  costBasis: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Breakdown of crypto distribution across different networks and addresses.
   * This data is populated only for self-custody (DeFi) wallets.
   */
  distribution: S.optionalWith(S.Array(DeFiPositionDistribution), { nullable: true }),
  /**
   * Market value of the asset: amount of asset multiplied by last asset value.
   */
  marketValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Current last price of the asset.
   */
  lastPrice: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class HoldingsModel extends S.Class<HoldingsModel>("HoldingsModel")({
  /**
   * Status of the request to the institution's API
   */
  status: S.optionalWith(S.Literal("succeeded", "failed", "notAuthorized"), { nullable: true }),
  /**
   * Error message specifying the problem
   */
  errorMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * User-friendly error message, optimized to be shown to the end user
   */
  displayMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * The equity positions Front could not recognize
   */
  notSupportedEquityPositions: S.optionalWith(S.Array(Position), { nullable: true }),
  /**
   * The cryptocurrency positions Front could not recognize
   */
  notSupportedCryptocurrencyPositions: S.optionalWith(S.Array(Position), { nullable: true }),
  /**
   * NFT holdings on the account
   */
  nftPositions: S.optionalWith(S.Array(B2BNftPosition), { nullable: true }),
  /**
   * Option holdings on the account
   */
  optionPositions: S.optionalWith(S.Array(B2BOptionPosition), { nullable: true }),
  /**
   * Type of the institution
   */
  type: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  /**
   * External institution's account id (returned by the institution)
   */
  accountId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Friendly name of the connected institution
   */
  institutionName: S.optionalWith(S.String, { nullable: true }),
  /**
   * Name of the account as returned from the institution
   */
  accountName: S.optionalWith(S.String, { nullable: true }),
  /**
   * Equity holdings, such as stocks and ETFs
   */
  equityPositions: S.optionalWith(S.Array(PositionWithMarketValue), { nullable: true }),
  /**
   * Cryptocurrency holdings on the account
   */
  cryptocurrencyPositions: S.optionalWith(S.Array(PositionWithMarketValue), { nullable: true }),
}) {}

export class HoldingsModelApiResult extends S.Class<HoldingsModelApiResult>("HoldingsModelApiResult")({
  status: S.optionalWith(
    S.Literal(
      "ok",
      "serverFailure",
      "permissionDenied",
      "badRequest",
      "notFound",
      "conflict",
      "tooManyRequest",
      "locked",
      "unavailableForLegalReasons",
    ),
    { nullable: true },
  ),
  /**
   * A message generated by the API
   */
  message: S.optionalWith(S.String, { nullable: true }),
  /**
   * User-friendly display message that can be presented to the end user
   */
  displayMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType: S.optionalWith(S.String, { nullable: true }),
  content: S.optionalWith(HoldingsModel, { nullable: true }),
}) {}

export class ApiV1HoldingsGet401 extends S.Struct({}) {}

export class ApiV1HoldingsGet403 extends S.Struct({}) {}

export class PortfolioBrokerBaseRequest extends S.Class<PortfolioBrokerBaseRequest>("PortfolioBrokerBaseRequest")({
  /**
   * Auth token that allows connecting to the target institution
   */
  authToken: S.String.pipe(S.minLength(1)),
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```Coinbase```
   * ```Kraken```
   * ```CryptoCom```
   * ```OpenSea```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```KuCoinDirect```
   * ```OkxOAuth```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BitsoDirect```
   * ```BinanceOAuth```
   * ```BybitDirect```
   * ```ParibuOAuth```
   * ```BinanceTrDirect```
   * ```BybitDirectMobile```
   * ```DeFiWallet```
   */
  type: S.Literal(
    "robinhood",
    "eTrade",
    "alpaca",
    "tdAmeritrade",
    "weBull",
    "stash",
    "interactiveBrokers",
    "public",
    "coinbase",
    "kraken",
    "coinbasePro",
    "cryptoCom",
    "openSea",
    "binanceUs",
    "gemini",
    "cryptocurrencyAddress",
    "cryptocurrencyWallet",
    "okCoin",
    "bittrex",
    "kuCoin",
    "etoro",
    "cexIo",
    "binanceInternational",
    "bitstamp",
    "gateIo",
    "acorns",
    "okx",
    "bitFlyer",
    "coinlist",
    "huobi",
    "bitfinex",
    "deFiWallet",
    "krakenDirect",
    "vanguard",
    "binanceInternationalDirect",
    "bitfinexDirect",
    "bybit",
    "paxos",
    "coinbasePrime",
    "btcTurkDirect",
    "kuCoinDirect",
    "okxOAuth",
    "paribuDirect",
    "robinhoodConnect",
    "blockchainCom",
    "bitsoDirect",
    "binanceConnect",
    "binanceOAuth",
    "revolutConnect",
    "binancePay",
    "bybitDirect",
    "paribuOAuth",
    "payPalConnect",
    "binanceTrDirect",
    "coinbaseRamp",
    "bybitDirectMobile",
  ),
}) {}

export class BrokerPortfolioValueModel extends S.Class<BrokerPortfolioValueModel>("BrokerPortfolioValueModel")({
  /**
   * Total USD value of portfolio.
   */
  totalValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total performance in percents based on the cost basis.
   */
  totalPerformance: S.optionalWith(S.Number, { nullable: true }),
  /**
   * USD value of all equities in the portfolio.
   */
  equitiesValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Performance in percents of all equities based on the cost basis.
   */
  equitiesPerformance: S.optionalWith(S.Number, { nullable: true }),
  /**
   * USD value of all cryptocurrencies in the portfolio.
   */
  cryptocurrenciesValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Performance in percents of all cryptocurrencies in the portfolio based on the cost basis.
   */
  cryptocurrenciesPerformance: S.optionalWith(S.Number, { nullable: true }),
  /**
   * USD value of all NFTs in the portfolio.
   */
  nftsValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * USD value of all fiat currencies in the portfolio.
   */
  fiatValue: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class BrokerPortfolioValueModelApiResult
  extends S.Class<BrokerPortfolioValueModelApiResult>("BrokerPortfolioValueModelApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(BrokerPortfolioValueModel, { nullable: true }),
  })
{}

export class ApiV1HoldingsValue401 extends S.Struct({}) {}

export class ApiV1HoldingsValue403 extends S.Struct({}) {}

export class ApiV1HoldingsPortfolioParams extends S.Struct({
  UserId: S.String,
  TimezoneOffset: S.optionalWith(S.Int, { nullable: true }),
}) {}

export class PositionWithReturn extends S.Class<PositionWithReturn>("PositionWithReturn")({
  /**
   * Name of the asset
   */
  name: S.optionalWith(S.String, { nullable: true }),
  /**
   * Symbol of the asset
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Amount of the asset
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * The total original value (or purchase price) of the asset
   */
  costBasis: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Breakdown of crypto distribution across different networks and addresses.
   * This data is populated only for self-custody (DeFi) wallets.
   */
  distribution: S.optionalWith(S.Array(DeFiPositionDistribution), { nullable: true }),
  /**
   * Market value of the asset: amount of asset multiplied by last asset value.
   */
  marketValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Current last price of the asset.
   */
  lastPrice: S.optionalWith(S.Number, { nullable: true }),
  /**
   * What percentage of total portfolio value is taken by this asset.
   */
  portfolioPercentage: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total return of investment of this asset. Can be negative or null. Based on the cost basis of the asset, cost basis
   * is not available by some of integrations.
   */
  totalReturn: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Percent of return of investment for this asset. Can be negative or null.
   */
  returnPercentage: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Company name of the relative asset.
   */
  companyName: S.optionalWith(S.String, { nullable: true }),
  /**
   * Total daily return of investment for this asset. Can be negative.
   */
  totalDailyReturn: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Daily percent of return of investment for this asset. Can be negative.
   */
  dailyReturnPercentage: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class NftOrderSide extends S.Literal("buy", "sell") {}

export class NftOrder extends S.Class<NftOrder>("NftOrder")({
  orderSide: S.optionalWith(S.Literal("buy", "sell"), { nullable: true }),
  symbol: S.optionalWith(S.String, { nullable: true }),
  price: S.optionalWith(S.Number, { nullable: true }),
  priceUsd: S.optionalWith(S.Number, { nullable: true }),
  amount: S.optionalWith(S.Number, { nullable: true }),
  createdTimestamp: S.optionalWith(S.Int, { nullable: true }),
  updatedTimestamp: S.optionalWith(S.Int, { nullable: true }),
  symbolLogo: S.optionalWith(S.String, { nullable: true }),
}) {}

export class NftBlockchain extends S.Literal("ethereum", "polygon", "klaytn") {}

export class NftPositionWithMarketValues extends S.Class<NftPositionWithMarketValues>("NftPositionWithMarketValues")({
  amount: S.optionalWith(S.Number, { nullable: true }),
  costBasis: S.optionalWith(S.Number, { nullable: true }),
  contractAddress: S.optionalWith(S.String, { nullable: true }),
  paymentTokenSymbol: S.optionalWith(S.String, { nullable: true }),
  name: S.optionalWith(S.String, { nullable: true }),
  description: S.optionalWith(S.String, { nullable: true }),
  imageUrl: S.optionalWith(S.String, { nullable: true }),
  imageOriginalUrl: S.optionalWith(S.String, { nullable: true }),
  animationUrl: S.optionalWith(S.String, { nullable: true }),
  backgroundColor: S.optionalWith(S.String, { nullable: true }),
  marketplaceId: S.optionalWith(S.String, { nullable: true }),
  tokenId: S.optionalWith(S.String, { nullable: true }),
  numberOfSales: S.optionalWith(S.Int, { nullable: true }),
  contractType: S.optionalWith(S.String, { nullable: true }),
  contractName: S.optionalWith(S.String, { nullable: true }),
  contractSchemaName: S.optionalWith(S.String, { nullable: true }),
  contractSymbol: S.optionalWith(S.String, { nullable: true }),
  contractDescription: S.optionalWith(S.String, { nullable: true }),
  marketplacePermalink: S.optionalWith(S.String, { nullable: true }),
  contractExternalLink: S.optionalWith(S.String, { nullable: true }),
  creatorAddress: S.optionalWith(S.String, { nullable: true }),
  currentOffer: S.optionalWith(NftOrder, { nullable: true }),
  lastSale: S.optionalWith(NftOrder, { nullable: true }),
  blockchain: S.optionalWith(S.Literal("ethereum", "polygon", "klaytn"), { nullable: true }),
  addressExplorerLink: S.optionalWith(S.String, { nullable: true }),
  twitterUsername: S.optionalWith(S.String, { nullable: true }),
  /**
   * Amount of NFTs multiplied by NFT value
   */
  marketValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * What percentage of total portfolio value is taken by this NFT
   */
  portfolioPercentage: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class B2BPortfolioModel extends S.Class<B2BPortfolioModel>("B2BPortfolioModel")({
  /**
   * Amount of money spent to buy all positions of the portfolio.
   */
  portfolioCostBasis: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Actual performance based on the cost basis.
   */
  actualPortfolioPerformance: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total USD portfolio value of all equities (sum(equity price * equity amount)). Does not include cash balance.
   */
  equitiesValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total USD value of all cryptocurrencies in the portfolio.
   */
  cryptocurrenciesValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total USD value of all NFTs in the portfolio.
   */
  nftsValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * List of equity positions
   */
  equityPositions: S.optionalWith(S.Array(PositionWithReturn), { nullable: true }),
  /**
   * List of cryptocurrency positions
   */
  cryptocurrencyPositions: S.optionalWith(S.Array(PositionWithReturn), { nullable: true }),
  /**
   * List of NFT positions
   */
  nftPositions: S.optionalWith(S.Array(NftPositionWithMarketValues), { nullable: true }),
}) {}

export class B2BPortfolioModelApiResult extends S.Class<B2BPortfolioModelApiResult>("B2BPortfolioModelApiResult")({
  status: S.optionalWith(
    S.Literal(
      "ok",
      "serverFailure",
      "permissionDenied",
      "badRequest",
      "notFound",
      "conflict",
      "tooManyRequest",
      "locked",
      "unavailableForLegalReasons",
    ),
    { nullable: true },
  ),
  /**
   * A message generated by the API
   */
  message: S.optionalWith(S.String, { nullable: true }),
  /**
   * User-friendly display message that can be presented to the end user
   */
  displayMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType: S.optionalWith(S.String, { nullable: true }),
  content: S.optionalWith(B2BPortfolioModel, { nullable: true }),
}) {}

export class ApiV1HoldingsPortfolio401 extends S.Struct({}) {}

export class ApiV1HoldingsPortfolio403 extends S.Struct({}) {}

export class ApiV1CatalogSolanaGetLatestBlockhashParams extends S.Struct({
  chainId: S.optionalWith(S.String, { nullable: true }),
}) {}

export class StringApiResult extends S.Class<StringApiResult>("StringApiResult")({
  status: S.optionalWith(
    S.Literal(
      "ok",
      "serverFailure",
      "permissionDenied",
      "badRequest",
      "notFound",
      "conflict",
      "tooManyRequest",
      "locked",
      "unavailableForLegalReasons",
    ),
    { nullable: true },
  ),
  /**
   * A message generated by the API
   */
  message: S.optionalWith(S.String, { nullable: true }),
  /**
   * User-friendly display message that can be presented to the end user
   */
  displayMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType: S.optionalWith(S.String, { nullable: true }),
  content: S.optionalWith(S.String, { nullable: true }),
}) {}

export class BrokerOrderStatus
  extends S.Literal("unknown", "inProgress", "cancelled", "rejected", "failed", "success", "partiallyFilled", "expired")
{}

export class TransactionsB2BBrokerOrderListRequest
  extends S.Class<TransactionsB2BBrokerOrderListRequest>("TransactionsB2BBrokerOrderListRequest")({
    /**
     * Auth token that allows connecting to the target institution
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * Type of the institution to connect
     *
     * ### Supported integrations:
     * ```Robinhood```
     * ```Coinbase```
     * ```Kraken```
     * ```CryptoCom```
     * ```Binance```
     * ```Gemini```
     * ```OkCoin```
     * ```KuCoin```
     * ```CexIo```
     * ```BinanceInternational```
     * ```Bitstamp```
     * ```GateIo```
     * ```Okx```
     * ```BitFlyer```
     * ```Coinlist```
     * ```Huobi```
     * ```Bitfinex```
     * ```KrakenDirect```
     * ```BinanceInternationalDirect```
     * ```Bybit```
     * ```CoinbasePrime```
     * ```RobinhoodConnect```
     */
    type: S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    /**
     * The cursor to retrieve the next page of transactions.
     * Providing it will cause the response to only return changes after this update.
     * If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
     */
    cursor: S.optionalWith(S.String, { nullable: true }),
    /**
     * Number of records to include in the response.
     *
     * Default: `100`
     *
     * Maximum: `250`
     */
    count: S.optionalWith(S.Int, { nullable: true }),
    /**
     * Return orders of this statuses only. If this field is not provided, orders with all available statuses will be returned.
     */
    statuses: S.optionalWith(S.Array(BrokerOrderStatus), { nullable: true }),
    /**
     * Return orders created after this timestamp.
     * If this field is not provided, orders will be returned according to the default of the institution.
     */
    from: S.optionalWith(S.Int, { nullable: true }),
  })
{}

export class BrokerOrderType extends S.Literal("unknown", "buy", "sell") {}

export class B2BAssetType extends S.Literal("equity", "cryptocurrency", "option", "nft") {}

export class B2BBrokerOrderPaymentSymbolType extends S.Literal("fiat", "cryptocurrency") {}

export class BrokerOrderPlaceType
  extends S.Literal(
    "unknown",
    "market",
    "limit",
    "stopLoss",
    "stopLimit",
    "takeProfit",
    "netDebit",
    "netCredit",
    "exercise",
  )
{}

export class BrokerOrderTimeInForceType
  extends S.Literal("goodTillCanceled", "immediateOrCancel", "fillOrKill", "goodForDay", "postOnly", "unknown")
{}

export class B2BTransactionType
  extends S.Literal(
    "order",
    "conversionTo",
    "conversionFrom",
    "ownAccountDeposit",
    "ownAccountWithdraw",
    "stake",
    "dividendReinvestment",
    "interest",
    "reward",
    "unknown",
    "conversionToFiat",
    "conversionFromFiat",
  )
{}

export class B2BBrokerOptionData extends S.Class<B2BBrokerOptionData>("B2BBrokerOptionData")({
  /**
   * Type of option
   */
  optionType: S.optionalWith(S.Literal("unknown", "call", "put"), { nullable: true }),
  /**
   * Direction of option
   */
  direction: S.optionalWith(
    S.Literal("unknown", "buyToOpen", "buyToClose", "sellToOpen", "sellToClose", "buyToCover", "sellShort"),
    { nullable: true },
  ),
  /**
   * Option strike price
   */
  strikePrice: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Option expiration timestamp
   */
  expirationTimestamp: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Number of shares covered by option
   */
  numberOfSharesInContract: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Option complex order strategy type
   */
  complexOrderStrategyType: S.optionalWith(S.String, { nullable: true }),
}) {}

export class B2BBrokerOrder extends S.Class<B2BBrokerOrder>("B2BBrokerOrder")({
  /**
   * Transaction id, as provided by the institution
   */
  id: S.optionalWith(S.String, { nullable: true }),
  /**
   * Side of the transaction
   */
  side: S.optionalWith(S.Literal("unknown", "buy", "sell"), { nullable: true }),
  /**
   * Traded symbol
   */
  symbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Name of the traded asset
   */
  name: S.optionalWith(S.String, { nullable: true }),
  /**
   * Type of the traded asset
   */
  assetType: S.optionalWith(S.Literal("equity", "cryptocurrency", "option", "nft"), { nullable: true }),
  /**
   * Fiat or cryptocurrency symbol used for payment. For transactions with types `ConversionFrom` or `ConversionTo`
   * this field specifies the target symbol. For example, for `ETH` to `BTC` conversion, the transaction type is `ConversionTo`, the `Symbol` field is `ETH` and the `PaymentSymbol` is `BTC`
   */
  paymentSymbol: S.optionalWith(S.String, { nullable: true }),
  /**
   * Indicates if the payment was performed with fiat or crypto currency
   */
  paymentType: S.optionalWith(S.Literal("fiat", "cryptocurrency"), { nullable: true }),
  /**
   * Executed amount
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Price of the unit
   */
  price: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Order Fee, taken by the financial institution
   */
  fee: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total value
   */
  value: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Unix timestamp in seconds indicating when the order was placed or the transaction was created
   */
  createdTimestamp: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Unix timestamp in seconds indicating when the transaction was last updated (e.g. executed)
   */
  updatedTimestamp: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Status of the transaction
   */
  status: S.optionalWith(
    S.Literal("unknown", "inProgress", "cancelled", "rejected", "failed", "success", "partiallyFilled", "expired"),
    { nullable: true },
  ),
  /**
   * Status text, as provided by the institution
   */
  statusDetails: S.optionalWith(S.String, { nullable: true }),
  /**
   * Type of the placed order
   */
  orderType: S.optionalWith(BrokerOrderPlaceType, { nullable: true }),
  /**
   * Time in force of the order: a value indicating how long the order remains active before it is executed or expires
   */
  timeInForce: S.optionalWith(BrokerOrderTimeInForceType, { nullable: true }),
  /**
   * Type of the integration
   */
  brokerType: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  /**
   * Type of the transaction
   */
  transactionType: S.optionalWith(
    S.Literal(
      "order",
      "conversionTo",
      "conversionFrom",
      "ownAccountDeposit",
      "ownAccountWithdraw",
      "stake",
      "dividendReinvestment",
      "interest",
      "reward",
      "unknown",
      "conversionToFiat",
      "conversionFromFiat",
    ),
    { nullable: true },
  ),
  /**
   * Id of the parent order, applicable to some institutions
   */
  parentOrderId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Additional details for options
   */
  optionDetails: S.optionalWith(B2BBrokerOptionData, { nullable: true }),
}) {}

export class B2BBrokerOrderListResponse extends S.Class<B2BBrokerOrderListResponse>("B2BBrokerOrderListResponse")({
  /**
   * List of obtained transactions.
   */
  transactions: S.optionalWith(S.Array(B2BBrokerOrder), { nullable: true }),
  /**
   * The cursor to retrieve the next page of transactions.
   */
  cursor: S.optionalWith(S.String, { nullable: true }),
  /**
   * Total amount of records.
   */
  total: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Earliest transaction timestamp.
   */
  earliestTimestamp: S.optionalWith(S.Int, { nullable: true }),
}) {}

export class B2BBrokerOrderListResponseApiResult
  extends S.Class<B2BBrokerOrderListResponseApiResult>("B2BBrokerOrderListResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerOrderListResponse, { nullable: true }),
  })
{}

export class ApiV1TransactionsList401 extends S.Struct({}) {}

export class ApiV1TransactionsList403 extends S.Struct({}) {}

export class TransactionsB2BBrokerOrderRequest
  extends S.Class<TransactionsB2BBrokerOrderRequest>("TransactionsB2BBrokerOrderRequest")({
    /**
     * Auth token that allows connecting to the target institution
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * Type of the institution to connect
     *
     * ### Supported integrations:
     * ```Robinhood```
     * ```Coinbase```
     * ```Kraken```
     * ```CryptoCom```
     * ```Binance```
     * ```Gemini```
     * ```OkCoin```
     * ```KuCoin```
     * ```CexIo```
     * ```BinanceInternational```
     * ```Bitstamp```
     * ```GateIo```
     * ```Okx```
     * ```BitFlyer```
     * ```Coinlist```
     * ```Huobi```
     * ```Bitfinex```
     * ```KrakenDirect```
     * ```BinanceInternationalDirect```
     * ```Bybit```
     * ```CoinbasePrime```
     * ```RobinhoodConnect```
     */
    type: S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    id: S.String.pipe(S.minLength(1)),
    /**
     * Should be provided for Coinbase.
     */
    side: S.optionalWith(BrokerOrderType, { nullable: true }),
    /**
     * Some Stock and Crypto symbols can intersect, so we need to explicitly specify what type of asset is requested to be bought.
     */
    isCryptocurrency: S.Boolean,
    /**
     * Symbol pair of the order (requested by some brokers).
     */
    symbolPair: S.optionalWith(S.String, { nullable: true }),
    /**
     * MFA Code to cancel an order (requested by Kraken if MFA is enabled in user settings)
     */
    mfaCode: S.optionalWith(S.String, { nullable: true }),
  })
{}

export class B2BBrokerOrderApiResult extends S.Class<B2BBrokerOrderApiResult>("B2BBrokerOrderApiResult")({
  status: S.optionalWith(
    S.Literal(
      "ok",
      "serverFailure",
      "permissionDenied",
      "badRequest",
      "notFound",
      "conflict",
      "tooManyRequest",
      "locked",
      "unavailableForLegalReasons",
    ),
    { nullable: true },
  ),
  /**
   * A message generated by the API
   */
  message: S.optionalWith(S.String, { nullable: true }),
  /**
   * User-friendly display message that can be presented to the end user
   */
  displayMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType: S.optionalWith(S.String, { nullable: true }),
  content: S.optionalWith(B2BBrokerOrder, { nullable: true }),
}) {}

export class ApiV1TransactionsDetails401 extends S.Struct({}) {}

export class ApiV1TransactionsDetails403 extends S.Struct({}) {}

export class TransactionsBrokerBaseRequest
  extends S.Class<TransactionsBrokerBaseRequest>("TransactionsBrokerBaseRequest")({
    /**
     * Auth token that allows connecting to the target institution
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * Type of the institution to connect
     *
     * ### Supported integrations:
     * ```Robinhood```
     * ```Coinbase```
     * ```Kraken```
     * ```CryptoCom```
     * ```Binance```
     * ```Gemini```
     * ```OkCoin```
     * ```KuCoin```
     * ```CexIo```
     * ```BinanceInternational```
     * ```Bitstamp```
     * ```GateIo```
     * ```Okx```
     * ```BitFlyer```
     * ```Coinlist```
     * ```Huobi```
     * ```Bitfinex```
     * ```KrakenDirect```
     * ```BinanceInternationalDirect```
     * ```Bybit```
     * ```CoinbasePrime```
     * ```RobinhoodConnect```
     */
    type: S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
  })
{}

export class B2BBrokerTradingFeatureOrderType
  extends S.Class<B2BBrokerTradingFeatureOrderType>("B2BBrokerTradingFeatureOrderType")({
    /**
     * Specifies if this order type is supported for this integration.
     */
    supported: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Specifies if this order type supports buying or selling in fractional amounts. If this value is `false`, then only whole shares can be traded.
     */
    supportsFractionalShares: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Indicates if pre-market trading or after-hours trading is supported.
     */
    supportsExtendedMarketHours: S.optionalWith(S.Boolean, { nullable: true }),
    supportsPlacingBuyOrdersInFiatAmount: S.optionalWith(S.Boolean, { nullable: true }),
    supportsPlacingSellOrdersInFiatAmount: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * The list of supported Time-in-force instructions for this order type.
     */
    supportedTimeInForceList: S.optionalWith(S.Array(BrokerOrderTimeInForceType), { nullable: true }),
    /**
     * Specifies if this order type supports placing buy orders in payment/quote symbol amounts. For example,
     * if payment/quote symbol is USD, and this capability is supported, then the API can be instructed to buy asset for $10 or other dollar amount.
     */
    supportsPlacingBuyOrdersInPaymentSymbolAmount: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Specifies if this order type supports placing sell orders in payment/quote symbol amounts. For example,
     * if payment/quote symbol is USD, and this capability is supported, then the API can be instructed to sell asset for $10 or other dollar amount.
     */
    supportsPlacingSellOrdersInPaymentSymbolAmount: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Specifies if this order type supports placing buy orders in base symbol amounts. For example,
     * if payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to buy 1 or other amount of AAPL.
     */
    supportsPlacingBuyOrdersInBaseSymbolAmount: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Specifies if this order type supports placing sell orders in base symbol amounts. For example,
     * if payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to sell 1 or other amount of AAPL.
     */
    supportsPlacingSellOrdersInBaseSymbolAmount: S.optionalWith(S.Boolean, { nullable: true }),
  })
{}

export class B2BBrokerTradingFeature extends S.Class<B2BBrokerTradingFeature>("B2BBrokerTradingFeature")({
  supported: S.optionalWith(S.Boolean, { nullable: true }),
  supportsFiatCurrencyPayment: S.optionalWith(S.Boolean, { nullable: true }),
  supportsCryptocurrencyPayment: S.optionalWith(S.Boolean, { nullable: true }),
  supportsMarginOrders: S.optionalWith(S.Boolean, { nullable: true }),
  supportedCryptocurrencySymbols: S.optionalWith(S.Array(S.String), { nullable: true }),
  supportedCryptocurrencySymbolsForPayment: S.optionalWith(S.Array(S.String), { nullable: true }),
  supportedFiatCurrencies: S.optionalWith(S.Array(S.String), { nullable: true }),
  marketType: S.optionalWith(B2BBrokerTradingFeatureOrderType, { nullable: true }),
  limitType: S.optionalWith(B2BBrokerTradingFeatureOrderType, { nullable: true }),
  stopLossType: S.optionalWith(B2BBrokerTradingFeatureOrderType, { nullable: true }),
}) {}

export class BrokerPairTradeTimeInForceType
  extends S.Literal("immediateOrCancel", "goodTillCanceled", "goodTillDate", "fillOrKill")
{}

export class B2BBrokerCryptoPairTradeFeatureOrderType
  extends S.Class<B2BBrokerCryptoPairTradeFeatureOrderType>("B2BBrokerCryptoPairTradeFeatureOrderType")({
    /**
     * Specifies if this order type is supported for this integration.
     */
    supported: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * The list of supported Time-in-force instructions for this order type.
     */
    supportedTimeInForceList: S.optionalWith(S.Array(BrokerPairTradeTimeInForceType), { nullable: true }),
    /**
     * Specifies if this order type supports placing buy orders in base symbol amounts. For example,
     * if payment/quote symbol is USD, base symbol is ETH, and this capability is supported, then the API can be instructed to buy 1 or other amount of ETH.
     */
    supportsPlacingBuyOrdersInBaseSymbolAmount: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Specifies if this order type supports placing sell orders in base symbol amounts. For example,
     * if payment/quote symbol is USD, base symbol is ETH, and this capability is supported, then the API can be instructed to sell 1 or other amount of ETH.
     */
    supportsPlacingSellOrdersInBaseSymbolAmount: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Specifies if this order type supports placing buy orders in quote symbol amounts. For example,
     * if payment/quote symbol is USDC, and this capability is supported, then the API can be instructed to buy asset for 10 USDC or other amount.
     */
    supportsPlacingBuyOrdersInQuoteSymbolAmount: S.optionalWith(S.Boolean, { nullable: true }),
    /**
     * Specifies if this order type supports placing sell orders in quote symbol amounts. For example,
     * if payment/quote symbol is USDC, and this capability is supported, then the API can be instructed to sell asset for 10 USDC or other amount.
     */
    supportsPlacingSellOrdersInQuoteSymbolAmount: S.optionalWith(S.Boolean, { nullable: true }),
  })
{}

export class B2BBrokerCryptocurrencyPairTradeFeature
  extends S.Class<B2BBrokerCryptocurrencyPairTradeFeature>("B2BBrokerCryptocurrencyPairTradeFeature")({
    supported: S.optionalWith(S.Boolean, { nullable: true }),
    supportedCryptocurrencySymbols: S.optionalWith(S.Array(S.String), { nullable: true }),
    supportedFiatCurrencies: S.optionalWith(S.Array(S.String), { nullable: true }),
    supportedTradingPairs: S.optionalWith(S.Array(S.String), { nullable: true }),
    marketType: S.optionalWith(B2BBrokerCryptoPairTradeFeatureOrderType, { nullable: true }),
    limitType: S.optionalWith(B2BBrokerCryptoPairTradeFeatureOrderType, { nullable: true }),
  })
{}

export class B2BBrokerConversionFeature extends S.Class<B2BBrokerConversionFeature>("B2BBrokerConversionFeature")({
  supported: S.optionalWith(S.Boolean, { nullable: true }),
  supportsPreview: S.optionalWith(S.Boolean, { nullable: true }),
  supportedCryptocurrencySymbols: S.optionalWith(S.Array(S.String), { nullable: true }),
  supportedFiatCurrencies: S.optionalWith(S.Array(S.String), { nullable: true }),
}) {}

export class B2BBrokerTradingFeatureInfo extends S.Class<B2BBrokerTradingFeatureInfo>("B2BBrokerTradingFeatureInfo")({
  /**
   * Type of the integration.
   */
  brokerType: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  /**
   * Account Id of the integration.
   */
  accountId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Model, describing the ability to place cryptocurrency orders.
   */
  cryptocurrencyOrders: S.optionalWith(B2BBrokerTradingFeature, { nullable: true }),
  /**
   * Model, describing the ability to place equity orders.
   */
  stockOrders: S.optionalWith(B2BBrokerTradingFeature, { nullable: true }),
  /**
   * Model, describing the asset pair trading ability
   */
  cryptocurrencyAssetPairTrading: S.optionalWith(B2BBrokerCryptocurrencyPairTradeFeature, { nullable: true }),
  /**
   * Model, describing the conversion ability
   */
  cryptocurrencyConversion: S.optionalWith(B2BBrokerConversionFeature, { nullable: true }),
  /**
   * Status of the request.
   */
  status: S.optionalWith(S.Literal("succeeded", "failed", "notAuthorized"), { nullable: true }),
  /**
   * Indicates if the preview of orders (`preview order execution` endpoint) is provided by the institution.
   * This allows to validate the order using the API of the institution. If the order preview is not supported,
   * Front API validates the order without calling the institution's API.
   */
  supportsOrderPreview: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Supports getting price information directly from the institution.
   */
  supportsPriceQuotes: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Indicates if it is possible to cancel the placed order, while it's in the `InProgress` status.
   */
  supportsOrderCancellation: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Indicates if the integration is available.
   */
  isIntegrationUp: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * Indicates if trading is generally supported at this time.
   */
  isTradingSupported: S.optionalWith(S.Boolean, { nullable: true }),
  /**
   * List of fiat balances of the account.
   */
  fiatBalances: S.optionalWith(S.Array(B2BBrokerAccountBalance), { nullable: true }),
  /**
   * Limit for history records
   */
  historyRecordLimit: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Indicates whether the current exchange uses spreads as costs for trading
   */
  usesSpreads: S.optionalWith(S.Boolean, { nullable: true }),
}) {}

export class B2BBrokerTradingFeatureInfoApiResult
  extends S.Class<B2BBrokerTradingFeatureInfoApiResult>("B2BBrokerTradingFeatureInfoApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerTradingFeatureInfo, { nullable: true }),
  })
{}

export class ApiV1TransactionsFeatureList401 extends S.Struct({}) {}

export class BrokerOrderPlaceTypeTrade extends S.Literal("market", "limit", "stopLoss") {}

export class TransactionsB2BBrokerCreateOrderRequest
  extends S.Class<TransactionsB2BBrokerCreateOrderRequest>("TransactionsB2BBrokerCreateOrderRequest")({
    /**
     * Auth token that allows connecting to the target institution
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * Type of the institution to connect
     *
     * ### Supported integrations:
     * ```Robinhood```
     * ```Coinbase```
     * ```Kraken```
     * ```CryptoCom```
     * ```Binance```
     * ```Gemini```
     * ```OkCoin```
     * ```KuCoin```
     * ```CexIo```
     * ```BinanceInternational```
     * ```Bitstamp```
     * ```GateIo```
     * ```Okx```
     * ```BitFlyer```
     * ```Coinlist```
     * ```Huobi```
     * ```Bitfinex```
     * ```KrakenDirect```
     * ```BinanceInternationalDirect```
     * ```Bybit```
     * ```CoinbasePrime```
     * ```RobinhoodConnect```
     */
    type: S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    /**
     * Symbol to trade. For example, `AAPL` or `ETH`
     */
    symbol: S.String.pipe(S.minLength(1)),
    /**
     * Symbol to use for payment, defaults to `USD`.
     */
    paymentSymbol: S.String.pipe(S.minLength(1)),
    /**
     * Amount of purchase.
     */
    amount: S.Number,
    /**
     * Price of the unit, used for `Limit` and `StopLoss` orders.
     */
    price: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly.
     */
    isCryptocurrency: S.Boolean,
    /**
     * Indicates whether the `PaymentSymbol` is fiat or cryptocurrency
     */
    paymentIsCryptocurrency: S.Boolean,
    amountIsFiat: S.optionalWith(S.Boolean, { nullable: true }),
    amountInFiat: S.optionalWith(S.Number, { nullable: true }),
    /**
     * This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
     * performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
     * `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
     * value is passed.
     */
    amountIsInPaymentSymbol: S.Boolean,
    /**
     * Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
     * and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
     */
    amountInPaymentSymbol: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Specifies if the extended trading hours should be used.
     */
    extendedHours: S.optionalWith(S.Boolean, { nullable: true }),
    orderType: S.Literal("market", "limit", "stopLoss"),
    timeInForce: S.Literal("goodTillCanceled", "immediateOrCancel", "fillOrKill", "goodForDay", "postOnly", "unknown"),
    /**
     * MFA Code to create an order (requested by Kraken if MFA is enabled in user settings)
     */
    mfaCode: S.optionalWith(S.String, { nullable: true }),
  })
{}

export class BrokerOrderValidationStatus extends S.Literal("success", "failed") {}

export class B2BBrokerPreviewOrderResult extends S.Class<B2BBrokerPreviewOrderResult>("B2BBrokerPreviewOrderResult")({
  brokerType: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  fee: S.optionalWith(S.Number, { nullable: true }),
  feeText: S.optionalWith(S.String, { nullable: true }),
  amount: S.optionalWith(S.Number, { nullable: true }),
  side: S.optionalWith(S.Literal("unknown", "buy", "sell"), { nullable: true }),
  status: S.optionalWith(S.Literal("success", "failed"), { nullable: true }),
  errorMessage: S.optionalWith(S.String, { nullable: true }),
  paymentSymbol: S.optionalWith(S.String, { nullable: true }),
  paymentIsCryptocurrency: S.optionalWith(S.Boolean, { nullable: true }),
  estimatedUnitPrice: S.optionalWith(S.Number, { nullable: true }),
}) {}

export class B2BBrokerPreviewOrderResultApiResult
  extends S.Class<B2BBrokerPreviewOrderResultApiResult>("B2BBrokerPreviewOrderResultApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerPreviewOrderResult, { nullable: true }),
  })
{}

export class ApiV1TransactionsPreviewSide401 extends S.Struct({}) {}

export class ApiV1TransactionsPreviewSide403 extends S.Struct({}) {}

export class BrokerOrderCategory extends S.Literal("order", "trade", "ledger", "historyAction") {}

export class B2BBrokerOrderTrade extends S.Class<B2BBrokerOrderTrade>("B2BBrokerOrderTrade")({
  tradeId: S.optionalWith(S.String, { nullable: true }),
  amount: S.optionalWith(S.Number, { nullable: true }),
  value: S.optionalWith(S.Number, { nullable: true }),
  price: S.optionalWith(S.Number, { nullable: true }),
  fee: S.optionalWith(S.Number, { nullable: true }),
  orderCategory: S.optionalWith(S.Literal("order", "trade", "ledger", "historyAction"), { nullable: true }),
}) {}

export class B2BBrokerCreateOrderResult extends S.Class<B2BBrokerCreateOrderResult>("B2BBrokerCreateOrderResult")({
  /**
   * Id of the order, as returned from the financial institution. Can be used to get the status of the order.
   */
  orderId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Type of the institution.
   */
  brokerType: S.optionalWith(
    S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    { nullable: true },
  ),
  /**
   * Side of the order.
   */
  side: S.optionalWith(S.Literal("unknown", "buy", "sell"), { nullable: true }),
  /**
   * Amount of the order.
   */
  amount: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Unit price of the asset.
   */
  price: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Total value of the order.
   */
  value: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Optional Fee taken by the financial institution.
   */
  fee: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Timestamp of the order.
   */
  timestamp: S.optionalWith(S.Int, { nullable: true }),
  /**
   * Status of the order.
   */
  status: S.optionalWith(
    S.Literal("unknown", "inProgress", "cancelled", "rejected", "failed", "success", "partiallyFilled", "expired"),
    { nullable: true },
  ),
  /**
   * Text details of the order, if additionally returned from the financial institution.
   */
  statusDetails: S.optionalWith(S.String, { nullable: true }),
  /**
   * Value that indicates how long the order will remain active before it is executed or expires.
   */
  timeInForce: S.optionalWith(BrokerOrderTimeInForceType, { nullable: true }),
  /**
   * Optional pair of symbols, as returned from the financial institution. Can be required to obtain the status of the order by some institutions.
   */
  symbolPair: S.optionalWith(S.String, { nullable: true }),
  /**
   * Id of the parent order, applicable to some institutions if the order was executed in several trades.
   */
  parentOrderId: S.optionalWith(S.String, { nullable: true }),
  /**
   * List of trades, provided only if the order was executed in several trades.
   */
  trades: S.optionalWith(S.Array(B2BBrokerOrderTrade), { nullable: true }),
  /**
   * A message describing the error if the order wasn't placed.
   */
  errorMessage: S.optionalWith(S.String, { nullable: true }),
  /**
   * A user-friendly display message that can be presented to the end user.
   */
  displayMessage: S.optionalWith(S.String, { nullable: true }),
}) {}

export class B2BBrokerCreateOrderResultApiResult
  extends S.Class<B2BBrokerCreateOrderResultApiResult>("B2BBrokerCreateOrderResultApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerCreateOrderResult, { nullable: true }),
  })
{}

export class ApiV1TransactionsSide401 extends S.Struct({}) {}

export class ApiV1TransactionsSide403 extends S.Struct({}) {}

export class ApiV1TransactionsCancel401 extends S.Struct({}) {}

export class ApiV1TransactionsCancel403 extends S.Struct({}) {}

export class TransactionsB2BBrokerSymbolInfoForOrderRequest
  extends S.Class<TransactionsB2BBrokerSymbolInfoForOrderRequest>("TransactionsB2BBrokerSymbolInfoForOrderRequest")({
    /**
     * Auth token that allows connecting to the target institution
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * Type of the institution to connect
     *
     * ### Supported integrations:
     * ```Robinhood```
     * ```Coinbase```
     * ```Kraken```
     * ```CryptoCom```
     * ```Binance```
     * ```Gemini```
     * ```OkCoin```
     * ```KuCoin```
     * ```CexIo```
     * ```BinanceInternational```
     * ```Bitstamp```
     * ```GateIo```
     * ```Okx```
     * ```BitFlyer```
     * ```Coinlist```
     * ```Huobi```
     * ```Bitfinex```
     * ```KrakenDirect```
     * ```BinanceInternationalDirect```
     * ```Bybit```
     * ```CoinbasePrime```
     * ```RobinhoodConnect```
     */
    type: S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    /**
     * Symbol to trade. For example, `AAPL` or `ETH`
     */
    symbol: S.String.pipe(S.minLength(1)),
    /**
     * Symbol to use for payment, defaults to `USD`.
     */
    paymentSymbol: S.String.pipe(S.minLength(1)),
    /**
     * Amount of purchase.
     */
    amount: S.Number,
    /**
     * Price of the unit, used for `Limit` and `StopLoss` orders.
     */
    price: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly.
     */
    isCryptocurrency: S.Boolean,
    /**
     * Indicates whether the `PaymentSymbol` is fiat or cryptocurrency
     */
    paymentIsCryptocurrency: S.Boolean,
    amountIsFiat: S.optionalWith(S.Boolean, { nullable: true }),
    amountInFiat: S.optionalWith(S.Number, { nullable: true }),
    /**
     * This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
     * performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
     * `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
     * value is passed.
     */
    amountIsInPaymentSymbol: S.Boolean,
    /**
     * Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
     * and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
     */
    amountInPaymentSymbol: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Specifies if the extended trading hours should be used.
     */
    extendedHours: S.optionalWith(S.Boolean, { nullable: true }),
    orderType: S.Literal("market", "limit", "stopLoss"),
    timeInForce: S.Literal("goodTillCanceled", "immediateOrCancel", "fillOrKill", "goodForDay", "postOnly", "unknown"),
    /**
     * MFA Code to create an order (requested by Kraken if MFA is enabled in user settings)
     */
    mfaCode: S.optionalWith(S.String, { nullable: true }),
    side: S.optionalWith(BrokerOrderType, { nullable: true }),
  })
{}

export class SymbolTradingAllowance
  extends S.Literal(
    "fractionalTradingAllowed",
    "fractionalTradingNotAllowed",
    "tradingNotAllowed",
    "fractionalTradingPossiblyAllowed",
  )
{}

export class B2BBrokerOrderSymbolInfo extends S.Class<B2BBrokerOrderSymbolInfo>("B2BBrokerOrderSymbolInfo")({
  /**
   * Specifies if the fractional trading is allowed for the provided symbol
   */
  fractionalTradingAllowance: S.optionalWith(
    S.Literal(
      "fractionalTradingAllowed",
      "fractionalTradingNotAllowed",
      "tradingNotAllowed",
      "fractionalTradingPossiblyAllowed",
    ),
    { nullable: true },
  ),
  /**
   * Minimum allowed order value
   */
  minimumOrderValue: S.optionalWith(S.Number, { nullable: true }),
  /**
   * Maximum number of decimal digits accepted by the symbol
   */
  precisionScale: S.optionalWith(S.Int, { nullable: true }),
}) {}

export class B2BBrokerOrderSymbolInfoApiResult
  extends S.Class<B2BBrokerOrderSymbolInfoApiResult>("B2BBrokerOrderSymbolInfoApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerOrderSymbolInfo, { nullable: true }),
  })
{}

export class ApiV1TransactionsSymbolinfo401 extends S.Struct({}) {}

export class TransfersBrokerTransactionsListRequest
  extends S.Class<TransfersBrokerTransactionsListRequest>("TransfersBrokerTransactionsListRequest")({
    /**
     * Auth token that allows connecting to the target institution
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * Type of the institution to connect
     *
     * ### Supported integrations:
     * ```Robinhood```
     * ```Coinbase```
     * ```Kraken```
     * ```CryptoCom```
     * ```Binance```
     * ```Gemini```
     * ```OkCoin```
     * ```KuCoin```
     * ```BinanceInternational```
     * ```Bitstamp```
     * ```GateIo```
     * ```Okx```
     * ```Huobi```
     * ```Bitfinex```
     * ```KrakenDirect```
     * ```BinanceInternationalDirect```
     * ```BitfinexDirect```
     * ```Bybit```
     * ```Paxos```
     * ```CoinbasePrime```
     * ```BtcTurkDirect```
     * ```ParibuDirect```
     * ```RobinhoodConnect```
     * ```BlockchainCom```
     * ```BinanceConnect```
     * ```RevolutConnect```
     * ```BinancePay```
     * ```ParibuOAuth```
     * ```PayPalConnect```
     * ```DeFiWallet```
     */
    type: S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    /**
     * Number of records to include in the response.
     *
     * Default: `100`
     *
     * Maximum: `250`
     */
    count: S.optionalWith(S.Int, { nullable: true }),
    /**
     * The cursor to retrieve the next page of transactions.
     * Providing it will cause the response to only return changes after this update.
     * If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
     */
    cursor: S.optionalWith(S.String, { nullable: true }),
    /**
     * If this value is provided, result set is filtered to only include transaction with the provided statuses.
     */
    statuses: S.optionalWith(S.Array(BrokerCryptocurrencyTransactionStatus), { nullable: true }),
    /**
     * For cryptocurrency address the type of address is required.
     */
    cryptocurrencyAddressType: S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
    /**
     * If this value is provided, result set is filtered to only include transactions created after this timestamp
     */
    from: S.optionalWith(S.Int, { nullable: true }),
  })
{}

export class BrokerCryptocurrencyTransactionType extends S.Literal("unknown", "deposit", "withdrawal") {}

export class BrokerCryptocurrencyTransactionNetworkFee
  extends S.Class<BrokerCryptocurrencyTransactionNetworkFee>("BrokerCryptocurrencyTransactionNetworkFee")({
    gasPrice: S.optionalWith(S.Number, { nullable: true }),
    gasUsed: S.optionalWith(S.Number, { nullable: true }),
    amount: S.optionalWith(S.Number, { nullable: true }),
    symbol: S.optionalWith(S.String, { nullable: true }),
  })
{}

export class BrokerCryptocurrencyTransactionBlockchainMethod
  extends S.Literal(
    "transfer",
    "swap",
    "mint",
    "withdraw",
    "claimRewards",
    "deposit",
    "approve",
    "forgeToken",
    "multicall",
    "migrateToken",
    "claim",
    "openSeaTransfer",
    "cancel",
    "commit",
    "run",
    "repay",
    "execute",
    "stake",
    "merge",
  )
{}

export class B2BBrokerCryptocurrencyTransaction
  extends S.Class<B2BBrokerCryptocurrencyTransaction>("B2BBrokerCryptocurrencyTransaction")({
    /**
     * Identifier of the transfer, if provided by the financial institution
     */
    id: S.optionalWith(S.String, { nullable: true }),
    /**
     * Current status of the transaction
     */
    status: S.optionalWith(
      S.Literal(
        "unknown",
        "failed",
        "frozen",
        "succeeded",
        "mfaRequired",
        "pending",
        "expired",
        "canceled",
        "waitingForSignature",
        "waitingForClearing",
        "awaitingApproval",
        "awaitingConfirmation",
        "awaitingVerification",
        "rejected",
        "pendingCancel",
        "emailVerification",
        "deviceConfirmationRequired",
        "mfaFailed",
        "addressWhitelistRequired",
        "secondMfaRequired",
        "emailConfirmationApprovalRequired",
        "travelRuleRequired",
      ),
      { nullable: true },
    ),
    /**
     * Details of the current status of the transfer, as provided by the financial institution
     */
    statusDetails: S.optionalWith(S.String, { nullable: true }),
    /**
     * The direction of the transaction
     */
    type: S.optionalWith(S.Literal("unknown", "deposit", "withdrawal"), { nullable: true }),
    /**
     * Address where the transaction was sent from
     */
    fromAddress: S.optionalWith(S.String, { nullable: true }),
    /**
     * Address where the transaction was sent to
     */
    targetAddress: S.optionalWith(S.String, { nullable: true }),
    /**
     * Ticker of the transaction
     */
    symbol: S.optionalWith(S.String, { nullable: true }),
    /**
     * Crypto Chain the transaction belongs to
     */
    chain: S.optionalWith(S.String, { nullable: true }),
    /**
     * Memo of the transaction (also called "Tag")
     */
    memo: S.optionalWith(S.String, { nullable: true }),
    /**
     * Hash of the transaction
     */
    hash: S.optionalWith(S.String, { nullable: true }),
    /**
     * Full amount affected the balance, typically transaction amount plus fee
     */
    amount: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Transaction amount
     */
    transactionAmount: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Unix timestamp in seconds indicating when the transaction was created
     */
    createdTimestamp: S.optionalWith(S.Int, { nullable: true }),
    /**
     * Unix timestamp in seconds indicating when the transaction was last updated
     */
    updatedTimestamp: S.optionalWith(S.Int, { nullable: true }),
    /**
     * Fee taken by the network
     */
    networkTransactionFee: S.optionalWith(BrokerCryptocurrencyTransactionNetworkFee, { nullable: true }),
    /**
     * Fee taken by the financial institution
     */
    transferFee: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Number of confirmations on the blockchain
     */
    confirmations: S.optionalWith(S.Int, { nullable: true }),
    /**
     * Name of the executed blockchain function based on decoded input data
     */
    blockchainMethodName: S.optionalWith(S.String, { nullable: true }),
    /**
     * Executed blockchain function based on decoded input data. Not guaranteed to be identified
     */
    blockchainMethod: S.optionalWith(
      S.Literal(
        "transfer",
        "swap",
        "mint",
        "withdraw",
        "claimRewards",
        "deposit",
        "approve",
        "forgeToken",
        "multicall",
        "migrateToken",
        "claim",
        "openSeaTransfer",
        "cancel",
        "commit",
        "run",
        "repay",
        "execute",
        "stake",
        "merge",
      ),
      { nullable: true },
    ),
  })
{}

export class B2BBrokerTransactionsListModel
  extends S.Class<B2BBrokerTransactionsListModel>("B2BBrokerTransactionsListModel")({
    /**
     * List of obtained transfers.
     */
    transfers: S.optionalWith(S.Array(B2BBrokerCryptocurrencyTransaction), { nullable: true }),
    /**
     * Total amount of records.
     */
    total: S.optionalWith(S.Int, { nullable: true }),
    /**
     * The cursor to retrieve the next page of transfers.
     */
    cursor: S.optionalWith(S.String, { nullable: true }),
    /**
     * Earliest transfer timestamp.
     */
    earliestTimestamp: S.optionalWith(S.Int, { nullable: true }),
  })
{}

export class B2BBrokerTransactionsListModelApiResult
  extends S.Class<B2BBrokerTransactionsListModelApiResult>("B2BBrokerTransactionsListModelApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerTransactionsListModel, { nullable: true }),
  })
{}

export class ApiV1TransfersList401 extends S.Struct({}) {}

export class ApiV1TransfersList403 extends S.Struct({}) {}

export class TransfersBrokerCryptocurrencyTransactionDetailsRequest
  extends S.Class<TransfersBrokerCryptocurrencyTransactionDetailsRequest>(
    "TransfersBrokerCryptocurrencyTransactionDetailsRequest",
  )({
    /**
     * Auth token that allows connecting to the target institution
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * Type of the institution to connect
     *
     * ### Supported integrations:
     * ```Robinhood```
     * ```Coinbase```
     * ```Kraken```
     * ```CryptoCom```
     * ```Binance```
     * ```Gemini```
     * ```OkCoin```
     * ```KuCoin```
     * ```BinanceInternational```
     * ```Bitstamp```
     * ```GateIo```
     * ```Okx```
     * ```Huobi```
     * ```Bitfinex```
     * ```KrakenDirect```
     * ```BinanceInternationalDirect```
     * ```BitfinexDirect```
     * ```Bybit```
     * ```Paxos```
     * ```CoinbasePrime```
     * ```BtcTurkDirect```
     * ```ParibuDirect```
     * ```RobinhoodConnect```
     * ```BlockchainCom```
     * ```BinanceConnect```
     * ```RevolutConnect```
     * ```BinancePay```
     * ```ParibuOAuth```
     * ```PayPalConnect```
     * ```DeFiWallet```
     */
    type: S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    /**
     * Type of the address of the transferred asset. Can be used instead of the `Symbol` field.
     */
    addressType: S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
    /**
     * Transaction Id by the financial institution
     */
    transactionId: S.optionalWith(S.String, { nullable: true }),
    /**
     * Hash of the transaction on the blockchain
     */
    transactionHash: S.optionalWith(S.String, { nullable: true }),
    /**
     * Symbol of the transferred asset. Can be provided instead of the `AddressType` field.
     */
    symbol: S.optionalWith(S.String, { nullable: true }),
  })
{}

export class B2BBrokerCryptocurrencyTransactionApiResult
  extends S.Class<B2BBrokerCryptocurrencyTransactionApiResult>("B2BBrokerCryptocurrencyTransactionApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerCryptocurrencyTransaction, { nullable: true }),
  })
{}

export class ApiV1TransfersDetails401 extends S.Struct({}) {}

export class ApiV1TransfersDetails403 extends S.Struct({}) {}

export class ClientType
  extends S.Literal(
    "undefined",
    "wallet",
    "exchange",
    "vasp",
    "merchant",
    "other",
    "psp",
    "neobank",
    "iGaming",
    "aggregator",
  )
{}

export class TransferTravelRuleOptions extends S.Class<TransferTravelRuleOptions>("TransferTravelRuleOptions")({
  transferType: S.optionalWith(TransferTypeEnum, { nullable: true }),
  clientName: S.optionalWith(S.String, { nullable: true }),
  clientType: S.optionalWith(
    S.Literal(
      "undefined",
      "wallet",
      "exchange",
      "vasp",
      "merchant",
      "other",
      "psp",
      "neobank",
      "iGaming",
      "aggregator",
    ),
    { nullable: true },
  ),
  clientId: S.optionalWith(S.String, { nullable: true }),
}) {}

export class TransfersBrokerCreateCryptocurrencyTransactionRequest
  extends S.Class<TransfersBrokerCreateCryptocurrencyTransactionRequest>(
    "TransfersBrokerCreateCryptocurrencyTransactionRequest",
  )({
    /**
     * Auth token that allows connecting to the target institution
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * Type of the institution to connect
     *
     * ### Supported integrations:
     * ```Robinhood```
     * ```Coinbase```
     * ```Kraken```
     * ```CryptoCom```
     * ```Binance```
     * ```Gemini```
     * ```OkCoin```
     * ```KuCoin```
     * ```BinanceInternational```
     * ```Bitstamp```
     * ```GateIo```
     * ```Okx```
     * ```Huobi```
     * ```Bitfinex```
     * ```KrakenDirect```
     * ```BinanceInternationalDirect```
     * ```BitfinexDirect```
     * ```Bybit```
     * ```Paxos```
     * ```CoinbasePrime```
     * ```BtcTurkDirect```
     * ```ParibuDirect```
     * ```RobinhoodConnect```
     * ```BlockchainCom```
     * ```BinanceConnect```
     * ```RevolutConnect```
     * ```BinancePay```
     * ```ParibuOAuth```
     * ```PayPalConnect```
     * ```DeFiWallet```
     */
    type: S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    /**
     * Additional data to send on-chain (optional, depends on an integration)
     */
    data: S.optionalWith(S.String, { nullable: true }),
    /**
     * Target address to transfer the asset to
     */
    targetAddress: S.String.pipe(S.minLength(1)),
    /**
     * Amount to transfer
     */
    amount: S.optionalWith(S.Number, { nullable: true }),
    /**
     * On-chain fee (optional, depends on an integration)
     */
    fee: S.optionalWith(S.Number, { nullable: true }),
    /**
     * Type of the address of symbol to be transferred. Providing `EthAddress` will initiate a transfer of ETH over Ethereum blockchain.
     * Can be used instead of `Symbol` and `Chain` fields.
     * To transfer assets over non-default chains (e.g. sending USDT over ERC20) please `Symbol` and `Chain` fields.
     */
    addressType: S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
    /**
     * 2 Factor auth code (optional, depends on an integration)
     */
    mfaCode: S.optionalWith(S.String, { nullable: true }),
    /**
     * Travel rule transaction id (optional, depends on an integration)
     */
    travelRuleTransactionId: S.optionalWith(S.Int, { nullable: true }),
    /**
     * 2 Factor auth type (optional, depends on an integration)
     */
    mfaType: S.optionalWith(MfaType, { nullable: true }),
    verificationSteps: S.optionalWith(S.Array(MfaType), { nullable: true }),
    /**
     * Password or pass-phrase, required to send transfers (optional, depends on an integration)
     */
    password: S.optionalWith(S.String, { nullable: true }),
    /**
     * Custom chain name, required by some of the integrations. E.g. USDT can be sent over USDT-ERC20, USDT-TRC20, and USDT-Omni.
     * Can be used to transfer assets over non-default chains (e.g. sending USDT over ERC20).
     * Please use `symbol/details` endpoint to get the list of all possible chains.
     */
    chain: S.optionalWith(S.String, { nullable: true }),
    /**
     * Memo (also called "Tag") - address remark.
     */
    memo: S.optionalWith(S.String, { nullable: true }),
    /**
     * Symbol to be transferred. Can be provided instead of the `AddressType` field.
     */
    symbol: S.optionalWith(S.String, { nullable: true }),
    challengeId: S.optionalWith(S.String, { nullable: true }),
    tryAnotherMfa: S.optionalWith(S.Boolean, { nullable: true }),
    travelRuleOptions: S.optionalWith(TransferTravelRuleOptions, { nullable: true }),
  })
{}

export class B2BBrokerCreateCryptocurrencyTransactionResponse
  extends S.Class<B2BBrokerCreateCryptocurrencyTransactionResponse>("B2BBrokerCreateCryptocurrencyTransactionResponse")(
    {
      /**
       * Transaction Id by the financial institution
       */
      transactionId: S.optionalWith(S.String, { nullable: true }),
      failed: S.optionalWith(S.Boolean, { nullable: true }),
      mfaType: S.optionalWith(MfaType, { nullable: true }),
      verificationSteps: S.optionalWith(S.Array(MfaType), { nullable: true }),
      qrCode: S.optionalWith(S.String, { nullable: true }),
      qrCodeLink: S.optionalWith(S.String, { nullable: true }),
      /**
       * Status of the operation
       */
      status: S.optionalWith(
        S.Literal(
          "unknown",
          "failed",
          "frozen",
          "succeeded",
          "mfaRequired",
          "pending",
          "expired",
          "canceled",
          "waitingForSignature",
          "waitingForClearing",
          "awaitingApproval",
          "awaitingConfirmation",
          "awaitingVerification",
          "rejected",
          "pendingCancel",
          "emailVerification",
          "deviceConfirmationRequired",
          "mfaFailed",
          "addressWhitelistRequired",
          "secondMfaRequired",
          "emailConfirmationApprovalRequired",
          "travelRuleRequired",
        ),
        { nullable: true },
      ),
      /**
       * Details of the current status of the transfer, as provided by the financial institution
       */
      statusDetails: S.optionalWith(S.String, { nullable: true }),
      /**
       * Details of the created transaction
       */
      transaction: S.optionalWith(B2BBrokerCryptocurrencyTransaction, { nullable: true }),
      fallbackMfaAvailable: S.optionalWith(S.Boolean, { nullable: true }),
      challengeId: S.optionalWith(S.String, { nullable: true }),
    },
  )
{}

export class B2BBrokerCreateCryptocurrencyTransactionResponseApiResult
  extends S.Class<B2BBrokerCreateCryptocurrencyTransactionResponseApiResult>(
    "B2BBrokerCreateCryptocurrencyTransactionResponseApiResult",
  )({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerCreateCryptocurrencyTransactionResponse, { nullable: true }),
  })
{}

export class ApiV1Transfers401 extends S.Struct({}) {}

export class ApiV1Transfers403 extends S.Struct({}) {}

export class TransfersBrokerCryptocurrencyDepositAddressRequest
  extends S.Class<TransfersBrokerCryptocurrencyDepositAddressRequest>(
    "TransfersBrokerCryptocurrencyDepositAddressRequest",
  )({
    /**
     * Auth token that allows connecting to the target institution
     */
    authToken: S.String.pipe(S.minLength(1)),
    /**
     * Type of the institution to connect
     *
     * ### Supported integrations:
     * ```Robinhood```
     * ```Coinbase```
     * ```Kraken```
     * ```CryptoCom```
     * ```Binance```
     * ```Gemini```
     * ```OkCoin```
     * ```KuCoin```
     * ```BinanceInternational```
     * ```Bitstamp```
     * ```GateIo```
     * ```Okx```
     * ```Huobi```
     * ```Bitfinex```
     * ```KrakenDirect```
     * ```BinanceInternationalDirect```
     * ```BitfinexDirect```
     * ```Bybit```
     * ```Paxos```
     * ```CoinbasePrime```
     * ```BtcTurkDirect```
     * ```ParibuDirect```
     * ```RobinhoodConnect```
     * ```BlockchainCom```
     * ```BinanceConnect```
     * ```RevolutConnect```
     * ```BinancePay```
     * ```ParibuOAuth```
     * ```PayPalConnect```
     * ```DeFiWallet```
     */
    type: S.Literal(
      "robinhood",
      "eTrade",
      "alpaca",
      "tdAmeritrade",
      "weBull",
      "stash",
      "interactiveBrokers",
      "public",
      "coinbase",
      "kraken",
      "coinbasePro",
      "cryptoCom",
      "openSea",
      "binanceUs",
      "gemini",
      "cryptocurrencyAddress",
      "cryptocurrencyWallet",
      "okCoin",
      "bittrex",
      "kuCoin",
      "etoro",
      "cexIo",
      "binanceInternational",
      "bitstamp",
      "gateIo",
      "acorns",
      "okx",
      "bitFlyer",
      "coinlist",
      "huobi",
      "bitfinex",
      "deFiWallet",
      "krakenDirect",
      "vanguard",
      "binanceInternationalDirect",
      "bitfinexDirect",
      "bybit",
      "paxos",
      "coinbasePrime",
      "btcTurkDirect",
      "kuCoinDirect",
      "okxOAuth",
      "paribuDirect",
      "robinhoodConnect",
      "blockchainCom",
      "bitsoDirect",
      "binanceConnect",
      "binanceOAuth",
      "revolutConnect",
      "binancePay",
      "bybitDirect",
      "paribuOAuth",
      "payPalConnect",
      "binanceTrDirect",
      "coinbaseRamp",
      "bybitDirectMobile",
    ),
    /**
     * Symbol of the required cryptocurrency, e.g. ETH or BTC.
     * Can be used instead of the `AddressType` field.
     */
    symbol: S.optionalWith(S.String, { nullable: true }),
    /**
     * Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.
     * Can be used instead of `Symbol` field.
     */
    addressType: S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
    /**
     * Chain of the required cryptocurrency, e.g. USDT has USDT-ERC20, USDT-TRC20, and USDT-Omni
     */
    chain: S.optionalWith(S.String, { nullable: true }),
    /**
     * Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect
     */
    mfaCode: S.optionalWith(S.String, { nullable: true }),
  })
{}

export class ApiV1TransfersAddressGet401 extends S.Struct({}) {}

export class BrokerCryptocurrencyChain extends S.Class<BrokerCryptocurrencyChain>("BrokerCryptocurrencyChain")({
  /**
   * Name of the chain, should be provided when initiating a transfer
   */
  chain: S.optionalWith(S.String, { nullable: true }),
  feeDescription: S.optionalWith(S.String, { nullable: true }),
  /**
   * Notes or tips provided by the integration
   */
  notes: S.optionalWith(S.String, { nullable: true }),
  fee: S.optionalWith(S.Number, { nullable: true }),
  minWithdrawAmount: S.optionalWith(S.Number, { nullable: true }),
  maxWithdrawAmount: S.optionalWith(S.Number, { nullable: true }),
  networkId: S.optionalWith(S.String, { nullable: true }),
}) {}

export class B2BBrokerCryptocurrencySymbolDetailsResponse
  extends S.Class<B2BBrokerCryptocurrencySymbolDetailsResponse>("B2BBrokerCryptocurrencySymbolDetailsResponse")({
    /**
     * Requested symbol
     */
    symbol: S.optionalWith(S.String, { nullable: true }),
    /**
     * Supported address types
     */
    addressTypes: S.optionalWith(S.Array(CryptocurrencyAddressType), { nullable: true }),
    /**
     * Supported chains. One of the values should be provided to execute transfers
     */
    chains: S.optionalWith(S.Array(BrokerCryptocurrencyChain), { nullable: true }),
  })
{}

export class B2BBrokerCryptocurrencySymbolDetailsResponseApiResult
  extends S.Class<B2BBrokerCryptocurrencySymbolDetailsResponseApiResult>(
    "B2BBrokerCryptocurrencySymbolDetailsResponseApiResult",
  )({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    content: S.optionalWith(B2BBrokerCryptocurrencySymbolDetailsResponse, { nullable: true }),
  })
{}

export class ApiV1TransfersSymbolDetails401 extends S.Struct({}) {}

export class ApiV1WalletsVerifyParams extends S.Struct({
  UserId: S.optionalWith(S.String, { nullable: true }),
  Address: S.optionalWith(S.String, { nullable: true }),
}) {}

/**
 * Verifications data.
 */
export class DeFiWalletVerification extends S.Class<DeFiWalletVerification>("DeFiWalletVerification")({
  /**
   * User identifier.
   */
  userId: S.optionalWith(S.String, { nullable: true }),
  /**
   * Wallet address.
   */
  address: S.optionalWith(S.String, { nullable: true }),
  /**
   * Wallet Xpub key for Bitcon wallets.
   */
  xPubKey: S.optionalWith(S.String, { nullable: true }),
  /**
   * Wallet network type.
   */
  networkType: S.optionalWith(
    S.Literal(
      "unknown",
      "evm",
      "solana",
      "bitcoin",
      "cardano",
      "tron",
      "avalancheX",
      "tezos",
      "dogecoin",
      "ripple",
      "stellar",
      "litecoin",
      "sui",
      "aptos",
      "tvm",
      "injective",
    ),
    { nullable: true },
  ),
  /**
   * Verification method.
   */
  verificationMethod: S.optionalWith(S.Literal("signedMessage"), { nullable: true }),
  /**
   * Original message.
   */
  message: S.optionalWith(S.String, { nullable: true }),
  /**
   * Message signature.
   */
  signedMessageHash: S.optionalWith(S.String, { nullable: true }),
  /**
   * Verification created timestamp.
   */
  timestamp: S.optionalWith(S.Int, { nullable: true }),
}) {}

/**
 * Verifications response.
 */
export class DeFiWalletVerificationResponse
  extends S.Class<DeFiWalletVerificationResponse>("DeFiWalletVerificationResponse")({
    /**
     * List of found verifications.
     */
    verifications: S.optionalWith(S.Array(DeFiWalletVerification), { nullable: true }),
  })
{}

export class DeFiWalletVerificationResponseApiResult
  extends S.Class<DeFiWalletVerificationResponseApiResult>("DeFiWalletVerificationResponseApiResult")({
    status: S.optionalWith(
      S.Literal(
        "ok",
        "serverFailure",
        "permissionDenied",
        "badRequest",
        "notFound",
        "conflict",
        "tooManyRequest",
        "locked",
        "unavailableForLegalReasons",
      ),
      { nullable: true },
    ),
    /**
     * A message generated by the API
     */
    message: S.optionalWith(S.String, { nullable: true }),
    /**
     * User-friendly display message that can be presented to the end user
     */
    displayMessage: S.optionalWith(S.String, { nullable: true }),
    /**
     * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
     * All possible error types are available in the documentation.
     */
    errorType: S.optionalWith(S.String, { nullable: true }),
    /**
     * Verifications response.
     */
    content: S.optionalWith(DeFiWalletVerificationResponse, { nullable: true }),
  })
{}

export class ApiV1WalletsVerify401 extends S.Struct({}) {}

export const make = (
  httpClient: HttpClient.HttpClient,
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {},
): Client => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse: <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ) => (
    request: HttpClientRequest.HttpClientRequest,
  ) => Effect.Effect<any, any> = options.transformClient
    ? (f) => (request) =>
      Effect.flatMap(
        Effect.flatMap(options.transformClient!(httpClient), (client) => client.execute(request)),
        f,
      )
    : (f) => (request) => Effect.flatMap(httpClient.execute(request), f)
  const decodeSuccess = <A, I, R>(schema: S.Schema<A, I, R>) => (response: HttpClientResponse.HttpClientResponse) =>
    HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, A, I, R>(tag: Tag, schema: S.Schema<A, I, R>) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(ClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "POST/api/v1/account/verify": (options) =>
      HttpClientRequest.post(`/api/v1/account/verify`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerAccountDetailsResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1AccountVerify401", ApiV1AccountVerify401),
          "403": decodeError("ApiV1AccountVerify403", ApiV1AccountVerify403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/exchange/verify": (options) =>
      HttpClientRequest.post(`/api/v1/exchange/verify`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerAccountDetailsResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1ExchangeVerify401", ApiV1ExchangeVerify401),
          "403": decodeError("ApiV1ExchangeVerify403", ApiV1ExchangeVerify403),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/assets/{assetType}": (assetType, options) =>
      HttpClientRequest.get(`/api/v1/assets/${assetType}`).pipe(
        HttpClientRequest.setUrlParams({
          Search: options?.["Search"] as any,
          Count: options?.["Count"] as any,
          Offset: options?.["Offset"] as any,
        }),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(AssetPaginationResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1AssetsAssetType401", ApiV1AssetsAssetType401),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/balance/get": (options) =>
      HttpClientRequest.post(`/api/v1/balance/get`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerAccountBalanceModelApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1BalanceGet401", ApiV1BalanceGet401),
          "403": decodeError("ApiV1BalanceGet403", ApiV1BalanceGet403),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/balance/portfolio": (options) =>
      HttpClientRequest.get(`/api/v1/balance/portfolio`).pipe(
        HttpClientRequest.setUrlParams({ UserId: options?.["UserId"] as any }),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BFiatPortfolioModelApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1BalancePortfolio401", ApiV1BalancePortfolio401),
          "403": decodeError("ApiV1BalancePortfolio403", ApiV1BalancePortfolio403),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/cataloglink": (options) =>
      HttpClientRequest.get(`/api/v1/cataloglink`).pipe(
        HttpClientRequest.setUrlParams({
          UserId: options?.["UserId"] as any,
          BrokerType: options?.["BrokerType"] as any,
          EnableTransfers: options?.["EnableTransfers"] as any,
          RestrictMultipleAccounts: options?.["RestrictMultipleAccounts"] as any,
          DisableApiKeyGeneration: options?.["DisableApiKeyGeneration"] as any,
        }),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CatalogLinkApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1Cataloglink401", ApiV1Cataloglink401),
          "404": decodeError("ApiResult", ApiResult),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/cataloglink": (options) =>
      HttpClientRequest.post(`/api/v1/cataloglink`).pipe(
        HttpClientRequest.setUrlParams({
          UserId: options.params?.["UserId"] as any,
          BrokerType: options.params?.["BrokerType"] as any,
          EnableTransfers: options.params?.["EnableTransfers"] as any,
          RestrictMultipleAccounts: options.params?.["RestrictMultipleAccounts"] as any,
          DisableApiKeyGeneration: options.params?.["DisableApiKeyGeneration"] as any,
        }),
        HttpClientRequest.bodyUnsafeJson(options.payload),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(CatalogLinkApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1Cataloglink401", ApiV1Cataloglink401),
          "404": decodeError("ApiResult", ApiResult),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/linktoken": (options) =>
      HttpClientRequest.post(`/api/v1/linktoken`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(LinkTokenModelApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1Linktoken401", ApiV1Linktoken401),
          "404": decodeError("ApiResult", ApiResult),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/token/refresh": (options) =>
      HttpClientRequest.post(`/api/v1/token/refresh`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerRefreshTokenResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TokenRefresh401", ApiV1TokenRefresh401),
          orElse: unexpectedStatus,
        })),
      ),
    "DELETE/api/v1/account": (options) =>
      HttpClientRequest.del(`/api/v1/account`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1Account401", ApiV1Account401),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/status": () =>
      HttpClientRequest.get(`/api/v1/status`).pipe(
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokersHealthStatusListApiResult),
          "401": decodeError("ApiV1Status401", ApiV1Status401),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/authenticationSchemes": () =>
      HttpClientRequest.get(`/api/v1/authenticationSchemes`).pipe(
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(BrokerAuthenticationSchemeIReadOnlyCollectionApiResult),
          "401": decodeError("ApiV1AuthenticationSchemes401", ApiV1AuthenticationSchemes401),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/authenticate": (options) =>
      HttpClientRequest.post(`/api/v1/authenticate`).pipe(
        HttpClientRequest.setUrlParams({ userId: options.params?.["userId"] as any }),
        HttpClientRequest.bodyUnsafeJson(options.payload),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerAuthResponseApiResult),
          "400": decodeError("ProblemDetails", ProblemDetails),
          "500": () => Effect.void,
          "503": () => Effect.void,
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/authenticate/{brokerType}": (brokerType, options) =>
      HttpClientRequest.get(`/api/v1/authenticate/${brokerType}`).pipe(
        HttpClientRequest.setUrlParams({ userId: options?.["userId"] as any }),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerAuthPromptResponseApiResult),
          "400": decodeError("ProblemDetails", ProblemDetails),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/integrations": () =>
      HttpClientRequest.get(`/api/v1/integrations`).pipe(
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(IntegrationsResponseApiResult),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/transfers/managed/networks": () =>
      HttpClientRequest.get(`/api/v1/transfers/managed/networks`).pipe(
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(NetworkModelResponseApiResult),
          "401": decodeError("ApiV1TransfersManagedNetworks401", ApiV1TransfersManagedNetworks401),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/transfers/managed/integrations": () =>
      HttpClientRequest.get(`/api/v1/transfers/managed/integrations`).pipe(
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(IntegrationNetworkResponseApiResult),
          "401": decodeError("ApiV1TransfersManagedIntegrations401", ApiV1TransfersManagedIntegrations401),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/transfers/managed/tokens": () =>
      HttpClientRequest.get(`/api/v1/transfers/managed/tokens`).pipe(
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(TokenNetworksResponseApiResult),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/transfers/managed/verify": (options) =>
      HttpClientRequest.get(`/api/v1/transfers/managed/verify`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(TransferVerificationResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersManagedVerify401", ApiV1TransfersManagedVerify401),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/managed/configure": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/managed/configure`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ConfigureTransferResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersManagedConfigure401", ApiV1TransfersManagedConfigure401),
          "403": decodeError("ApiV1TransfersManagedConfigure403", ApiV1TransfersManagedConfigure403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/managed/preview": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/managed/preview`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(PreviewTransferResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersManagedPreview401", ApiV1TransfersManagedPreview401),
          "403": decodeError("ApiV1TransfersManagedPreview403", ApiV1TransfersManagedPreview403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/managed/execute": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/managed/execute`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ExecuteTransferResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersManagedExecute401", ApiV1TransfersManagedExecute401),
          "403": decodeError("ApiV1TransfersManagedExecute403", ApiV1TransfersManagedExecute403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/managed/address/get": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/managed/address/get`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerCryptocurrencyDepositAddressResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersManagedAddressGet401", ApiV1TransfersManagedAddressGet401),
          "404": decodeError("ApiResult", ApiResult),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/managed/quote": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/managed/quote`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(QuoteTransferResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersManagedQuote401", ApiV1TransfersManagedQuote401),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/transfers/managed/mesh": (options) =>
      HttpClientRequest.get(`/api/v1/transfers/managed/mesh`).pipe(
        HttpClientRequest.setUrlParams({
          Count: options?.["Count"] as any,
          Offset: options?.["Offset"] as any,
          Id: options?.["Id"] as any,
          ClientTransactionId: options?.["ClientTransactionId"] as any,
          UserId: options?.["UserId"] as any,
          IntegrationIds: options?.["IntegrationIds"] as any,
          Statuses: options?.["Statuses"] as any,
          FromTimestamp: options?.["FromTimestamp"] as any,
          ToTimestamp: options?.["ToTimestamp"] as any,
          MinAmountInFiat: options?.["MinAmountInFiat"] as any,
          MaxAmountInFiat: options?.["MaxAmountInFiat"] as any,
          OrderBy: options?.["OrderBy"] as any,
          Hash: options?.["Hash"] as any,
          SubClientId: options?.["SubClientId"] as any,
          DescendingOrder: options?.["DescendingOrder"] as any,
        }),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(TransferModelPaginationResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersManagedMesh401", ApiV1TransfersManagedMesh401),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/managed/update": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/managed/update`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(UpdateTransferResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersManagedUpdate401", ApiV1TransfersManagedUpdate401),
          "403": decodeError("ApiV1TransfersManagedUpdate403", ApiV1TransfersManagedUpdate403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/holdings/get": (options) =>
      HttpClientRequest.post(`/api/v1/holdings/get`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(HoldingsModelApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1HoldingsGet401", ApiV1HoldingsGet401),
          "403": decodeError("ApiV1HoldingsGet403", ApiV1HoldingsGet403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/holdings/value": (options) =>
      HttpClientRequest.post(`/api/v1/holdings/value`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(BrokerPortfolioValueModelApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1HoldingsValue401", ApiV1HoldingsValue401),
          "403": decodeError("ApiV1HoldingsValue403", ApiV1HoldingsValue403),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/holdings/portfolio": (options) =>
      HttpClientRequest.get(`/api/v1/holdings/portfolio`).pipe(
        HttpClientRequest.setUrlParams({
          UserId: options?.["UserId"] as any,
          TimezoneOffset: options?.["TimezoneOffset"] as any,
        }),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BPortfolioModelApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1HoldingsPortfolio401", ApiV1HoldingsPortfolio401),
          "403": decodeError("ApiV1HoldingsPortfolio403", ApiV1HoldingsPortfolio403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/catalog/solana/getLatestBlockhash": (options) =>
      HttpClientRequest.post(`/api/v1/catalog/solana/getLatestBlockhash`).pipe(
        HttpClientRequest.setUrlParams({ chainId: options?.["chainId"] as any }),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(StringApiResult),
          "400": decodeError("ProblemDetails", ProblemDetails),
          "500": () => Effect.void,
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transactions/list": (options) =>
      HttpClientRequest.post(`/api/v1/transactions/list`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerOrderListResponseApiResult),
          "401": decodeError("ApiV1TransactionsList401", ApiV1TransactionsList401),
          "403": decodeError("ApiV1TransactionsList403", ApiV1TransactionsList403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transactions/details": (options) =>
      HttpClientRequest.post(`/api/v1/transactions/details`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerOrderApiResult),
          "400": decodeError("ProblemDetails", ProblemDetails),
          "401": decodeError("ApiV1TransactionsDetails401", ApiV1TransactionsDetails401),
          "403": decodeError("ApiV1TransactionsDetails403", ApiV1TransactionsDetails403),
          "404": decodeError("ProblemDetails", ProblemDetails),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transactions/featureList": (options) =>
      HttpClientRequest.post(`/api/v1/transactions/featureList`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerTradingFeatureInfoApiResult),
          "400": decodeError("ProblemDetails", ProblemDetails),
          "401": decodeError("ApiV1TransactionsFeatureList401", ApiV1TransactionsFeatureList401),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transactions/preview/{side}": (side, options) =>
      HttpClientRequest.post(`/api/v1/transactions/preview/${side}`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerPreviewOrderResultApiResult),
          "400": decodeError("ProblemDetails", ProblemDetails),
          "401": decodeError("ApiV1TransactionsPreviewSide401", ApiV1TransactionsPreviewSide401),
          "403": decodeError("ApiV1TransactionsPreviewSide403", ApiV1TransactionsPreviewSide403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transactions/{side}": (side, options) =>
      HttpClientRequest.post(`/api/v1/transactions/${side}`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerCreateOrderResultApiResult),
          "400": decodeError("ProblemDetails", ProblemDetails),
          "401": decodeError("ApiV1TransactionsSide401", ApiV1TransactionsSide401),
          "403": decodeError("ApiV1TransactionsSide403", ApiV1TransactionsSide403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transactions/cancel": (options) =>
      HttpClientRequest.post(`/api/v1/transactions/cancel`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(ApiResult),
          "400": decodeError("ProblemDetails", ProblemDetails),
          "401": decodeError("ApiV1TransactionsCancel401", ApiV1TransactionsCancel401),
          "403": decodeError("ApiV1TransactionsCancel403", ApiV1TransactionsCancel403),
          "404": decodeError("ProblemDetails", ProblemDetails),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transactions/symbolinfo": (options) =>
      HttpClientRequest.post(`/api/v1/transactions/symbolinfo`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerOrderSymbolInfoApiResult),
          "400": decodeError("ProblemDetails", ProblemDetails),
          "401": decodeError("ApiV1TransactionsSymbolinfo401", ApiV1TransactionsSymbolinfo401),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/list": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/list`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerTransactionsListModelApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersList401", ApiV1TransfersList401),
          "403": decodeError("ApiV1TransfersList403", ApiV1TransfersList403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/details": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/details`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerCryptocurrencyTransactionApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersDetails401", ApiV1TransfersDetails401),
          "403": decodeError("ApiV1TransfersDetails403", ApiV1TransfersDetails403),
          "404": decodeError("ApiResult", ApiResult),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers": (options) =>
      HttpClientRequest.post(`/api/v1/transfers`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerCreateCryptocurrencyTransactionResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1Transfers401", ApiV1Transfers401),
          "403": decodeError("ApiV1Transfers403", ApiV1Transfers403),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/address/get": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/address/get`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerCryptocurrencyDepositAddressResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersAddressGet401", ApiV1TransfersAddressGet401),
          "404": decodeError("ApiResult", ApiResult),
          orElse: unexpectedStatus,
        })),
      ),
    "POST/api/v1/transfers/symbol/details": (options) =>
      HttpClientRequest.post(`/api/v1/transfers/symbol/details`).pipe(
        HttpClientRequest.bodyUnsafeJson(options),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(B2BBrokerCryptocurrencySymbolDetailsResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1TransfersSymbolDetails401", ApiV1TransfersSymbolDetails401),
          "404": decodeError("ApiResult", ApiResult),
          orElse: unexpectedStatus,
        })),
      ),
    "GET/api/v1/wallets/verify": (options) =>
      HttpClientRequest.get(`/api/v1/wallets/verify`).pipe(
        HttpClientRequest.setUrlParams({ UserId: options?.["UserId"] as any, Address: options?.["Address"] as any }),
        withResponse(HttpClientResponse.matchStatus({
          "2xx": decodeSuccess(DeFiWalletVerificationResponseApiResult),
          "400": decodeError("ApiResult", ApiResult),
          "401": decodeError("ApiV1WalletsVerify401", ApiV1WalletsVerify401),
          orElse: unexpectedStatus,
        })),
      ),
  }
}

export interface Client {
  readonly httpClient: HttpClient.HttpClient
  /**
   * Return KYC details of the user.
   */
  readonly "POST/api/v1/account/verify": (
    options: typeof B2BBrokerAccountDetailsRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerAccountDetailsResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1AccountVerify401", typeof ApiV1AccountVerify401.Type>
    | ClientError<"ApiV1AccountVerify403", typeof ApiV1AccountVerify403.Type>
  >
  /**
   * Returns basic profile data of the user's exchange account.
   * Available data varies by exchange and linked account.
   */
  readonly "POST/api/v1/exchange/verify": (
    options: typeof ExchangeAccountInfoRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerAccountDetailsResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1ExchangeVerify401", typeof ApiV1ExchangeVerify401.Type>
    | ClientError<"ApiV1ExchangeVerify403", typeof ApiV1ExchangeVerify403.Type>
  >
  /**
   * Get available assets
   */
  readonly "GET/api/v1/assets/{assetType}": (
    assetType: string,
    options?: typeof ApiV1AssetsAssetTypeParams.Encoded | undefined,
  ) => Effect.Effect<
    typeof AssetPaginationResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1AssetsAssetType401", typeof ApiV1AssetsAssetType401.Type>
  >
  /**
   * Get real-time account fiat balances.
   */
  readonly "POST/api/v1/balance/get": (
    options: typeof BalanceBrokerBaseRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerAccountBalanceModelApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1BalanceGet401", typeof ApiV1BalanceGet401.Type>
    | ClientError<"ApiV1BalanceGet403", typeof ApiV1BalanceGet403.Type>
  >
  /**
   * Get cached aggregated fiat balances from all connected integrations.
   */
  readonly "GET/api/v1/balance/portfolio": (
    options?: typeof ApiV1BalancePortfolioParams.Encoded | undefined,
  ) => Effect.Effect<
    typeof B2BFiatPortfolioModelApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1BalancePortfolio401", typeof ApiV1BalancePortfolio401.Type>
    | ClientError<"ApiV1BalancePortfolio403", typeof ApiV1BalancePortfolio403.Type>
  >
  /**
   * Get personalized catalog link for client
   */
  readonly "GET/api/v1/cataloglink": (
    options: typeof ApiV1CataloglinkParams.Encoded,
  ) => Effect.Effect<
    typeof CatalogLinkApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1Cataloglink401", typeof ApiV1Cataloglink401.Type>
    | ClientError<"ApiResult", typeof ApiResult.Type>
  >
  /**
   * Get personalized catalog link for client supplying parameters for Link actions, such as transfers
   */
  readonly "POST/api/v1/cataloglink": (
    options: {
      readonly params: typeof ApiV1CataloglinkParams.Encoded
      readonly payload: typeof InitializeTransfersForLinkRequest.Encoded
    },
  ) => Effect.Effect<
    typeof CatalogLinkApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1Cataloglink401", typeof ApiV1Cataloglink401.Type>
    | ClientError<"ApiResult", typeof ApiResult.Type>
  >
  /**
   * Get a short lived, one-time use token for initializing a Link session using the client-side SDKs
   */
  readonly "POST/api/v1/linktoken": (
    options: typeof GetLinkTokenRequest.Encoded,
  ) => Effect.Effect<
    typeof LinkTokenModelApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1Linktoken401", typeof ApiV1Linktoken401.Type>
    | ClientError<"ApiResult", typeof ApiResult.Type>
  >
  /**
   * Refresh auth token of the connected institution.
   * Some institutions do not require tokens to be refreshed.
   *
   * The following institutions require custom flows:
   *
   * WeBull: AuthToken should be provided along with the RefreshToken
   *
   * Vanguard: security settings may activate MFA, requiring user action.
   * If MFA is triggered, a second refresh request should be sent.
   * Second request should contain MFA code and access token obtained from initial response
   */
  readonly "POST/api/v1/token/refresh": (
    options: typeof BrokerRefreshTokenRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerRefreshTokenResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TokenRefresh401", typeof ApiV1TokenRefresh401.Type>
  >
  /**
   * Remove connection to the financial institution and erase all related data completely.
   */
  readonly "DELETE/api/v1/account": (
    options: typeof BrokerBaseRequest.Encoded,
  ) => Effect.Effect<
    typeof ApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1Account401", typeof ApiV1Account401.Type>
  >
  /**
   * Get the list of supported institutions and their health statuses.
   */
  readonly "GET/api/v1/status": () => Effect.Effect<
    typeof B2BBrokersHealthStatusListApiResult.Type,
    HttpClientError.HttpClientError | ParseError | ClientError<"ApiV1Status401", typeof ApiV1Status401.Type>
  >
  /**
   * Get authentication schemes of available integrations to perform authentication programmatically (not using
   * the Web Catalog UI).
   */
  readonly "GET/api/v1/authenticationSchemes": () => Effect.Effect<
    typeof BrokerAuthenticationSchemeIReadOnlyCollectionApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiV1AuthenticationSchemes401", typeof ApiV1AuthenticationSchemes401.Type>
  >
  /**
   * Authenticate user's brokerage/exchange account programmatically (not using the Web Catalog UI)
   */
  readonly "POST/api/v1/authenticate": (
    options: {
      readonly params: typeof ApiV1AuthenticateParams.Encoded
      readonly payload: typeof B2BBrokerAuthRequest.Encoded
    },
  ) => Effect.Effect<
    typeof B2BBrokerAuthResponseApiResult.Type,
    HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
  >
  /**
   * Get OAuth link for the integrations with `OAuth` AuthenticationSchemeType
   */
  readonly "GET/api/v1/authenticate/{brokerType}": (
    brokerType: string,
    options: typeof ApiV1AuthenticateBrokerTypeParams.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerAuthPromptResponseApiResult.Type,
    HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
  >
  /**
   * Returns a list of integrations with details including the integration ID, name, type,
   * DeFi wallet provider ID, and categories.
   */
  readonly "GET/api/v1/integrations": () => Effect.Effect<
    typeof IntegrationsResponseApiResult.Type,
    HttpClientError.HttpClientError | ParseError
  >
  /**
   * **Get supported networks list.**
   *
   * ---
   * Get the list of all networks supported by Mesh to perform transfers, including which tokens and integrations are supported.
   */
  readonly "GET/api/v1/transfers/managed/networks": () => Effect.Effect<
    typeof NetworkModelResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiV1TransfersManagedNetworks401", typeof ApiV1TransfersManagedNetworks401.Type>
  >
  /**
   * **Get supported integrations list.**
   *
   * ---
   * Get the list of all integrations supported by Mesh to perform transfers, including which tokens and networks are supported.
   */
  readonly "GET/api/v1/transfers/managed/integrations": () => Effect.Effect<
    typeof IntegrationNetworkResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiV1TransfersManagedIntegrations401", typeof ApiV1TransfersManagedIntegrations401.Type>
  >
  /**
   * Get the list of all tokens supported by Mesh to perform transfers, including which networks and integrations are supported.
   */
  readonly "GET/api/v1/transfers/managed/tokens": () => Effect.Effect<
    typeof TokenNetworksResponseApiResult.Type,
    HttpClientError.HttpClientError | ParseError
  >
  /**
   * Checks if the combination of integration ID, network ID, token is correct for transfer.
   * Checks if the target address is in the correct format.
   */
  readonly "GET/api/v1/transfers/managed/verify": (
    options: typeof TransferVerificationRequest.Encoded,
  ) => Effect.Effect<
    typeof TransferVerificationResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersManagedVerify401", typeof ApiV1TransfersManagedVerify401.Type>
  >
  /**
   * **Get the list of networks and tokens eligible for a transfer, based on the provided request data.**
   *
   * ---
   * Transfers can be configured either from one connected account to another connected account, or
   * from a connected account to any arbitrary address or addresses.
   *
   * * **From one connected account to another connected account:**
   *
   * The API client provides `FromAuthToken` that is representing the source account and `ToAuthToken` that is representing the target account. Front API maps networks and tokens supported by both accounts and returns all tokens and networks eligible for a transfer as the result.
   *
   * * **From a connected account to any arbitrary address:**
   *
   * The API client provides `FromAuthToken` that is representing the source account and the list of target addresses using the `ToAddresses` field. Front API verifies the addresses and returns the list of tokens, eligible to be transferred as the result of the operation.
   *
   * Returns the list of holdings on the account that can be used to perform the transfer. Each holdings item
   * contains the list of supported networks that can be used to transfer the corresponding asset.
   * Each network contains details such as gas fees and the amount eligible to be transferred.
   */
  readonly "POST/api/v1/transfers/managed/configure": (
    options: typeof ConfigureTransferRequest.Encoded,
  ) => Effect.Effect<
    typeof ConfigureTransferResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersManagedConfigure401", typeof ApiV1TransfersManagedConfigure401.Type>
    | ClientError<"ApiV1TransfersManagedConfigure403", typeof ApiV1TransfersManagedConfigure403.Type>
  >
  /**
   * **Validate and preview the transfer.**
   *
   * ---
   * Validates the transfer, calculates the relevant amount in crypto if requested amount was in fiat and updates
   * the current network fee values.
   *
   * This endpoint uses the `NetworkId` field to specify which network will be used to perform the transfer. The target `NetworkId`
   * should be selected after configuring the transfer using `/configure` endpoint.
   *
   * Returns the `PreviewId` value that can be used to commit the transfer.
   */
  readonly "POST/api/v1/transfers/managed/preview": (
    options: typeof PreviewTransferRequest.Encoded,
  ) => Effect.Effect<
    typeof PreviewTransferResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersManagedPreview401", typeof ApiV1TransfersManagedPreview401.Type>
    | ClientError<"ApiV1TransfersManagedPreview403", typeof ApiV1TransfersManagedPreview403.Type>
  >
  /**
   * **Commit the previously previewed transfer.**
   *
   * ---
   * Previews the transfer, using the `PreviewId` value.
   *
   * Handles multi-factor authentication codes if the account is configured to use them for additional security.
   *
   * Returns the status of the transfer and the details of the transfer if it was initiated successfully.
   */
  readonly "POST/api/v1/transfers/managed/execute": (
    options: typeof ExecuteTransferRequest.Encoded,
  ) => Effect.Effect<
    typeof ExecuteTransferResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersManagedExecute401", typeof ApiV1TransfersManagedExecute401.Type>
    | ClientError<"ApiV1TransfersManagedExecute403", typeof ApiV1TransfersManagedExecute403.Type>
  >
  /**
   * Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
   */
  readonly "POST/api/v1/transfers/managed/address/get": (
    options: typeof ManagedBrokerCryptocurrencyDepositAddressRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerCryptocurrencyDepositAddressResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersManagedAddressGet401", typeof ApiV1TransfersManagedAddressGet401.Type>
    | ClientError<"ApiResult", typeof ApiResult.Type>
  >
  /**
   * Get a quote for transferring a fiat amount from a brokerage account in a given cryptocurrency over a specified network.
   * Returns min and max fees and amounts to account for different funding sources (existing crypto balance, cash balance or
   * ACH/debit deposit). Currently only supported for Coinbase.
   */
  readonly "POST/api/v1/transfers/managed/quote": (
    options: typeof QuoteTransferRequest.Encoded,
  ) => Effect.Effect<
    typeof QuoteTransferResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersManagedQuote401", typeof ApiV1TransfersManagedQuote401.Type>
  >
  /**
   * Get cryptocurrency transfers initiated by Mesh on exchanges or self-custody wallets.
   */
  readonly "GET/api/v1/transfers/managed/mesh": (
    options?: typeof ApiV1TransfersManagedMeshParams.Encoded | undefined,
  ) => Effect.Effect<
    typeof TransferModelPaginationResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersManagedMesh401", typeof ApiV1TransfersManagedMesh401.Type>
  >
  /**
   * **Updates the previously executed transfer.**
   *
   * ---
   * Updates the transfer status, using the `TransactionId` value.
   * Returns the status of the transfer and the details of the transfer.
   */
  readonly "POST/api/v1/transfers/managed/update": (
    options: typeof UpdateTransferStatusRequest.Encoded,
  ) => Effect.Effect<
    typeof UpdateTransferResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersManagedUpdate401", typeof ApiV1TransfersManagedUpdate401.Type>
    | ClientError<"ApiV1TransfersManagedUpdate403", typeof ApiV1TransfersManagedUpdate403.Type>
  >
  /**
   * Obtain assets from the connected investment account. Performs realtime API call to the underlying integration.
   */
  readonly "POST/api/v1/holdings/get": (
    options: typeof PortfolioHoldingsRequest.Encoded,
  ) => Effect.Effect<
    typeof HoldingsModelApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1HoldingsGet401", typeof ApiV1HoldingsGet401.Type>
    | ClientError<"ApiV1HoldingsGet403", typeof ApiV1HoldingsGet403.Type>
  >
  /**
   * Obtain assets from the connected investment account and return total value and performance.
   * Performs realtime API call to the underlying integration.
   */
  readonly "POST/api/v1/holdings/value": (
    options: typeof PortfolioBrokerBaseRequest.Encoded,
  ) => Effect.Effect<
    typeof BrokerPortfolioValueModelApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1HoldingsValue401", typeof ApiV1HoldingsValue401.Type>
    | ClientError<"ApiV1HoldingsValue403", typeof ApiV1HoldingsValue403.Type>
  >
  /**
   * Get the aggregated portfolio of the user containing market values.
   */
  readonly "GET/api/v1/holdings/portfolio": (
    options: typeof ApiV1HoldingsPortfolioParams.Encoded,
  ) => Effect.Effect<
    typeof B2BPortfolioModelApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1HoldingsPortfolio401", typeof ApiV1HoldingsPortfolio401.Type>
    | ClientError<"ApiV1HoldingsPortfolio403", typeof ApiV1HoldingsPortfolio403.Type>
  >
  readonly "POST/api/v1/catalog/solana/getLatestBlockhash": (
    options?: typeof ApiV1CatalogSolanaGetLatestBlockhashParams.Encoded | undefined,
  ) => Effect.Effect<
    typeof StringApiResult.Type,
    HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
  >
  /**
   * Get transactions on the account - the paginated history of the executed orders along with the pending orders.
   */
  readonly "POST/api/v1/transactions/list": (
    options: typeof TransactionsB2BBrokerOrderListRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerOrderListResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiV1TransactionsList401", typeof ApiV1TransactionsList401.Type>
    | ClientError<"ApiV1TransactionsList403", typeof ApiV1TransactionsList403.Type>
  >
  /**
   * Get details of an executed order. Typically used to poll the status of the previously executed order.
   */
  readonly "POST/api/v1/transactions/details": (
    options: typeof TransactionsB2BBrokerOrderRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerOrderApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
    | ClientError<"ApiV1TransactionsDetails401", typeof ApiV1TransactionsDetails401.Type>
    | ClientError<"ApiV1TransactionsDetails403", typeof ApiV1TransactionsDetails403.Type>
    | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
  >
  /**
   * Get supported features for trading for a particular financial institution. Different institutions support different
   * features (e.g. different `OrderType` or different sets of `TimeInForce` values), so this endpoint is used to
   * describe such features for provided financial institution.
   */
  readonly "POST/api/v1/transactions/featureList": (
    options: typeof TransactionsBrokerBaseRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerTradingFeatureInfoApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
    | ClientError<"ApiV1TransactionsFeatureList401", typeof ApiV1TransactionsFeatureList401.Type>
  >
  /**
   * Validates the order information (such as necessary balance availability), and returns additional information,
   * such as expected order fee.
   * Does not execute the order.
   */
  readonly "POST/api/v1/transactions/preview/{side}": (
    side: string,
    options: typeof TransactionsB2BBrokerCreateOrderRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerPreviewOrderResultApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
    | ClientError<"ApiV1TransactionsPreviewSide401", typeof ApiV1TransactionsPreviewSide401.Type>
    | ClientError<"ApiV1TransactionsPreviewSide403", typeof ApiV1TransactionsPreviewSide403.Type>
  >
  /**
   * Validates the order information and then calls institution's API to execute an order.
   * It's recommended to call this endpoint after calling the `preview` endpoint to make sure that the
   * order execution request is correct.
   */
  readonly "POST/api/v1/transactions/{side}": (
    side: string,
    options: typeof TransactionsB2BBrokerCreateOrderRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerCreateOrderResultApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
    | ClientError<"ApiV1TransactionsSide401", typeof ApiV1TransactionsSide401.Type>
    | ClientError<"ApiV1TransactionsSide403", typeof ApiV1TransactionsSide403.Type>
  >
  /**
   * Cancels a pending order (an order with `InProgress` status).
   * `SymbolPair` is required to be provided for `Binance`, `BinanceInternational`, `Okx` and `BitFlyer` institutions.
   * This value
   */
  readonly "POST/api/v1/transactions/cancel": (
    options: typeof TransactionsB2BBrokerOrderRequest.Encoded,
  ) => Effect.Effect<
    typeof ApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
    | ClientError<"ApiV1TransactionsCancel401", typeof ApiV1TransactionsCancel401.Type>
    | ClientError<"ApiV1TransactionsCancel403", typeof ApiV1TransactionsCancel403.Type>
    | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
  >
  /**
   * Returns information on trading allowance for a provided symbol.
   * For example - some institutions allow fractional trading for some symbols, but do not allow it
   * for others. So before placing an order the API client can check if the required symbol can be traded fractionally
   * with the provided institution.
   */
  readonly "POST/api/v1/transactions/symbolinfo": (
    options: typeof TransactionsB2BBrokerSymbolInfoForOrderRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerOrderSymbolInfoApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ProblemDetails", typeof ProblemDetails.Type>
    | ClientError<"ApiV1TransactionsSymbolinfo401", typeof ApiV1TransactionsSymbolinfo401.Type>
  >
  /**
   * Get entire history of cryptocurrency transfers (withdrawals or deposits) executed from an exchange.
   * Only supports Exchange integrations.
   */
  readonly "POST/api/v1/transfers/list": (
    options: typeof TransfersBrokerTransactionsListRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerTransactionsListModelApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersList401", typeof ApiV1TransfersList401.Type>
    | ClientError<"ApiV1TransfersList403", typeof ApiV1TransfersList403.Type>
  >
  /**
   * Get details of a specific transfer (withdrawals or deposits) executed from an exchange.
   * Only supports Exchange integrations.
   */
  readonly "POST/api/v1/transfers/details": (
    options: typeof TransfersBrokerCryptocurrencyTransactionDetailsRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerCryptocurrencyTransactionApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersDetails401", typeof ApiV1TransfersDetails401.Type>
    | ClientError<"ApiV1TransfersDetails403", typeof ApiV1TransfersDetails403.Type>
    | ClientError<"ApiResult", typeof ApiResult.Type>
  >
  /**
   * Initiate a new cryptocurrency transfer on a blockchain, cryptocurrency broker or cryptocurrency exchange.
   * Obsolete endpoint, please use POST /transfers/managed/execute endpoint instead.
   */
  readonly "POST/api/v1/transfers": (
    options: typeof TransfersBrokerCreateCryptocurrencyTransactionRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerCreateCryptocurrencyTransactionResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1Transfers401", typeof ApiV1Transfers401.Type>
    | ClientError<"ApiV1Transfers403", typeof ApiV1Transfers403.Type>
  >
  /**
   * Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
   */
  readonly "POST/api/v1/transfers/address/get": (
    options: typeof TransfersBrokerCryptocurrencyDepositAddressRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerCryptocurrencyDepositAddressResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersAddressGet401", typeof ApiV1TransfersAddressGet401.Type>
    | ClientError<"ApiResult", typeof ApiResult.Type>
  >
  /**
   * Get details of the asset for deposit or withdrawal. For example, several exchanges support same tokens over multiple
   * blockchains, and thus require the name of chain to be supplied for transfers. This endpoint allows getting such details.
   */
  readonly "POST/api/v1/transfers/symbol/details": (
    options: typeof TransfersBrokerCryptocurrencyDepositAddressRequest.Encoded,
  ) => Effect.Effect<
    typeof B2BBrokerCryptocurrencySymbolDetailsResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1TransfersSymbolDetails401", typeof ApiV1TransfersSymbolDetails401.Type>
    | ClientError<"ApiResult", typeof ApiResult.Type>
  >
  /**
   * Get wallet verifications for user and address.
   */
  readonly "GET/api/v1/wallets/verify": (
    options?: typeof ApiV1WalletsVerifyParams.Encoded | undefined,
  ) => Effect.Effect<
    typeof DeFiWalletVerificationResponseApiResult.Type,
    | HttpClientError.HttpClientError
    | ParseError
    | ClientError<"ApiResult", typeof ApiResult.Type>
    | ClientError<"ApiV1WalletsVerify401", typeof ApiV1WalletsVerify401.Type>
  >
}

export interface ClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class ClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const ClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): ClientError<Tag, E> =>
  new ClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any
