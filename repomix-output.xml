This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  components/
    ui/
      button.tsx
      dialog.tsx
  lib/
    utils.ts
  public/
    vite.svg
  app.tsx
  client.ts
  components.json
  global.css
  index.html
  main.tsx
  package.json
  tsconfig.json
  vite-env.d.ts
  vite.config.ts
domain/
  Api.ts
  common.ts
  index.ts
  package.json
  tsconfig.json
experimental_client/
  Generated.ts
  MeshClient.ts
  openapi.json
  package.json
  README.md
  tsconfig.json
playground/
  tsconfig.json
server/
  ApiLive.ts
  ConfigService.ts
  CurrentUserId.ts
  Db.ts
  main.ts
  MemoryDb.ts
  package.json
  tokens.ts
  tsconfig.json
tasks/
  ensure_uuid_extension.ts
  generate_mesh_client.ts
  main.ts
  tsconfig.json
.gitignore
cspell.json
dprint.json
package.json
tsconfig.base.json
tsconfig.json
words.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="experimental_client/MeshClient.ts">
import * as HttpClient from "@effect/platform/HttpClient"
import * as HttpClientRequest from "@effect/platform/HttpClientRequest"
import * as Config from "effect/Config"
import * as Context from "effect/Context"
import * as Effect from "effect/Effect"
import { flow } from "effect/Function"
import * as Layer from "effect/Layer"
import * as Redacted from "effect/Redacted"
import { type Client, make as makeGenerated } from "./Generated.ts"

export class MeshClient extends Context.Tag("MeshClient")<MeshClient, Client>() {}

export interface MeshClientConfig {
  clientId: string
  secret: Redacted.Redacted
}

export const make = Effect.fnUntraced(function*({ clientId, secret }: MeshClientConfig) {
  return (yield* HttpClient.HttpClient).pipe(
    HttpClient.mapRequest(flow(
      HttpClientRequest.prependUrl("https://integration-api.meshconnect.com"),
      HttpClientRequest.setHeaders({
        "X-Client-Id": clientId,
        "X-Client-Secret": Redacted.value(secret),
      }),
    )),
    makeGenerated,
  )
})

export const layerConfig = (config: Config.Config.Wrap<MeshClientConfig>) =>
  Layer.effect(
    MeshClient,
    Config.unwrap(config).pipe(
      Effect.flatMap(make),
    ),
  )
</file>

<file path="server/ApiLive.ts">
import { Api } from "@1b1/domain"
import * as MeshClient from "@1b1/experimental_client/MeshClient"
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
import * as HttpApiError from "@effect/platform/HttpApiError"
import * as Effect from "effect/Effect"
import * as Redacted from "effect/Redacted"
import assert from "node:assert"
import { ConfigService } from "./ConfigService.ts"
import { CurrentUserId } from "./CurrentUserId.ts"
import { Db } from "./Db.ts"
import { coinbaseAccessToken, metamaskAccessToken } from "./tokens.ts"

// TODO: Replace with actual user ID retrieval logic
const userId = "1b1"
const symbol = "ETH"

export const ApiLive = HttpApiBuilder.group(
  Api,
  "v1",
  Effect.fn(function*(handlers) {
    const { destinationAddress } = yield* ConfigService
    const mesh = yield* MeshClient.MeshClient
    const db = yield* Db

    const ethereumNetworkId = yield* mesh["GET/api/v1/transfers/managed/networks"]().pipe(
      Effect.map(({ content }) => content?.networks?.find((network) => network.name === "Ethereum")?.id),
      Effect.flatMap(Effect.fromNullable),
    )

    const integrations = yield* mesh["GET/api/v1/transfers/managed/integrations"]().pipe(
      Effect.map(({ content }) => content?.integrations),
      Effect.flatMap(Effect.fromNullable),
      Effect.orDie,
    )

    let coinbaseIntegrationId: string | undefined
    let metamaskIntegrationId: string | undefined
    for (const { name, id } of integrations) {
      if (name === "Coinbase") {
        coinbaseIntegrationId = id!
      } else if (name === "MetaMask") {
        metamaskIntegrationId = id!
      }
    }
    assert(
      typeof coinbaseIntegrationId === "string" && typeof metamaskIntegrationId === "string",
    )

    return handlers
      .handle(
        "createLinkToken",
        Effect.fn(function*({ payload: { _tag } }) {
          return yield* mesh["POST/api/v1/linktoken"]({
            userId,
            restrictMultipleAccounts: true,
            integrationId: _tag === "coinbase" ? coinbaseIntegrationId : metamaskIntegrationId,
            // TODO: why is this not represented in the OpenAPI spec?
            ...{
              enableTransfers: false,
            } as {},
          }).pipe(
            Effect.map(({ content }) => content?.linkToken),
            Effect.flatMap(Effect.fromNullable),
            Effect.orDie,
          )
        }),
      )
      .handle(
        "saveCoinbaseTokens",
        Effect.fn(function*({ payload }) {
          console.log({ saveCoinbaseTokens: payload })
          const clerkId = yield* CurrentUserId
          if (typeof clerkId === "undefined") {
            return yield* new HttpApiError.Unauthorized()
          }
          yield* db.setCoinbaseAccessTokens(clerkId, payload)
        }),
      )
      .handle(
        "saveMetamaskToken",
        Effect.fn(function*({ payload }) {
          console.log({ saveMetamaskToken: payload })
          const clerkId = yield* CurrentUserId
          if (typeof clerkId === "undefined") {
            return yield* new HttpApiError.Unauthorized()
          }
          yield* db.setMetamaskAccessToken(clerkId, payload)
        }),
      )
      .handle(
        "getBalances",
        Effect.fn(function*({ payload: {} }) {
          const tokens = yield* Effect.all({
            coinbase: coinbaseAccessToken,
            metamask: metamaskAccessToken,
          }).pipe(Effect.orDie)
          return yield* Effect.all({
            coinbase: mesh["POST/api/v1/holdings/get"]({
              authToken: tokens.coinbase,
              type: "coinbase",
              includeMarketValue: true,
            }).pipe(
              Effect.map(({ content }) =>
                content?.cryptocurrencyPositions?.find(({ symbol: symbol_ }) => symbol === symbol_)?.amount ?? 0
              ),
            ),
            metamask: mesh["POST/api/v1/holdings/get"]({
              authToken: tokens.metamask,
              type: "deFiWallet",
              includeMarketValue: true,
            }).pipe(
              Effect.map(({ content }) =>
                content?.cryptocurrencyPositions?.find(({ symbol: symbol_ }) => symbol === symbol_)?.amount ?? 0
              ),
            ),
          }).pipe(Effect.orDie)
        }),
      )
      .handle(
        "transferFromCoinbase",
        Effect.fn(function*({ payload: { accessToken, amount, brokerType } }) {
          yield* mesh["POST/api/v1/transfers/managed/configure"]({
            fromAuthToken: Redacted.value(accessToken),
            fromType: brokerType,
            symbol,
            amount,
            toAddresses: [
              {
                networkId: ethereumNetworkId,
                symbol,
                address: destinationAddress,
              },
            ],
            networkId: ethereumNetworkId,
          }).pipe(
            Effect.orDie,
          )
          console.log({
            fromAuthToken: Redacted.value(accessToken),
            fromType: brokerType,
            symbol,
            amount,
            networkId: ethereumNetworkId,
            toAddress: destinationAddress,
          })
          const previewId = yield* mesh["POST/api/v1/transfers/managed/preview"]({
            fromAuthToken: Redacted.value(accessToken),
            fromType: brokerType,
            symbol,
            amount,
            networkId: ethereumNetworkId,
            toAddress: destinationAddress,
          }).pipe(
            Effect.tapError((error) => {
              return Effect.logError(error)
            }),
            Effect.map(({ content }) => {
              // console.log({ content }, "\n\n\n\n\n\n\n")
              return content?.previewResult?.previewId
            }),
            Effect.flatMap(Effect.fromNullable),
            Effect.orDie,
          )
          console.log({ previewId })
          const content = yield* mesh["POST/api/v1/transfers/managed/execute"]({
            fromAuthToken: Redacted.value(accessToken),
            fromType: brokerType,
            previewId,
            tryAnotherMfa: true,
          }).pipe(
            Effect.map(({ content }) => content),
            Effect.flatMap(Effect.fromNullable),
            Effect.orDie,
          )
          if (content.status === "mfaRequired") {
            return { _tag: "mfa", previewId }
          }
          return { _tag: "success", content }
        }),
      )
      .handle(
        "transferFromCoinbaseMfa",
        Effect.fn(function*({ payload: { accessToken, brokerType, mfaCode, previewId } }) {
          return yield* mesh["POST/api/v1/transfers/managed/execute"]({
            fromAuthToken: Redacted.value(accessToken),
            fromType: brokerType,
            previewId,
            tryAnotherMfa: false,
            mfaCode,
          }).pipe(
            Effect.map(({ content }) => content),
            Effect.flatMap(Effect.fromNullable),
            Effect.orDie,
          )
        }),
      )
  }),
)
</file>

<file path="server/CurrentUserId.ts">
import { ClerkId } from "@1b1/domain"
import { verifyToken } from "@clerk/backend"
import * as HttpApiError from "@effect/platform/HttpApiError"
import * as HttpServerRequest from "@effect/platform/HttpServerRequest"
import * as Effect from "effect/Effect"
import * as Redacted from "effect/Redacted"
import * as Schema from "effect/Schema"
import { ConfigService } from "./ConfigService"

export const CurrentUserId = Effect.gen(function*() {
  const { clerkSecret } = yield* ConfigService
  const { cookies } = yield* HttpServerRequest.HttpServerRequest
  const jwt = Schema.decodeUnknownSync(
    Schema.Struct({
      __session: Schema.String.pipe(Schema.optional),
    }),
  )(cookies).__session
  if (typeof jwt === "undefined") {
    return undefined
  }
  const { sub } = yield* Effect.tryPromise({
    try: () =>
      verifyToken(jwt, {
        authorizedParties: ["http://localhost:5173"],
        secretKey: Redacted.value(clerkSecret),
      }),
    catch: () => new HttpApiError.Unauthorized(),
  })
  return ClerkId(sub)
})

// import { ApiError, Authorization, ClerkId } from "@1b1/domain"
// import { verifyToken } from "@clerk/backend"
// import { Unauthorized } from "@effect/platform/HttpApiError"
// import * as Effect from "effect/Effect"
// import * as Layer from "effect/Layer"
// import * as Redacted from "effect/Redacted"
// import { ConfigService } from "./ConfigService"

// export const AuthorizationLive = Layer.effect(
//   Authorization,
//   Effect.gen(function*() {
//     const { clerkSecret } = yield* ConfigService
//     return {
//       session: (session) =>
//         Effect.gen(function*() {
//           const { sub } = yield* Effect.tryPromise({
//             try: () =>
//               verifyToken(Redacted.value(session), {
//                 authorizedParties: ["http://localhost:5173"],
//                 secretKey: Redacted.value(clerkSecret),
//               }),
//             catch: () => new Unauthorized(),
//           })
//           return {
//             clerkId: ClerkId(sub),
//           }
//         }),
//     }
//   }),
// )
</file>

<file path="server/Db.ts">
import type { ClerkId } from "@1b1/domain"
import * as Context from "effect/Context"
import * as Effect from "effect/Effect"

export class Db extends Context.Tag("Db")<Db, {
  setCoinbaseAccessTokens: (
    clerkId: ClerkId,
    accessTokens: {
      accessToken: string
      refreshToken: string
    },
  ) => Effect.Effect<void>
  getCoinbaseAccessTokens: (clerkId: ClerkId) => Effect.Effect<
    {
      accessToken: string
      refreshToken: string
    } | undefined
  >
  setMetamaskAccessToken: (
    clerkId: ClerkId,
    payload: {
      accessToken: string
    },
  ) => Effect.Effect<void>
  getMetamaskAccessToken: (clerkId: ClerkId) => Effect.Effect<string | undefined>
}>() {}
</file>

<file path="server/MemoryDb.ts">
import type { ClerkId } from "@1b1/domain"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import { Db } from "./Db.ts"

type UsersLookup = Record<ClerkId, {
  coinbaseAccessTokens?: {
    accessToken: string
    refreshToken: string
  }
  metamaskAccessToken?: string
}>

export const MemoryDb = Layer.effect(
  Db,
  Effect.gen(function*() {
    const users: UsersLookup = {}
    return {
      setCoinbaseAccessTokens: Effect.fn(function*(
        clerkId: ClerkId,
        accessTokens: {
          accessToken: string
          refreshToken: string
        },
      ) {
        let user = users[clerkId]
        if (!user) {
          user = {}
          users[clerkId] = user
        }
        user.coinbaseAccessTokens = accessTokens
      }),
      getCoinbaseAccessTokens: Effect.fn(function*(clerkId: ClerkId) {
        return users[clerkId]?.coinbaseAccessTokens
      }),
      setMetamaskAccessToken: Effect.fn(function*(clerkId: ClerkId, { accessToken }: {
        accessToken: string
      }) {
        let user = users[clerkId]
        if (!user) {
          user = {}
          users[clerkId] = user
        }
        user.metamaskAccessToken = accessToken
      }),
      getMetamaskAccessToken: Effect.fn(function*(clerkId: ClerkId) {
        return users[clerkId]?.metamaskAccessToken
      }),
    }
  }),
)
</file>

<file path="server/tokens.ts">
import * as MeshClient from "@1b1/experimental_client/MeshClient"
import * as Effect from "effect/Effect"
import * as Schema from "effect/Schema"
import { CurrentUserId } from "./CurrentUserId.ts"
import { Db } from "./Db.ts"

const decodeTokens = Schema.decodeUnknownSync(
  Schema.Struct({
    accessToken: Schema.String,
    refreshToken: Schema.String,
  }),
)

export const coinbaseAccessToken = Effect.gen(function*() {
  const clerkId = yield* CurrentUserId.pipe(
    Effect.flatMap(Effect.fromNullable),
  )
  const mesh = yield* MeshClient.MeshClient
  const db = yield* Db
  const tokens = yield* db.getCoinbaseAccessTokens(clerkId).pipe(
    Effect.flatMap(Effect.fromNullable),
  )
  const refreshed = yield* mesh["POST/api/v1/token/refresh"]({
    type: "coinbase",
    ...tokens,
  }).pipe(Effect.map(decodeTokens))
  yield* db.setCoinbaseAccessTokens(clerkId, tokens)
  return refreshed.accessToken
})

export const metamaskAccessToken = Effect.gen(function*() {
  const db = yield* Db
  const clerkId = yield* CurrentUserId.pipe(
    Effect.flatMap(Effect.fromNullable),
  )
  return yield* db.getMetamaskAccessToken(clerkId).pipe(
    Effect.flatMap(Effect.fromNullable),
  )
})
</file>

<file path="app/components/ui/button.tsx">
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import * as React from "react"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}:
  & React.ComponentProps<"button">
  & VariantProps<typeof buttonVariants>
  & {
    asChild?: boolean
  })
{
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props as any}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="app/lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="app/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="app/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="app/global.css">
@import "tailwindcss";

@plugin "tailwindcss-animate";

@custom-variant dark (&:is(.dark *));

html, body {
  height: 100%;
  font-family: "Inconsolata", mono;
}

:root {
  --background: hsl(0 0% 100%);
  --foreground: hsl(222.2 84% 4.9%);
  --card: hsl(0 0% 100%);
  --card-foreground: hsl(222.2 84% 4.9%);
  --popover: hsl(0 0% 100%);
  --popover-foreground: hsl(222.2 84% 4.9%);
  --primary: hsl(222.2 47.4% 11.2%);
  --primary-foreground: hsl(210 40% 98%);
  --secondary: hsl(210 40% 96.1%);
  --secondary-foreground: hsl(222.2 47.4% 11.2%);
  --muted: hsl(210 40% 96.1%);
  --muted-foreground: hsl(215.4 16.3% 46.9%);
  --accent: hsl(210 40% 96.1%);
  --accent-foreground: hsl(222.2 47.4% 11.2%);
  --destructive: hsl(0 84.2% 60.2%);
  --destructive-foreground: hsl(210 40% 98%);
  --border: hsl(214.3 31.8% 91.4%);
  --input: hsl(214.3 31.8% 91.4%);
  --ring: hsl(222.2 84% 4.9%);
  --chart-1: hsl(12 76% 61%);
  --chart-2: hsl(173 58% 39%);
  --chart-3: hsl(197 37% 24%);
  --chart-4: hsl(43 74% 66%);
  --chart-5: hsl(27 87% 67%);
  --radius: 0.6rem;
  --sidebar: hsl(0 0% 100%);
  --sidebar-foreground: hsl(240 5.3% 26.1%);
  --sidebar-primary: hsl(240 5.9% 10%);
  --sidebar-primary-foreground: hsl(0 0% 98%);
  --sidebar-accent: hsl(240 4.8% 95.9%);
  --sidebar-accent-foreground: hsl(240 5.9% 10%);
  --sidebar-border: hsl(220 13% 91%);
  --sidebar-ring: hsl(217.2 91.2% 59.8%);
}

.dark {
  --background: hsl(222.2 84% 4.9%);
  --foreground: hsl(210 40% 98%);
  --card: hsl(222.2 84% 4.9%);
  --card-foreground: hsl(210 40% 98%);
  --popover: hsl(222.2 84% 4.9%);
  --popover-foreground: hsl(210 40% 98%);
  --primary: hsl(210 40% 98%);
  --primary-foreground: hsl(222.2 47.4% 11.2%);
  --secondary: hsl(217.2 32.6% 17.5%);
  --secondary-foreground: hsl(210 40% 98%);
  --muted: hsl(217.2 32.6% 17.5%);
  --muted-foreground: hsl(215 20.2% 65.1%);
  --accent: hsl(217.2 32.6% 17.5%);
  --accent-foreground: hsl(210 40% 98%);
  --destructive: hsl(0 62.8% 30.6%);
  --destructive-foreground: hsl(210 40% 98%);
  --border: hsl(217.2 32.6% 17.5%);
  --input: hsl(217.2 32.6% 17.5%);
  --ring: hsl(212.7 26.8% 83.9%);
  --chart-1: hsl(220 70% 50%);
  --chart-2: hsl(160 60% 45%);
  --chart-3: hsl(30 80% 55%);
  --chart-4: hsl(280 65% 60%);
  --chart-5: hsl(340 75% 55%);
  --sidebar: hsl(222.2 84% 4.9%);
  --sidebar-foreground: hsl(240 4.8% 95.9%);
  --sidebar-primary: hsl(224.3 76.3% 48%);
  --sidebar-primary-foreground: hsl(0 0% 100%);
  --sidebar-accent: hsl(240 3.7% 15.9%);
  --sidebar-accent-foreground: hsl(240 4.8% 95.9%);
  --sidebar-border: hsl(240 3.7% 15.9%);
  --sidebar-ring: hsl(217.2 91.2% 59.8%);
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;

  @keyframes accordion-down {
    from {
      height: 0;
    }
    to {
      height: var(--radix-accordion-content-height);
    }
  }

  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }
    to {
      height: 0;
    }
  }
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="app/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1B1</title>
  </head>
  <body>
    <div id="root" class="h-svh"></div>
    <script type="module" src="/main.tsx"></script>
  </body>
</html>
</file>

<file path="app/tsconfig.json">
{
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "baseUrl": ".",
    "jsx": "react-jsx",
    "paths": {
      "@/*": ["./*"]
    },
    "target": "ES2020"
  },
  "include": ["."],
  "exclude": ["node_modules"],
  "references": [{ "path": "../domain" }]
}
</file>

<file path="app/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="app/vite.config.ts">
import tailwindcss from "@tailwindcss/vite"
import react from "@vitejs/plugin-react-swc"
import { defineConfig } from "vite"
import tsconfigPaths from "vite-tsconfig-paths"

export default defineConfig({
  plugins: [react(), tailwindcss(), tsconfigPaths()],
  envDir: "..",
  server: {
    proxy: {
      "/v1": {
        target: "http://localhost:3000",
        changeOrigin: false,
        secure: false,
      },
    },
  },
})
</file>

<file path="domain/Api.ts">
import { BrokerType, ExecuteTransferResponse } from "@1b1/experimental_client/Generated"
import * as HttpApi from "@effect/platform/HttpApi"
import * as HttpApiEndpoint from "@effect/platform/HttpApiEndpoint"
import * as HttpApiError from "@effect/platform/HttpApiError"
import * as HttpApiGroup from "@effect/platform/HttpApiGroup"
import * as Schema from "effect/Schema"
import { ApiError } from "./common.ts"

export class Api extends HttpApi.make("api").add(
  HttpApiGroup
    .make("v1")
    .add(
      HttpApiEndpoint
        .post("getBalances")`/get_balances`
        .addSuccess(Schema.Struct({
          coinbase: Schema.Number,
          metamask: Schema.Number,
        })),
    )
    .add(
      HttpApiEndpoint
        .post("saveCoinbaseTokens")`/save_coinbase_tokens`
        .setPayload(Schema.Struct({
          accessToken: Schema.String,
          refreshToken: Schema.String,
        })),
    )
    .add(
      HttpApiEndpoint
        .post("saveMetamaskToken")`/save_metamask_token`
        .setPayload(Schema.Struct({
          accessToken: Schema.String,
        })),
    )
    .add(
      HttpApiEndpoint
        .post("transferFromCoinbase")`/transfer_from_coinbase`
        .setPayload(Schema.Struct({
          accessToken: Schema.Redacted(Schema.String),
          brokerType: BrokerType,
          amount: Schema.Number,
        }))
        .addSuccess(Schema.Union(
          Schema.TaggedStruct("mfa", {
            previewId: Schema.String,
          }),
          Schema.TaggedStruct("success", {
            content: ExecuteTransferResponse,
          }),
        )),
    )
    .add(
      HttpApiEndpoint
        .post("transferFromCoinbaseMfa")`/transfer_from_coinbase_mfa`
        .setPayload(Schema.Struct({
          accessToken: Schema.Redacted(Schema.String),
          brokerType: BrokerType,
          previewId: Schema.String,
          mfaCode: Schema.String,
        }))
        .addSuccess(ExecuteTransferResponse),
    )
    .add(
      HttpApiEndpoint
        .post("createLinkToken")`/create_link_token`
        .setPayload(Schema.Union(
          Schema.TaggedStruct("metamask", {}),
          Schema.TaggedStruct("coinbase", {}),
        ))
        .addSuccess(Schema.String),
    )
    .prefix("/v1")
    .addError(HttpApiError.Unauthorized)
    .addError(ApiError),
) {}
</file>

<file path="domain/common.ts">
// import { Unauthorized } from "@effect/platform/HttpApiError"
// import * as HttpApiMiddleware from "@effect/platform/HttpApiMiddleware"
// import * as HttpApiSecurity from "@effect/platform/HttpApiSecurity"
import * as Brand from "effect/Brand"
import * as Context from "effect/Context"
import * as Schema from "effect/Schema"

export type ClerkId = string & Brand.Brand<"ClerkId">
export const ClerkId = Brand.nominal<ClerkId>()

export class AccessTokenDetails extends Schema.Class<AccessTokenDetails>("TokenDetails")({
  accessToken: Schema.String,
  refreshToken: Schema.String,
}) {}

export class ApiError extends Schema.TaggedError<ApiError>("ApiError")("ApiError", {
  inner: Schema.Unknown.pipe(Schema.optional),
}) {}

// export class CurrentUser extends Context.Tag("CurrentUser")<CurrentUser, {
//   clerkId: ClerkId
// }>() {}

// export class Authorization extends HttpApiMiddleware.Tag<Authorization>()(
//   "Authorization",
//   {
//     provides: CurrentUser,
//     failure: Unauthorized,
//     security: {
//       session: HttpApiSecurity.apiKey({
//         in: "cookie",
//         key: "__session",
//       }),
//     },
//   },
// ) {}
</file>

<file path="experimental_client/Generated.ts">
import type * as HttpClient from "@effect/platform/HttpClient"
import * as HttpClientError from "@effect/platform/HttpClientError"
import * as HttpClientRequest from "@effect/platform/HttpClientRequest"
import * as HttpClientResponse from "@effect/platform/HttpClientResponse"
import * as Data from "effect/Data"
import * as Effect from "effect/Effect"
import type { ParseError } from "effect/ParseResult"
import * as S from "effect/Schema"

export class B2BBrokerAccountDetailsRequest extends S.Class<B2BBrokerAccountDetailsRequest>("B2BBrokerAccountDetailsRequest")({
  /**
* Auth token that allows connecting to the target institution.
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* The Id which uniquely identifies the integration.
*/
"integrationId": S.String
}) {}

export class ApiResultStatus extends S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons") {}

export class UserIdentificationType extends S.Literal("none", "idCard", "driversLicense", "passport") {}

export class B2BBrokerAccountDetailsResponse extends S.Class<B2BBrokerAccountDetailsResponse>("B2BBrokerAccountDetailsResponse")({
  "integrationName": S.optionalWith(S.String, { nullable: true }),
  "firstName": S.optionalWith(S.String, { nullable: true }),
  "middleName": S.optionalWith(S.String, { nullable: true }),
  "lastName": S.optionalWith(S.String, { nullable: true }),
  "accountNumber": S.optionalWith(S.String, { nullable: true }),
  "email": S.optionalWith(S.String, { nullable: true }),
  "mobileNumber": S.optionalWith(S.String, { nullable: true }),
  "companyName": S.optionalWith(S.String, { nullable: true }),
  "countryCode": S.optionalWith(S.String, { nullable: true }),
  "city": S.optionalWith(S.String, { nullable: true }),
  "postalCode": S.optionalWith(S.String, { nullable: true }),
  "address": S.optionalWith(S.String, { nullable: true }),
  "idType": S.optionalWith(UserIdentificationType, { nullable: true }),
  "idNumber": S.optionalWith(S.String, { nullable: true }),
  "dateOfBirth": S.optionalWith(S.Int, { nullable: true })
}) {}

export class B2BBrokerAccountDetailsResponseApiResult extends S.Class<B2BBrokerAccountDetailsResponseApiResult>("B2BBrokerAccountDetailsResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerAccountDetailsResponse, { nullable: true })
}) {}

export class ApiResult extends S.Class<ApiResult>("ApiResult")({
  "status": S.optionalWith(ApiResultStatus, { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true })
}) {}

export class ApiV1AccountVerify401 extends S.Struct({
  
}) {}

export class ApiV1AccountVerify403 extends S.Struct({
  
}) {}

export class AccountInfoType extends S.Literal("firstName", "middleName", "lastName", "accountNumber", "email", "mobileNumber", "companyName", "countryCode", "city", "postalCode", "address", "id", "dateOfBirth") {}

/**
* Exchange account info request.
*/
export class ExchangeAccountInfoRequest extends S.Class<ExchangeAccountInfoRequest>("ExchangeAccountInfoRequest")({
  /**
* Auth token that allows connecting to the target institution.
*/
"authToken": S.optionalWith(S.String, { nullable: true }),
  /**
* The Id which uniquely identifies the integration.
*/
"integrationId": S.optionalWith(S.String, { nullable: true }),
  /**
* Account information to return.
*/
"accountInfo": S.optionalWith(S.Array(AccountInfoType), { nullable: true })
}) {}

export class ApiV1ExchangeVerify401 extends S.Struct({
  
}) {}

export class ApiV1ExchangeVerify403 extends S.Struct({
  
}) {}

export class ApiV1AssetsAssetTypeParams extends S.Struct({
  "Search": S.optionalWith(S.String, { nullable: true }),
  "Count": S.optionalWith(S.Int, { nullable: true }),
  "Offset": S.optionalWith(S.Int, { nullable: true })
}) {}

export class AssetType extends S.Literal("equity", "cryptocurrency") {}

export class Asset extends S.Class<Asset>("Asset")({
  "symbol": S.optionalWith(S.String, { nullable: true }),
  "name": S.optionalWith(S.String, { nullable: true }),
  "type": S.optionalWith(AssetType, { nullable: true })
}) {}

export class AssetPaginationResponse extends S.Class<AssetPaginationResponse>("AssetPaginationResponse")({
  /**
* list of items
*/
"items": S.optionalWith(S.Array(Asset), { nullable: true }),
  /**
* Total number of items
*/
"total": S.optionalWith(S.Int, { nullable: true })
}) {}

export class AssetPaginationResponseApiResult extends S.Class<AssetPaginationResponseApiResult>("AssetPaginationResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(AssetPaginationResponse, { nullable: true })
}) {}

export class ApiV1AssetsAssetType401 extends S.Struct({
  
}) {}

export class BrokerType extends S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile") {}

export class BalanceBrokerBaseRequest extends S.Class<BalanceBrokerBaseRequest>("BalanceBrokerBaseRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```CexIo```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```BitFlyer```
* ```Coinlist```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```BitfinexDirect```
* ```Bybit```
* ```Paxos```
* ```CoinbasePrime```
* ```BtcTurkDirect```
* ```KuCoinDirect```
* ```OkxOAuth```
* ```ParibuDirect```
* ```RobinhoodConnect```
* ```BlockchainCom```
* ```BitsoDirect```
* ```BybitDirect```
* ```ParibuOAuth```
* ```BinanceTrDirect```
* ```BybitDirectMobile```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile")
}) {}

export class B2BBrokerAccountBalance extends S.Class<B2BBrokerAccountBalance>("B2BBrokerAccountBalance")({
  /**
* Withdrawable cash amount on the account.
*/
"cash": S.optionalWith(S.Number, { nullable: true }),
  /**
* Buying power indicating the maximum amount the user can spend to buy assets. E.g. available margin.
*/
"buyingPower": S.optionalWith(S.Number, { nullable: true }),
  /**
* Buying power available for placing cryptocurrency orders.
*/
"cryptocurrencyBuyingPower": S.optionalWith(S.Number, { nullable: true }),
  /**
* ISO 4217 currency code.
*/
"currencyCode": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerAccountBalanceModel extends S.Class<B2BBrokerAccountBalanceModel>("B2BBrokerAccountBalanceModel")({
  "balances": S.optionalWith(S.Array(B2BBrokerAccountBalance), { nullable: true }),
  /**
* Total USD value of all currencies
*/
"totalCashUsdValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total USD value of all Buying Power
*/
"totalBuyingPowerUsdValue": S.optionalWith(S.Number, { nullable: true })
}) {}

export class B2BBrokerAccountBalanceModelApiResult extends S.Class<B2BBrokerAccountBalanceModelApiResult>("B2BBrokerAccountBalanceModelApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerAccountBalanceModel, { nullable: true })
}) {}

export class ApiV1BalanceGet401 extends S.Struct({
  
}) {}

export class ApiV1BalanceGet403 extends S.Struct({
  
}) {}

export class ApiV1BalancePortfolioParams extends S.Struct({
  "UserId": S.optionalWith(S.String, { nullable: true })
}) {}

export class PortfolioFiatBalance extends S.Class<PortfolioFiatBalance>("PortfolioFiatBalance")({
  /**
* Balance currency
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Amount of money in a specific currency from all brokers
*/
"cash": S.optionalWith(S.Number, { nullable: true }),
  /**
* BuyingPower from all brokers, it indicates total amount of money the user can spend on buying stock.
* Always includes cash and can also include margin
*/
"buyingPower": S.optionalWith(S.Number, { nullable: true })
}) {}

export class B2BFiatPortfolioModel extends S.Class<B2BFiatPortfolioModel>("B2BFiatPortfolioModel")({
  /**
* List of aggregated fiat balances
*/
"fiatBalances": S.optionalWith(S.Array(PortfolioFiatBalance), { nullable: true })
}) {}

export class B2BFiatPortfolioModelApiResult extends S.Class<B2BFiatPortfolioModelApiResult>("B2BFiatPortfolioModelApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BFiatPortfolioModel, { nullable: true })
}) {}

export class ApiV1BalancePortfolio401 extends S.Struct({
  
}) {}

export class ApiV1BalancePortfolio403 extends S.Struct({
  
}) {}

export class ApiV1CataloglinkParams extends S.Struct({
  "UserId": S.String.pipe(S.maxLength(50)),
  "BrokerType": S.optionalWith(BrokerType, { nullable: true }),
  "EnableTransfers": S.optionalWith(S.Boolean, { nullable: true }),
  "RestrictMultipleAccounts": S.optionalWith(S.Boolean, { nullable: true }),
  "DisableApiKeyGeneration": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class CatalogLink extends S.Class<CatalogLink>("CatalogLink")({
  /**
* Url to open Front catalog that should be presented to the end user.
*/
"url": S.optionalWith(S.String, { nullable: true }),
  /**
* Url to open Front catalog in iFrame that should be presented to the end user.
*/
"iFrameUrl": S.optionalWith(S.String, { nullable: true })
}) {}

export class CatalogLinkApiResult extends S.Class<CatalogLinkApiResult>("CatalogLinkApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(CatalogLink, { nullable: true })
}) {}

export class ApiV1Cataloglink401 extends S.Struct({
  
}) {}

export class TransferToAddressWithAmount extends S.Class<TransferToAddressWithAmount>("TransferToAddressWithAmount")({
  /**
* The Id of the network in Front system. The list of all available networks can be obtained by
* using `GET /transfers/managed/networks` endpoint.
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* The symbol of the digital asset.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* The address to send the asset to.
*/
"address": S.optionalWith(S.String, { nullable: true }),
  /**
* Secondary address identifier for coins like XRP,XMR etc.
*/
"addressTag": S.optionalWith(S.String, { nullable: true }),
  /**
* Amount of tokens to transfer by specified network.
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transfer amount in fiat which is requested by client to be shown as amount in fiat.
* It will be shown to end-user if and only if it's difference with actual amount in fiat is less that 1%.
*/
"displayAmountInFiat": S.optionalWith(S.Number, { nullable: true })
}) {}

export class TransferTypeEnum extends S.Literal("deposit", "payment", "onramp") {}

export class GoodsDetails extends S.Class<GoodsDetails>("GoodsDetails")({
  /**
* The type of the goods for the order (01: Tangible Goods, 02: Virtual Goods).
*/
"goodsType": S.optionalWith(S.String, { nullable: true }),
  /**
* The category of goods (e.g., Electronics, Food).
*/
"goodsCategory": S.optionalWith(S.String, { nullable: true }),
  /**
* A unique reference ID to identify the goods.
*/
"referenceGoodsId": S.optionalWith(S.String, { nullable: true }),
  /**
* The name of the goods.
*/
"goodsName": S.optionalWith(S.String, { nullable: true }),
  /**
* Additional details about the goods (optional).
*/
"goodsDetail": S.optionalWith(S.String, { nullable: true })
}) {}

export class InitializeTransfersForLinkRequest extends S.Class<InitializeTransfersForLinkRequest>("InitializeTransfersForLinkRequest")({
  /**
* The list of destination addresses with corresponding networks are asset symbols that
* can be used to initiate incoming transfers.
*/
"toAddresses": S.optionalWith(S.Array(TransferToAddressWithAmount), { nullable: true }),
  /**
* Amount in USD to transfer. If not provided users can specify amount by themselves.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transaction ID Provided by client to track transaction in future calls
*/
"transactionId": S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
  /**
* A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments to your company.
* This will override any default fee entered in your Mesh dashboard for an individual transaction.
* Please note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),
* and not for Deposits (when the transfer destination is an address owned by the end user).
* If used for Deposits, it will increase the size of the user's Deposit by the fee amount,
* but will incorrectly show to the user as a fee.
*/
"clientFee": S.optionalWith(S.Number.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(1)), { nullable: true }),
  /**
* Deposit (default): The user is transferring crypto to a wallet they own on your platform.
* Payment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.
* Onramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.
*/
"transferType": S.optionalWith(TransferTypeEnum, { nullable: true }),
  /**
* Transaction description. (Binance Pay)
*/
"description": S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(256)), { nullable: true }),
  /**
* Goods details for the transaction. (Binance Pay)
*/
"goodsDetails": S.optionalWith(S.Array(GoodsDetails), { nullable: true })
}) {}

export class TransferCryptocurrencyFundingOptions extends S.Class<TransferCryptocurrencyFundingOptions>("TransferCryptocurrencyFundingOptions")({
  /**
* Indicates whether the Link is permitted to use the end user's available buying power
* and/or payment methods to supplement the cryptocurrency balance if it is insufficient
* for the transfer.
*/
"enabled": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class LinkTokenTransferOptions extends S.Class<LinkTokenTransferOptions>("LinkTokenTransferOptions")({
  /**
* The list of destination addresses with corresponding networks are asset symbols that
* can be used to initiate incoming transfers. If this parameter is present, the Link
* session will continue to transfer flow after connecting the origin account.
*/
"toAddresses": S.optionalWith(S.Array(TransferToAddressWithAmount), { nullable: true }),
  /**
* Amount in USD to transfer. If not provided users can specify amount by themselves.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transaction ID Provided by client to track transaction in future calls
*/
"transactionId": S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
  /**
* A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments to your company.
* This will override any default fee entered in your Mesh dashboard for an individual transaction.
* Please note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),
* and not for Deposits (when the transfer destination is an address owned by the end user).
* If used for Deposits, it will increase the size of the user's Deposit by the fee amount,
* but will incorrectly show to the user as a fee.
*/
"clientFee": S.optionalWith(S.Number.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(1)), { nullable: true }),
  /**
* Deposit: The user is transferring crypto to a wallet they own on your platform.
* Payment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.
* Onramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.
*/
"transferType": S.optionalWith(TransferTypeEnum, { nullable: true }),
  /**
* Specifies the permitted options to use the end user's available buying power
* and/or payment methods to supplement the cryptocurrency balance if it is insufficient
* for the transfer.
*/
"fundingOptions": S.optionalWith(TransferCryptocurrencyFundingOptions, { nullable: true }),
  /**
* Specifies if all the fees are included in the amount to transfer.
*/
"isInclusiveFeeEnabled": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Transaction description. (Binance Pay)
*/
"description": S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(256)), { nullable: true }),
  /**
* Goods details for the transaction. (Binance Pay)
*/
"goodsDetails": S.optionalWith(S.Array(GoodsDetails), { nullable: true }),
  /**
* Link presents the user with the option to generate a unique payment link for Mesh pay scenarios.
* If this param is true, a unique payment link will be returned.
*/
"generatePayLink": S.optionalWith(S.Boolean, { nullable: true })
}) {}

/**
* Verification method.
*/
export class WalletVerificationMethod extends S.Literal("signedMessage") {}

export class NetworkType extends S.Literal("unknown", "evm", "solana", "bitcoin", "cardano", "tron", "avalancheX", "tezos", "dogecoin", "ripple", "stellar", "litecoin", "sui", "aptos", "tvm", "injective") {}

/**
* DeFi wallet verification options.
*/
export class VerifyWalletOptions extends S.Class<VerifyWalletOptions>("VerifyWalletOptions")({
  /**
* Verification message to sign.
* Required if `signedMessage` is provided in <paramref name="VerificationMethods">VerificationMethods</paramref> list.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* List or required verification methods. By default - sign message with wallet key.
*/
"verificationMethods": S.optionalWith(S.Array(WalletVerificationMethod), { nullable: true }),
  /**
* Addresses list to verify. If user verifies another address then verification will be failed.
*/
"addresses": S.optionalWith(S.Array(S.String), { nullable: true }),
  /**
* Network to verify. If user verifies another network address then verification will be failed.
* Checked only if Addresses is provided.
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* Network type to verify. If user verifies another network address then verification will be failed.
* Checked only if Addresses is provided.
*/
"networkType": S.optionalWith(NetworkType, { nullable: true })
}) {}

export class GetLinkTokenRequest extends S.Class<GetLinkTokenRequest>("GetLinkTokenRequest")({
  /**
* A unique Id representing the end user. Typically this will be a user Id from the
* client application. Personally identifiable information, such as an email address or phone number,
* should not be used. 300 characters length maximum.
*/
"userId": S.String.pipe(S.minLength(1), S.maxLength(300)),
  /**
* Type of integration to redirect to. Will redirect to catalog if not provided.
* Not supported types: DeFiWallet, CryptocurrencyAddress, CryptocurrencyWallet.
*/
"brokerType": S.optionalWith(BrokerType, { nullable: true }),
  /**
* The final screen of Link allows users to “continue” back to your app or “Link another account.”
* If this param is present then this button will be hidden.
*/
"restrictMultipleAccounts": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Encapsulates transaction-related parameters, including destination addresses and the amount to transfer in fiat currency.
*/
"transferOptions": S.optionalWith(LinkTokenTransferOptions, { nullable: true }),
  /**
* A unique identifier representing a specific integration obtained from the list of available integrations.
*/
"integrationId": S.optionalWith(S.String, { nullable: true }),
  /**
* For direct integrations that also support API keys, Link presents the user with the option to generate an API key for seamless access.
* If this param is true, this feature will be disabled.
*/
"disableApiKeyGeneration": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Encapsulates verify DeFi wallet parameters.
*/
"verifyWalletOptions": S.optionalWith(VerifyWalletOptions, { nullable: true }),
  /**
* Sub Client ID, for B2B2B clients to tailor Link experience for their clients.
*/
"subClientId": S.optionalWith(S.String, { nullable: true })
}) {}

export class LinkTokenModel extends S.Class<LinkTokenModel>("LinkTokenModel")({
  "linkToken": S.optionalWith(S.String, { nullable: true }),
  "paymentLink": S.optionalWith(S.String, { nullable: true })
}) {}

export class LinkTokenModelApiResult extends S.Class<LinkTokenModelApiResult>("LinkTokenModelApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(LinkTokenModel, { nullable: true })
}) {}

export class ApiV1Linktoken401 extends S.Struct({
  
}) {}

export class BrokerRefreshTokenRequest extends S.Class<BrokerRefreshTokenRequest>("BrokerRefreshTokenRequest")({
  "type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  "refreshToken": S.String.pipe(S.minLength(1)),
  /**
* Optional, used when we the refresh token should be refreshed.
* Currently this flow is supported by TD Ameritrade
*/
"createNewRefreshToken": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Some institutions may require accessToken to be provided as well.
* It's currently required by WeBull and Vanguard
*/
"accessToken": S.optionalWith(S.String, { nullable: true }),
  /**
* Currently used to update WeBull trade token.
*/
"tradeToken": S.optionalWith(S.String, { nullable: true }),
  /**
* Optional, currently used by Vanguard if account has enforced MFA enabled.
*/
"mfaCode": S.optionalWith(S.String, { nullable: true }),
  /**
* Additional metadata
*/
"metadata": S.optionalWith(S.Record({ key: S.String, value: S.Unknown }), { nullable: true })
}) {}

export class B2BBrokerAuthStatus extends S.Literal("failed", "succeeded", "mfaRequired") {}

export class BrokerFiatBalance extends S.Class<BrokerFiatBalance>("BrokerFiatBalance")({
  /**
* Account balance currency
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* BuyingPower indicates total amount of money the user can spend for buying stock. Always includes cash and
* can also include margin
*/
"buyingPower": S.optionalWith(S.Number, { nullable: true }),
  /**
* BuyingPower indicates total amount of money the user can spend for buying crypto.
*/
"cryptoBuyingPower": S.optionalWith(S.Number, { nullable: true }),
  /**
* Account cash indicates total amount of money
*/
"cash": S.optionalWith(S.Number, { nullable: true })
}) {}

export class BrokerAccount extends S.Class<BrokerAccount>("BrokerAccount")({
  "meshAccountId": S.optionalWith(S.String, { nullable: true }),
  "frontAccountId": S.optionalWith(S.String, { nullable: true }),
  "accountId": S.optionalWith(S.String, { nullable: true }),
  "accountName": S.optionalWith(S.String, { nullable: true }),
  /**
* Buying power of the account. Typically consists of cash plus available margin.
* For non-margin accounts fund contains cash only
*/
"fund": S.optionalWith(S.Number, { nullable: true }),
  /**
* Cash balance in USD
*/
"cash": S.optionalWith(S.Number, { nullable: true }),
  /**
* Indicates if this account was already connected by the current user and device.
* Can be null.
*/
"isReconnected": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The list of all asset balances of account
*/
"balances": S.optionalWith(S.Array(BrokerFiatBalance), { nullable: true })
}) {}

export class BrokerAccountTokens extends S.Class<BrokerAccountTokens>("BrokerAccountTokens")({
  "account": S.optionalWith(BrokerAccount, { nullable: true }),
  "accessToken": S.optionalWith(S.String, { nullable: true }),
  "refreshToken": S.optionalWith(S.String, { nullable: true }),
  /**
* Token identifier provided by Mesh when the actual integration's token is managed by Mesh's Token Management System.
*/
"tokenId": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerRefreshTokenResponse extends S.Class<B2BBrokerRefreshTokenResponse>("B2BBrokerRefreshTokenResponse")({
  "status": S.optionalWith(S.Literal("failed", "succeeded", "mfaRequired"), { nullable: true }),
  "errorMessage": S.optionalWith(S.String, { nullable: true }),
  "account": S.optionalWith(BrokerAccount, { nullable: true }),
  "accessToken": S.optionalWith(S.String, { nullable: true }),
  "refreshToken": S.optionalWith(S.String, { nullable: true }),
  "expiresInSeconds": S.optionalWith(S.Int, { nullable: true }),
  "refreshTokenExpiresInSeconds": S.optionalWith(S.Int, { nullable: true }),
  "brokerAccountTokens": S.optionalWith(S.Array(BrokerAccountTokens), { nullable: true })
}) {}

export class B2BBrokerRefreshTokenResponseApiResult extends S.Class<B2BBrokerRefreshTokenResponseApiResult>("B2BBrokerRefreshTokenResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerRefreshTokenResponse, { nullable: true })
}) {}

export class ApiV1TokenRefresh401 extends S.Struct({
  
}) {}

export class BrokerBaseRequest extends S.Class<BrokerBaseRequest>("BrokerBaseRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile")
}) {}

export class ApiV1Account401 extends S.Struct({
  
}) {}

export class BrokerFeature extends S.Literal("holdings", "balance", "orders", "transfers", "identity", "cryptocurrencyDepositAddresses", "accountNumber", "paymentMethods", "conversions") {}

export class DeFiWalletHealthStatusInfo extends S.Class<DeFiWalletHealthStatusInfo>("DeFiWalletHealthStatusInfo")({
  "id": S.String,
  "name": S.NullOr(S.String)
}) {}

export class B2BBrokersHealthStatus extends S.Class<B2BBrokersHealthStatus>("B2BBrokersHealthStatus")({
  /**
* Type of the integration
*/
"type": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* Name of the integration
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Is the communication with the integration up
*/
"isUp": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Description of the outage
*/
"description": S.optionalWith(S.String, { nullable: true }),
  /**
* Unix timestamp in seconds indicating when the outage occurred
*/
"downTimeStart": S.optionalWith(S.Int, { nullable: true }),
  /**
* Unix timestamp in seconds indicating expected end of the outage
*/
"downTimeEnd": S.optionalWith(S.Int, { nullable: true }),
  /**
* Get products supported by the financial institution
*/
"supportedProducts": S.optionalWith(S.Array(BrokerFeature), { nullable: true }),
  /**
* Short information about DeFiWallet
*/
"deFiWalletData": S.NullOr(DeFiWalletHealthStatusInfo)
}) {}

export class B2BBrokersHealthStatusListApiResult extends S.Class<B2BBrokersHealthStatusListApiResult>("B2BBrokersHealthStatusListApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(S.Array(B2BBrokersHealthStatus), { nullable: true })
}) {}

export class ApiV1Status401 extends S.Struct({
  
}) {}

export class AuthenticationSchemeType extends S.Literal("usernamePassword", "oAuth", "apiKey", "blockchainAddress", "trueAuth") {}

export class BrokerAuthStatus extends S.Literal("failed", "challengeFailed", "succeeded", "challengeIssued", "mfaRequired", "openInBrokerModule", "delayed", "deviceConfirmationRequired", "emailVerification", "emailReceived", "captchaChallenge", "faceVerification", "bindMfaRequired", "apiKeyGenerationError", "qrCodeRequired", "qrCodeExpired", "deviceLoginVerified") {}

export class MfaType extends S.Literal("phone", "email", "totp", "phoneAndEmail", "requireNextSecurityQuestion", "readEmail", "face", "tradingPin", "qrCode", "password", "roaming", "mobile") {}

export class AuthFlowStep extends S.Literal("loginPassword", "mfaFlow", "faceVerification", "createAPIKey", "loginQrCode") {}

export class B2BBrokerAuthResponse extends S.Class<B2BBrokerAuthResponse>("B2BBrokerAuthResponse")({
  /**
* Status of the request
*/
"status": S.optionalWith(S.Literal("failed", "challengeFailed", "succeeded", "challengeIssued", "mfaRequired", "openInBrokerModule", "delayed", "deviceConfirmationRequired", "emailVerification", "emailReceived", "captchaChallenge", "faceVerification", "bindMfaRequired", "apiKeyGenerationError", "qrCodeRequired", "qrCodeExpired", "deviceLoginVerified"), { nullable: true }),
  "mfaType": S.optionalWith(MfaType, { nullable: true }),
  /**
* The AuthFlowStep is used to determine which state the authentication is in, for initial requests without MFA verification the value should be LoginPassword and when calling with MFA code it should be MfaFlow (currently used for BinanceInternationalDirect only).
*/
"authFlowStep": S.optionalWith(AuthFlowStep, { nullable: true }),
  /**
* Qr code used to scan and solve facial verification (currently used for BinanceInternationalDirect only).
*/
"qrCode": S.optionalWith(S.String, { nullable: true }),
  "qrCodeLink": S.optionalWith(S.String, { nullable: true }),
  "qrCodeLinkIOS": S.optionalWith(S.String, { nullable: true }),
  /**
* Id of the challenge, relevant when the status is `ChallengeIssued`
*/
"challengeId": S.optionalWith(S.String, { nullable: true }),
  "challengeText": S.optionalWith(S.String, { nullable: true }),
  /**
* Life span of the challenge
*/
"challengeExpiresInSeconds": S.optionalWith(S.Int, { nullable: true }),
  "errorMessage": S.optionalWith(S.String, { nullable: true }),
  "accessToken": S.optionalWith(S.String, { nullable: true }),
  "refreshToken": S.optionalWith(S.String, { nullable: true }),
  "expiresInSeconds": S.optionalWith(S.Int, { nullable: true }),
  "refreshTokenExpiresInSeconds": S.optionalWith(S.Int, { nullable: true }),
  "account": S.optionalWith(BrokerAccount, { nullable: true }),
  "accountTokens": S.optionalWith(S.Array(BrokerAccountTokens), { nullable: true }),
  "requiresReauthentication": S.optionalWith(S.Boolean, { nullable: true }),
  "email": S.optionalWith(S.String, { nullable: true }),
  "allocatedIPAddress": S.optionalWith(S.String, { nullable: true })
}) {}

export class AuthenticationFieldDescription extends S.Class<AuthenticationFieldDescription>("AuthenticationFieldDescription")({
  /**
* Name of the field, as expected from the API
*/
"name": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(S.String, { nullable: true })
}) {}

export class AuthenticationModel extends S.Class<AuthenticationModel>("AuthenticationModel")({
  "authResponse": S.optionalWith(B2BBrokerAuthResponse, { nullable: true }),
  /**
* Set of fields that are expected to be provided based on the status of the AuthResponse
*/
"fields": S.optionalWith(S.Array(AuthenticationFieldDescription), { nullable: true })
}) {}

export class MfaScheme extends S.Literal("mfaCode", "challenge", "deviceConfirmation", "securityQuestion") {}

export class BrokerTrueAuthAuthenticationScheme extends S.Class<BrokerTrueAuthAuthenticationScheme>("BrokerTrueAuthAuthenticationScheme")({
  /**
* The login url page to show in the webview.
*/
"loginUrl": S.NullOr(S.String),
  /**
* The login page to check against for successful login
*/
"successfulLoginUri": S.NullOr(S.String),
  /**
* The urls from where cookies are fetched.
*/
"cookieDomains": S.NullOr(S.Array(S.String)),
  /**
* The headers that are required for authentication.
*/
"requiredHeaderNames": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

export class BrokerAuthenticationScheme extends S.Class<BrokerAuthenticationScheme>("BrokerAuthenticationScheme")({
  "brokerType": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* Type of authentication for the integration.
*/
"authenticationSchemeType": S.optionalWith(S.Literal("usernamePassword", "oAuth", "apiKey", "blockchainAddress", "trueAuth"), { nullable: true }),
  /**
* Set of fields that should be provided in the initial POST `authenticate` request.
*/
"initialAuthenticationModel": S.optionalWith(AuthenticationModel, { nullable: true }),
  /**
* Set of fields that should be provided depending on the status of the response of the first POST `authenticate` request.
*/
"authenticationSteps": S.optionalWith(S.Array(AuthenticationModel), { nullable: true }),
  /**
* Supported MFA schemes, can be none or multiple.
*/
"mfaSchemes": S.optionalWith(S.Array(MfaScheme), { nullable: true }),
  /**
* Optional URL with the instructions explaining how to create a set of API key/secret for the integration, can be shown to the end user.
*/
"instructionsUrl": S.optionalWith(S.String, { nullable: true }),
  "trueAuthAuthenticaion": S.optionalWith(BrokerTrueAuthAuthenticationScheme, { nullable: true })
}) {}

export class BrokerAuthenticationSchemeIReadOnlyCollectionApiResult extends S.Class<BrokerAuthenticationSchemeIReadOnlyCollectionApiResult>("BrokerAuthenticationSchemeIReadOnlyCollectionApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(S.Array(BrokerAuthenticationScheme), { nullable: true })
}) {}

export class ApiV1AuthenticationSchemes401 extends S.Struct({
  
}) {}

export class ApiV1AuthenticateParams extends S.Struct({
  "userId": S.String.pipe(S.maxLength(50))
}) {}

export class CountryInfo extends S.Class<CountryInfo>("CountryInfo")({
  "countryCode": S.optionalWith(S.String, { nullable: true }),
  "countryNumber": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(S.String, { nullable: true })
}) {}

export class TrueAuthAuthRequest extends S.Class<TrueAuthAuthRequest>("TrueAuthAuthRequest")({
  "requestHeaders": S.NullOr(S.Record({ key: S.String, value: S.Unknown })),
  "cookies": S.NullOr(S.Array(S.Record({ key: S.String, value: S.Unknown }))),
  "userAgent": S.NullOr(S.String)
}) {}

export class B2BBrokerAuthRequest extends S.Class<B2BBrokerAuthRequest>("B2BBrokerAuthRequest")({
  "type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  "phone": S.optionalWith(S.String, { nullable: true }),
  "username": S.optionalWith(S.String, { nullable: true }),
  "password": S.optionalWith(S.String, { nullable: true }),
  "tradePin": S.optionalWith(S.String, { nullable: true }),
  "countryInfo": S.optionalWith(CountryInfo, { nullable: true }),
  "challengeId": S.optionalWith(S.String, { nullable: true }),
  "challengeCode": S.optionalWith(S.String, { nullable: true }),
  "challengeType": S.optionalWith(S.String, { nullable: true }),
  /**
* Used to provide answers to security questions
*/
"challengeAnswer": S.optionalWith(S.String, { nullable: true }),
  "mfaCode": S.optionalWith(S.String, { nullable: true }),
  "mfaType": S.optionalWith(S.Literal("phone", "email", "totp", "phoneAndEmail", "requireNextSecurityQuestion", "readEmail", "face", "tradingPin", "qrCode", "password", "roaming", "mobile"), { nullable: true }),
  "deviceInfo": S.optionalWith(S.String, { nullable: true }),
  "webData": S.optionalWith(S.String, { nullable: true }),
  "authFlowStep": S.optionalWith(AuthFlowStep, { nullable: true }),
  "key": S.optionalWith(S.String, { nullable: true }),
  "authToken": S.optionalWith(S.String, { nullable: true }),
  "redirectLink": S.optionalWith(S.String, { nullable: true }),
  "confirmationEmail": S.optionalWith(S.String, { nullable: true }),
  "trueAuthAuthRequest": S.optionalWith(TrueAuthAuthRequest, { nullable: true }),
  /**
* Indicates whether the sensitive fields in this request are encrypted.
* When set to true, the following fields should be encrypted using Base64 encoding:
* - Username
* - Password
* - Phone
* - TradePin
* - ChallengeAnswer
* - MfaCode
* - DeviceInfo
* - ConfirmationEmail
*             
* Base64 encoding is used to encode these fields into a format that can be safely transmitted and stored.
*/
"isSensitiveFieldsEncrypted": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Flag indicating that the user is attempting to switch to the next available 2FA
* method (e.g., Email, Google Authenticator) after failing to complete or canceling
* the current verification method (e.g., Roaming 2FA).
*             
* This field is primarily used for Robinhood and BinanceInternationalDirect on the DeviceConfirmationPage
* when a user clicks the "Try Another Way" button. It informs the backend to move to the next
* MFA method instead of retrying the current one.
*/
"isTryingAnotherWay": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class B2BBrokerAuthResponseApiResult extends S.Class<B2BBrokerAuthResponseApiResult>("B2BBrokerAuthResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerAuthResponse, { nullable: true })
}) {}

export class ProblemDetails extends S.Class<ProblemDetails>("ProblemDetails")({
  "type": S.optionalWith(S.String, { nullable: true }),
  "title": S.optionalWith(S.String, { nullable: true }),
  "status": S.optionalWith(S.Int, { nullable: true }),
  "detail": S.optionalWith(S.String, { nullable: true }),
  "instance": S.optionalWith(S.String, { nullable: true })
}) {}

export class ApiV1AuthenticateBrokerTypeParams extends S.Struct({
  "userId": S.String
}) {}

export class BrokerAuthPromptStatus extends S.Literal("failed", "redirect", "openInBrokerModule") {}

export class B2BBrokerAuthPromptResponse extends S.Class<B2BBrokerAuthPromptResponse>("B2BBrokerAuthPromptResponse")({
  "status": S.optionalWith(S.Literal("failed", "redirect", "openInBrokerModule"), { nullable: true }),
  "redirectLink": S.optionalWith(S.String, { nullable: true }),
  "linkToken": S.optionalWith(S.String, { nullable: true }),
  "errorMessage": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerAuthPromptResponseApiResult extends S.Class<B2BBrokerAuthPromptResponseApiResult>("B2BBrokerAuthPromptResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerAuthPromptResponse, { nullable: true })
}) {}

export class FinancialInstitutionIntegrationType extends S.Literal("brokerage", "bank", "exchange", "wallet", "address", "nftMarketplace", "deFiWallet") {}

/**
* Integration style
*/
export class IntegrationStyle extends S.Class<IntegrationStyle>("IntegrationStyle")({
  /**
* Field Active Light Hex Color
*/
"fieldActiveLight": S.optionalWith(S.String, { nullable: true }),
  /**
* Button Primary Light Hex Color
*/
"buttonPrimaryLight": S.optionalWith(S.String, { nullable: true }),
  /**
* Button Hover Light Hex Color
*/
"buttonHoverLight": S.optionalWith(S.String, { nullable: true }),
  /**
* Button Text Light Hex Color
*/
"buttonTextLight": S.optionalWith(S.String, { nullable: true }),
  /**
* Button Text Hover Light Hex Color
*/
"buttonTextHoverLight": S.optionalWith(S.String, { nullable: true }),
  /**
* Field Active Dark Hex Color
*/
"fieldActiveDark": S.optionalWith(S.String, { nullable: true }),
  /**
* Button Primary Dark Hex Color
*/
"buttonPrimaryDark": S.optionalWith(S.String, { nullable: true }),
  /**
* Button Hover Dark Hex Color
*/
"buttonHoverDark": S.optionalWith(S.String, { nullable: true }),
  /**
* Button Text Dark Hex Color
*/
"buttonTextDark": S.optionalWith(S.String, { nullable: true }),
  /**
* Button Text Hover Dark Hex Color
*/
"buttonTextHoverDark": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* Integreation logos.
*/
export class IntegrationLogo extends S.Class<IntegrationLogo>("IntegrationLogo")({
  /**
* Light logo url.
*/
"logoLightUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Dark logo url.
*/
"logoDarkUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* White logo url.
*/
"logoWhiteUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Black logo url.
*/
"logoBlackUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Colored logo url.
*/
"logoColorUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* White icon url.
*/
"iconLightUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Light icon url.
*/
"iconDarkUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Dark icon url.
*/
"iconWhiteUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Balck icon url.
*/
"iconBlackUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Colored logo url.
*/
"iconColorUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Base64 PNG logo.
*/
"base64Logo": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* Integration model.
*/
export class IntegrationModel extends S.Class<IntegrationModel>("IntegrationModel")({
  /**
* Integration unique identifier.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Integration name.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Integration type.
*/
"type": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* DeFi wallet provider identifier.
*/
"deFiWalletProviderId": S.optionalWith(S.String, { nullable: true }),
  /**
* Integration categories.
*/
"categories": S.optionalWith(S.Array(FinancialInstitutionIntegrationType), { nullable: true }),
  /**
* Style object.
*/
"style": S.optionalWith(IntegrationStyle, { nullable: true }),
  /**
* Logo object.
*/
"logo": S.optionalWith(IntegrationLogo, { nullable: true }),
  /**
* Forgot Password Link.
*/
"forgotPasswordLink": S.optionalWith(S.String, { nullable: true }),
  /**
* Indicates if crypto transfers supported by integration.
*/
"cryptoTransfersSupported": S.optionalWith(S.Boolean, { nullable: true })
}) {}

/**
* Integration response.
*/
export class IntegrationsResponse extends S.Class<IntegrationsResponse>("IntegrationsResponse")({
  /**
* Integrations list.
*/
"items": S.optionalWith(S.Array(IntegrationModel), { nullable: true })
}) {}

export class IntegrationsResponseApiResult extends S.Class<IntegrationsResponseApiResult>("IntegrationsResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  /**
* Integration response.
*/
"content": S.optionalWith(IntegrationsResponse, { nullable: true })
}) {}

export class NetworkResponseToken extends S.Class<NetworkResponseToken>("NetworkResponseToken")({
  "symbol": S.optionalWith(S.String, { nullable: true }),
  "logoUrl": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* Crypto network.
*/
export class NetworkResponseWithIntegrations extends S.Class<NetworkResponseWithIntegrations>("NetworkResponseWithIntegrations")({
  /**
* The Id of the network in Mesh system. Should be used to initiate transfers.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* The name if the network.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137.
*/
"chainId": S.optionalWith(S.String, { nullable: true }),
  /**
* Network logo URL.
*/
"logoUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* The list of tokens that are currently supported to be transferred using the network.
*/
"supportedTokens": S.optionalWith(S.Array(S.String), { nullable: true }),
  /**
* The symbol of the network's native cryptocurrency.
*/
"nativeSymbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Network type.
*/
"networkType": S.optionalWith(S.Literal("unknown", "evm", "solana", "bitcoin", "cardano", "tron", "avalancheX", "tezos", "dogecoin", "ripple", "stellar", "litecoin", "sui", "aptos", "tvm", "injective"), { nullable: true }),
  /**
* The list of tokens that are currently supported to be transferred using the network.
*/
"tokens": S.optionalWith(S.Array(NetworkResponseToken), { nullable: true }),
  /**
* The list of types of integrations that are currently supported to perform transfers over the network.
*/
"supportedBrokerTypes": S.optionalWith(S.Array(BrokerType), { nullable: true })
}) {}

export class NetworkModelResponse extends S.Class<NetworkModelResponse>("NetworkModelResponse")({
  "networks": S.optionalWith(S.Array(NetworkResponseWithIntegrations), { nullable: true })
}) {}

export class NetworkModelResponseApiResult extends S.Class<NetworkModelResponseApiResult>("NetworkModelResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(NetworkModelResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedNetworks401 extends S.Struct({
  
}) {}

export class DeviceType extends S.Literal("unknown", "android", "ios", "web") {}

export class NetworkResponseWithSupportedDevices extends S.Class<NetworkResponseWithSupportedDevices>("NetworkResponseWithSupportedDevices")({
  /**
* The Id of the network in Mesh system. Should be used to initiate transfers.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* The name if the network.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137.
*/
"chainId": S.optionalWith(S.String, { nullable: true }),
  /**
* Network logo URL.
*/
"logoUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* The list of tokens that are currently supported to be transferred using the network.
*/
"supportedTokens": S.optionalWith(S.Array(S.String), { nullable: true }),
  /**
* The symbol of the network's native cryptocurrency.
*/
"nativeSymbol": S.optionalWith(S.String, { nullable: true }),
  "supportedDevices": S.optionalWith(S.Array(DeviceType), { nullable: true })
}) {}

export class IntegrationNetworksModelResponse extends S.Class<IntegrationNetworksModelResponse>("IntegrationNetworksModelResponse")({
  /**
* Integration unique identifier.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Type of the integration.
*/
"type": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* Name of the integration.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* The list of supported networks and corresponding tokens for the integration.
*/
"networks": S.optionalWith(S.Array(NetworkResponseWithSupportedDevices), { nullable: true }),
  /**
* Specifies if the integration supports outgoing transfers.
*/
"supportsOutgoingTransfers": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Specifies if the integration supports incoming transfers.
*/
"supportsIncomingTransfers": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class IntegrationNetworkResponse extends S.Class<IntegrationNetworkResponse>("IntegrationNetworkResponse")({
  "integrations": S.optionalWith(S.Array(IntegrationNetworksModelResponse), { nullable: true })
}) {}

export class IntegrationNetworkResponseApiResult extends S.Class<IntegrationNetworkResponseApiResult>("IntegrationNetworkResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(IntegrationNetworkResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedIntegrations401 extends S.Struct({
  
}) {}

/**
* Crypto network.
*/
export class NetworkResponseBase extends S.Class<NetworkResponseBase>("NetworkResponseBase")({
  /**
* The Id of the network in Mesh system. Should be used to initiate transfers.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* The name if the network.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137.
*/
"chainId": S.optionalWith(S.String, { nullable: true }),
  /**
* Network logo URL.
*/
"logoUrl": S.optionalWith(S.String, { nullable: true })
}) {}

export class IntegrationNetwork extends S.Class<IntegrationNetwork>("IntegrationNetwork")({
  "networkId": S.optionalWith(S.String, { nullable: true }),
  "netwokName": S.optionalWith(S.String, { nullable: true }),
  "innerNetworkId": S.optionalWith(S.String, { nullable: true }),
  "networkLogo": S.optionalWith(S.String, { nullable: true }),
  "brokerType": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true })
}) {}

export class TokenNetworksModel extends S.Class<TokenNetworksModel>("TokenNetworksModel")({
  "token": S.optionalWith(S.String, { nullable: true }),
  "networks": S.optionalWith(S.Array(NetworkResponseBase), { nullable: true }),
  "supportedIntegrations": S.optionalWith(S.Array(BrokerType), { nullable: true }),
  "integrationNetworks": S.optionalWith(S.Array(IntegrationNetwork), { nullable: true }),
  "tokenLogoUrl": S.optionalWith(S.String, { nullable: true })
}) {}

export class TokenNetworksResponse extends S.Class<TokenNetworksResponse>("TokenNetworksResponse")({
  "tokens": S.optionalWith(S.Array(TokenNetworksModel), { nullable: true })
}) {}

export class TokenNetworksResponseApiResult extends S.Class<TokenNetworksResponseApiResult>("TokenNetworksResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(TokenNetworksResponse, { nullable: true })
}) {}

export class TransferVerificationRequest extends S.Class<TransferVerificationRequest>("TransferVerificationRequest")({
  "integrationId": S.optionalWith(S.String, { nullable: true }),
  "token": S.optionalWith(S.String, { nullable: true }),
  "networkId": S.optionalWith(S.String, { nullable: true }),
  "targetAddress": S.optionalWith(S.String, { nullable: true })
}) {}

export class TransferVerifyStatus extends S.Literal("succeeded", "failed") {}

export class FailureReason extends S.Literal("notSupportedOnIntegration", "notSupportedOnNetwork", "invalidAddressFormat", "notSupportedOnToken") {}

export class TransferVerificationResponse extends S.Class<TransferVerificationResponse>("TransferVerificationResponse")({
  "status": S.optionalWith(S.Literal("succeeded", "failed"), { nullable: true }),
  "errorMessage": S.optionalWith(S.String, { nullable: true }),
  "failureReason": S.optionalWith(FailureReason, { nullable: true })
}) {}

export class TransferVerificationResponseApiResult extends S.Class<TransferVerificationResponseApiResult>("TransferVerificationResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(TransferVerificationResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedVerify401 extends S.Struct({
  
}) {}

export class TransferToAddress extends S.Class<TransferToAddress>("TransferToAddress")({
  /**
* The Id of the network in Front system. The list of all available networks can be obtained by
* using `GET /transfers/managed/networks` endpoint.
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* The symbol of the digital asset.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* The address to send the asset to.
*/
"address": S.optionalWith(S.String, { nullable: true }),
  /**
* Secondary address identifier for coins like XRP,XMR etc.
*/
"addressTag": S.optionalWith(S.String, { nullable: true })
}) {}

export class ConfigureTransferRequest extends S.Class<ConfigureTransferRequest>("ConfigureTransferRequest")({
  /**
* The authentication token to send assets from.
*/
"fromAuthToken": S.String.pipe(S.minLength(1)),
  /**
* The type of the integration to send assets from.
*/
"fromType": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* The authentication token of the target integration. Can be used alternatively to the list of requested address (`toAddresses`).
* If used, `toType` should also be provided.
*/
"toAuthToken": S.optionalWith(S.String, { nullable: true }),
  /**
* The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `toAddresses`.
*/
"toType": S.optionalWith(BrokerType, { nullable: true }),
  /**
* A list of available addresses provided by the API client. The list can contain all supported addresses by the client.
* Front API validates the addresses and returns the list of supported tokens and networks as the result of the operation.
*/
"toAddresses": S.optionalWith(S.Array(TransferToAddress), { nullable: true }),
  /**
* If provided, Front API returns only networks that support transferring of this symbol.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* If provided, Front API configures the response to only return holdings with enough amount of this crypto for the transfer
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* If provided, Front API configures the response to only contain holdings with enough value (converted to fiat) for the transfer.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`.
*/
"fiatCurrency": S.optionalWith(S.String, { nullable: true }),
  /**
* If provided, from API configures the response to include the requested network only.
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* Specifies if all the fees are included in the amount to transfer.
*/
"isInclusiveFeeEnabled": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class ConfigureTransferStatus extends S.Literal("succeeded", "failed", "validationFailed", "notAuthorizedTo", "notAuthorizedFrom", "kycRequired", "fromIntegrationNotSupported", "toIntegrationNotSupported") {}

export class TransferFee extends S.Class<TransferFee>("TransferFee")({
  /**
* The amount of the fee.
*/
"fee": S.optionalWith(S.Number, { nullable: true }),
  /**
* The currency of the fee. Does not match the currency of the transfer in some cases.
*/
"feeCurrency": S.optionalWith(S.String, { nullable: true }),
  /**
* The value of the fee converted to the fiat currency.
*/
"feeInFiat": S.optionalWith(S.Number, { nullable: true })
}) {}

export class NetworkTransferIneligibilityReason extends S.Literal("amountNotSufficient", "gasFeeAssetBalanceNotEnough", "noTargetNetworkFound", "refusedByInstitution", "eligibleWithFunding", "balanceBelowRequestedAmount", "requestedAmountBelowMinimum", "balanceBelowMinimum", "requestedAmountBelowFees", "requestedAmountBelowClientMinimum", "requestedAmountAboveClientMaximum", "noPrice", "nyCoinbaseUserRestrictions") {}

export class ConfigureTransferResultNetwork extends S.Class<ConfigureTransferResultNetwork>("ConfigureTransferResultNetwork")({
  /**
* The name of the network.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* The Id of the network in Front system.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Then minimum amount that can be withdrawn using this network.
*/
"minimumAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* The maximum amount that can be withdrawn using this network.
*/
"maximumAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total estimated transfer fee converted to fiat. Can consist of the fee taken by the financial institution and the
* gas fee.
*/
"totalEstimatedTransferFeeInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* The minimum amount that can be withdrawn using this network, converted to fiat currency.
*/
"minimumAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* The maximum amount that can be withdrawn using this network, converted to fiat currency.
*/
"maximumAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be
* covered by the `InstitutionTransferFee`.
*/
"estimatedNetworkGasFee": S.optionalWith(TransferFee, { nullable: true }),
  /**
* The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not
* take the transfer fee and only network fee is used for the transfer.
*/
"institutionTransferFee": S.optionalWith(TransferFee, { nullable: true }),
  /**
* Specifies if the asset is eligible for a transfer over the current network.
*/
"eligibleForTransfer": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The reason indicating why the transfer cannot be performed over this network.
*/
"ineligibilityReason": S.optionalWith(NetworkTransferIneligibilityReason, { nullable: true }),
  "eligibleForTransferWithFunding": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The designated destination for sending the asset.
*/
"toAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Token's amount to transfer specified by the client.
*/
"transferAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* The minimum amount of cryptocurrency that is required to be present in the account to perform the transfer.
* Unlike `minimum` field that indicates the minimum amount that can generally be transferred, this field indicates the minimum
* that can be transferred given the current transfer configuration values, such as `amountInFiat` and `clientFee`.
*/
"minimumRequiredForTransferAmount": S.optionalWith(S.Number, { nullable: true }),
  "caipNetworkId": S.optionalWith(S.String, { nullable: true }),
  /**
* Logo url for network.
*/
"logoUrl": S.optionalWith(S.String, { nullable: true })
}) {}

export class HoldingTransferIneligibilityReason extends S.Literal("noEligibleNetworks", "symbolDoesNotMatch", "notSupportedForTransferByTarget", "notSupportedForTransferBySource", "eligibleWithFunding", "amountNotSufficient", "noPrice") {}

export class ConfigureTransferResultHolding extends S.Class<ConfigureTransferResultHolding>("ConfigureTransferResultHolding")({
  /**
* The symbol of the digital asset on the source account.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* The available balance of the digital asset.
*/
"availableBalance": S.optionalWith(S.Number, { nullable: true }),
  /**
* The available balance of the digital asset, converted to fiat currency.
*/
"availableBalanceInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Specifies if the asset is eligible for a transfer.
*/
"eligibleForTransfer": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Supported networks.
*/
"networks": S.optionalWith(S.Array(ConfigureTransferResultNetwork), { nullable: true }),
  /**
* The reason indicating why the transfer of the current asset cannot be performed.
*/
"ineligibilityReason": S.optionalWith(HoldingTransferIneligibilityReason, { nullable: true }),
  /**
* Indicates that the asset is not eligible for a transfer with the current holding balance,
* but can be made eligible after funding the balance using the cryptocurrency balance funding feature.
*/
"eligibleForTransferWithFunding": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Logo url for holding.
*/
"logoUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Specifies if the asset is used for bridging between networks.
*/
"isBridgingAsset": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class TransferBalanceFundingAvailabilityStatus extends S.Literal("disabled", "available", "requiresAmountLowering", "notApplicable", "unavailable") {}

export class TransferBalanceFundingAvailabilityBase extends S.Class<TransferBalanceFundingAvailabilityBase>("TransferBalanceFundingAvailabilityBase")({
  "status": S.optionalWith(S.Literal("disabled", "available", "requiresAmountLowering", "notApplicable", "unavailable"), { nullable: true })
}) {}

export class ConfigureTransferResponse extends S.Class<ConfigureTransferResponse>("ConfigureTransferResponse")({
  /**
* Status of the operation.
*/
"status": S.optionalWith(S.Literal("succeeded", "failed", "validationFailed", "notAuthorizedTo", "notAuthorizedFrom", "kycRequired", "fromIntegrationNotSupported", "toIntegrationNotSupported"), { nullable: true }),
  /**
* List of holdings on the source account.
*/
"holdings": S.optionalWith(S.Array(ConfigureTransferResultHolding), { nullable: true }),
  /**
* Amount in USD to transfer.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Used fiat currency.
*/
"fiatCurrency": S.optionalWith(S.String, { nullable: true }),
  /**
* Minimum transfer amount in fiat.
*/
"minimumTransferAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Maximum transfer amount in fiat
*/
"maximumTransferAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Supported fiat currencies for this transfer
*/
"supportedFiatCurrencies": S.optionalWith(S.Array(S.String), { nullable: true }),
  "transferBalanceFundingAvailability": S.optionalWith(TransferBalanceFundingAvailabilityBase, { nullable: true })
}) {}

export class ConfigureTransferResponseApiResult extends S.Class<ConfigureTransferResponseApiResult>("ConfigureTransferResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(ConfigureTransferResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedConfigure401 extends S.Struct({
  
}) {}

export class ApiV1TransfersManagedConfigure403 extends S.Struct({
  
}) {}

export class PreviewTransferRequest extends S.Class<PreviewTransferRequest>("PreviewTransferRequest")({
  /**
* The authentication token to send the asset from.
*/
"fromAuthToken": S.String.pipe(S.minLength(1)),
  /**
* The type of the integration to send the asset from.
*/
"fromType": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* The authentication token of the target integration. Can be used alternatively to the address in the `ToAddress` field.
* If used, `toType` should also be provided.
*/
"toAuthToken": S.optionalWith(S.String, { nullable: true }),
  /**
* The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `ToAddress`.
*/
"toType": S.optionalWith(BrokerType, { nullable: true }),
  /**
* The network to send the asset over.
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* The symbol of the digital asset to send.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* The target address to send the asset to.
*/
"toAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Secondary address identifier for coins like XRP,XMR etc.
*/
"addressTag": S.optionalWith(S.String, { nullable: true }),
  /**
* The amount to send, in crypto.
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* The amount to send, in fiat currency. Can be used alternatively to `Amount`.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`.
*/
"fiatCurrency": S.optionalWith(S.String, { nullable: true }),
  /**
* Transaction ID Provided by client to track transaction in future calls.
*/
"transactionId": S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
  /**
* Indicates that the transfer is a bridging transfer.
*/
"isBridging": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Specifies if all the fees are included in the amount to transfer.
*/
"isInclusiveFeeEnabled": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class PreviewTransferStatus extends S.Literal("succeeded", "failed", "requiresFunding") {}

export class TransferFeeDetails extends S.Class<TransferFeeDetails>("TransferFeeDetails")({
  /**
* Units of gas used
*/
"gasLimit": S.optionalWith(S.Number, { nullable: true }),
  /**
* The max amount of tip to be paid to validator
*/
"maxPriorityFeePerGas": S.optionalWith(S.Number, { nullable: true }),
  /**
* The max amount of fee to be paid per gas
*/
"maxFeePerGas": S.optionalWith(S.Number, { nullable: true })
}) {}

export class ProcessingFeeRetainType extends S.Literal("default", "smartDeposit") {}

export class ProcessingFeeRetainMethod extends S.Class<ProcessingFeeRetainMethod>("ProcessingFeeRetainMethod")({
  "type": S.optionalWith(S.Literal("default", "smartDeposit"), { nullable: true }),
  "processingFeeAddress": S.optionalWith(S.String, { nullable: true })
}) {}

export class BridgingDetails extends S.Class<BridgingDetails>("BridgingDetails")({
  /**
* The ID of the bridging direction that was used to generate the preview.
*/
"bridgingDirectionId": S.optionalWith(S.String, { nullable: true }),
  "targetAddress": S.optionalWith(S.String, { nullable: true })
}) {}

export class PreviewTransferResult extends S.Class<PreviewTransferResult>("PreviewTransferResult")({
  /**
* The Id of the preview of the transfer. Should be used to commit the transfer using `Execute` endpoint.
*/
"previewId": S.optionalWith(S.String, { nullable: true }),
  /**
* The period of time in seconds during which the transfer can be committed.
*/
"previewExpiresIn": S.optionalWith(S.Int, { nullable: true }),
  /**
* Obtained address that will be used to send the transfer. Not guaranteed to be returned by some of integrations.
*/
"fromAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Obtained address that will be used to refund the transfer. Not guaranteed to be returned by some of integrations.
*/
"refundAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* The target address to send the asset to.
*/
"toAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Secondary address identifier for coins like XRP, XMR etc.
*/
"addressTag": S.optionalWith(S.String, { nullable: true }),
  /**
* Symbol of the asset to be sent.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Amount in symbol. If the transfer was requested using `AmountInFiat` field, this field represents the exact amount
* of the asset that will be transferred.
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transfer amount in fiat. If the transfer was requested in crypto amount using the `Amount` field,
* this field contains the corresponding converted to fiat value.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total estimated amount of the transfer including all fees, in cryptocurrency.
*/
"totalEstimatedAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total estimated amount of the transfer including all fees, converted to fiat.
*/
"totalEstimatedAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Id of the network in Front system.
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* Name of the network in Front system.
*/
"networkName": S.optionalWith(S.String, { nullable: true }),
  /**
* Blockchain address of the transferred token's contract
*/
"contractAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not
* take the transfer fee and only network fee is used for the transfer.
*/
"institutionTransferFee": S.optionalWith(TransferFee, { nullable: true }),
  /**
* The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be
* covered by the `InstitutionTransferFee`.
*/
"estimatedNetworkGasFee": S.optionalWith(TransferFee, { nullable: true }),
  /**
* The gas fee values in EIP 1559 standard that is estimated to be taken by the network.
*/
"estimatedNetworkGasFeeDetails": S.optionalWith(TransferFeeDetails, { nullable: true }),
  /**
* Number of decimal places used to represent the token's smallest unit
*/
"decimalPlaces": S.optionalWith(S.Int, { nullable: true }),
  /**
* The price of the cryptocurrency asset in the fiat currency.
*/
"unitPrice": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transaction id provided by the client
*/
"clientTransactionId": S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
  /**
* A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments.
* This will override any default fee entered in your Mesh dashboard for an individual transaction.
* Please note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),
* and not for Deposits (when the transfer destination is an address owned by the end user).
* If used for Deposits, it will increase the size of the user's Deposit by the fee amount,
* but will incorrectly show to the user as a fee.
*/
"clientFee": S.optionalWith(S.Number.pipe(S.greaterThanOrEqualTo(0), S.lessThanOrEqualTo(1)), { nullable: true }),
  /**
* The client fee that is estimated to be added to the total estimated transfer amount, based on the user's requested transfer amount and client fee percentage.
*/
"customClientFee": S.optionalWith(TransferFee, { nullable: true }),
  "processingFeeRetainMethod": S.optionalWith(ProcessingFeeRetainMethod, { nullable: true }),
  /**
* Deposit: The user is transferring crypto to a wallet they own on your platform.
* Payment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.
* Onramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.
*/
"transferType": S.optionalWith(S.Literal("deposit", "payment", "onramp"), { nullable: true }),
  "isCustomClientFeeProvided": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Amount in symbol after the client fees are applied. This field represents the exact amount
* of the asset that will be requested for transfer.
*/
"amountWithCustomClientFee": S.optionalWith(S.Number, { nullable: true }),
  /**
* Indicates if all the fees are included in the amount. For example, if this field's value is `true`
* and the user wants to send 1 BTC and the sum of all fees is 0.1 BTC, the user will be charged 1 BTC, and
* the target address will receive 0.9 BTC.
* If the fees are no inclusive, the user will be charged 1.1 BTC and the target address will receive 1 BTC.
*/
"isFeeIncluded": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Indicates the final amount to receive after all fees are applied. In case fees are not inclusive (`IsFeeIncluded` is `false`),
* this field will be equal to the `Amount` field.
*/
"amountToReceive": S.optionalWith(S.Number, { nullable: true }),
  /**
* Indicates the final amount in fiat to receive after all fees are applied. In case fees are not inclusive (`IsFeeIncluded` is `false`),
* this field will be equal to the `AmountInFiat` field.
*/
"amountToReceiveInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Exact amount in cryptocurrency requested to transfer to the destination address using the target integration.
*/
"transferAmountToRequest": S.optionalWith(S.Number, { nullable: true }),
  /**
* Indicates if the transfer's intention is to transfer all available assets using the requested network and symbol.
*/
"isMaximumAmount": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Indicates the fiat currency that is used to calculate transfer amounts.
*/
"fiatCurrency": S.optionalWith(S.String, { nullable: true }),
  /**
* Indicates if the transfer is a bridging transfer, meaning that the transfer will be swapped between two different networks.
*/
"isBridging": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Details of the bridging operation, in case the transfer is a bridging transfer.
*/
"bridgingDetails": S.optionalWith(BridgingDetails, { nullable: true })
}) {}

export class TransferBalanceFundingAvailability extends S.Class<TransferBalanceFundingAvailability>("TransferBalanceFundingAvailability")({
  "status": S.optionalWith(TransferBalanceFundingAvailabilityStatus, { nullable: true }),
  /**
* The total transfer amount in crypto after all fees are applied
*/
"transferTotalAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* The price of the cryptocurrency asset in the fiat currency.
*/
"unitPrice": S.optionalWith(S.Number, { nullable: true }),
  /**
* Represents the safety margin amount to cover gas fee volatility.
*/
"gasFeeBuffer": S.optionalWith(TransferFee, { nullable: true }),
  "symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* The total transfer amount in fiat after all fees are applied.
*/
"transferTotalAmountInFiat": S.optionalWith(S.Number, { nullable: true })
}) {}

export class TransferFromAnotherAccountAvailabilityInfo extends S.Class<TransferFromAnotherAccountAvailabilityInfo>("TransferFromAnotherAccountAvailabilityInfo")({
  "transferFromAnotherAccountNeeded": S.optionalWith(S.Boolean, { nullable: true }),
  "transferFromAnotherAccountAmount": S.optionalWith(S.Number, { nullable: true }),
  "anotherAccountName": S.optionalWith(S.String, { nullable: true })
}) {}

export class PreviewTransferResponse extends S.Class<PreviewTransferResponse>("PreviewTransferResponse")({
  /**
* The status of the operation.
*/
"status": S.optionalWith(S.Literal("succeeded", "failed", "requiresFunding"), { nullable: true }),
  /**
* Result of the preview.
*/
"previewResult": S.optionalWith(PreviewTransferResult, { nullable: true }),
  "transferBalanceFundingAvailability": S.optionalWith(TransferBalanceFundingAvailability, { nullable: true }),
  /**
* For instance if not enough assets in Spot account, and we can fill it from Funding account
*/
"transferFromAnotherAccountAvailabilityInfo": S.optionalWith(TransferFromAnotherAccountAvailabilityInfo, { nullable: true })
}) {}

export class PreviewTransferResponseApiResult extends S.Class<PreviewTransferResponseApiResult>("PreviewTransferResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(PreviewTransferResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedPreview401 extends S.Struct({
  
}) {}

export class ApiV1TransfersManagedPreview403 extends S.Struct({
  
}) {}

export class ExecuteTransferRequest extends S.Class<ExecuteTransferRequest>("ExecuteTransferRequest")({
  /**
* The authentication token to send the asset from.
*/
"fromAuthToken": S.String.pipe(S.minLength(1)),
  /**
* The type of the integration to send the asset from.
*/
"fromType": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Id of the Preview of the transfer.
*/
"previewId": S.String,
  /**
* Multi-factor auth code that should be provided if the status of the transfer was `MfaRequired`.
*/
"mfaCode": S.optionalWith(S.String, { nullable: true }),
  /**
* When user is unable to provide the primary Mfa this should be passed in to use fallback Mfa.
*/
"tryAnotherMfa": S.optionalWith(S.Boolean, { nullable: true }),
  "challengeId": S.optionalWith(S.String, { nullable: true })
}) {}

export class ExecuteTransferStatus extends S.Literal("succeeded", "inProgress", "failed", "mfaRequired", "emailConfirmationRequired", "deviceConfirmationRequired", "mfaFailed", "addressWhitelistRequired", "secondMfaRequired", "deFiWalletConfirmationRequired", "emailConfirmationApprovalRequired") {}

export class ExecuteTransferMfaType extends S.Literal("unspecified", "phone", "email", "totp", "face", "tradingPin", "mobile") {}

export class BrokerCryptocurrencyTransactionStatus extends S.Literal("unknown", "failed", "frozen", "succeeded", "mfaRequired", "pending", "expired", "canceled", "waitingForSignature", "waitingForClearing", "awaitingApproval", "awaitingConfirmation", "awaitingVerification", "rejected", "pendingCancel", "emailVerification", "deviceConfirmationRequired", "mfaFailed", "addressWhitelistRequired", "secondMfaRequired", "emailConfirmationApprovalRequired", "travelRuleRequired") {}

export class SmartContractTransferAllocation extends S.Class<SmartContractTransferAllocation>("SmartContractTransferAllocation")({
  /**
* Blockchain address of the Smart Contract
*/
"address": S.optionalWith(S.String, { nullable: true }),
  /**
* The timestamp by which the transfer must be completely initiated. Currently, this means solving the MFA steps
*/
"expirationTimestamp": S.optionalWith(S.Int, { nullable: true })
}) {}

export class ExecuteTransferResultResponse extends S.Class<ExecuteTransferResultResponse>("ExecuteTransferResultResponse")({
  /**
* The Id of the transfer by the integration.
*/
"transferId": S.optionalWith(S.String, { nullable: true }),
  /**
* The current status of the transfer.
*/
"status": S.optionalWith(S.Literal("unknown", "failed", "frozen", "succeeded", "mfaRequired", "pending", "expired", "canceled", "waitingForSignature", "waitingForClearing", "awaitingApproval", "awaitingConfirmation", "awaitingVerification", "rejected", "pendingCancel", "emailVerification", "deviceConfirmationRequired", "mfaFailed", "addressWhitelistRequired", "secondMfaRequired", "emailConfirmationApprovalRequired", "travelRuleRequired"), { nullable: true }),
  /**
* Details of the current status of the transfer, as provided by the integration.
*/
"statusDetails": S.optionalWith(S.String, { nullable: true }),
  /**
* The address of the source account or wallet.
*/
"fromAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* The address of the target account or wallet.
*/
"toAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Transferred symbol.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* The name of the used network.
*/
"networkName": S.optionalWith(S.String, { nullable: true }),
  /**
* The Id of the used network in Front system.
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* The hash of the blockchain transaction.
*/
"hash": S.optionalWith(S.String, { nullable: true }),
  /**
* The transferred amount, in the symbol of the transfer.
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* The transferred amount, converted to the fiat currency.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total amount of the transfer including all fees, converted to fiat.
*/
"totalAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Current number of network confirmations.
*/
"completedConfirmations": S.optionalWith(S.Int, { nullable: true }),
  /**
* The fee that was taken by the institution.
*/
"institutionTransferFee": S.optionalWith(TransferFee, { nullable: true }),
  /**
* The gas fee that was taken by the network. Depending on the integration, the network gas fee might be
* covered by the `InstitutionTransferFee`.
*/
"networkGasFee": S.optionalWith(TransferFee, { nullable: true }),
  /**
* Details of the allocated Smart Contract in case of 'Deposit' type transfers.
*/
"smartContract": S.optionalWith(SmartContractTransferAllocation, { nullable: true })
}) {}

export class ExecuteTransferResponse extends S.Class<ExecuteTransferResponse>("ExecuteTransferResponse")({
  /**
* The status of the transfer.
*/
"status": S.optionalWith(S.Literal("succeeded", "inProgress", "failed", "mfaRequired", "emailConfirmationRequired", "deviceConfirmationRequired", "mfaFailed", "addressWhitelistRequired", "secondMfaRequired", "deFiWalletConfirmationRequired", "emailConfirmationApprovalRequired"), { nullable: true }),
  /**
* The type of the MFA when the status is `MfaRequired`.
*/
"mfaType": S.optionalWith(ExecuteTransferMfaType, { nullable: true }),
  /**
* The type of the MFA when the status is `MfaRequired`.
*/
"verificationSteps": S.optionalWith(S.Array(ExecuteTransferMfaType), { nullable: true }),
  /**
* The transaction number for Travel rule required clients (optional, depends on an integration).
*/
"travelRuleTransactionId": S.optionalWith(S.Int, { nullable: true }),
  "qrCode": S.optionalWith(S.String, { nullable: true }),
  "qrCodeLink": S.optionalWith(S.String, { nullable: true }),
  /**
* Error message, if the operation did not complete successfully.
*/
"errorMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Result of the transfer initiation.
*/
"executeTransferResult": S.optionalWith(ExecuteTransferResultResponse, { nullable: true }),
  "fallbackMfaAvailable": S.optionalWith(S.Boolean, { nullable: true }),
  "challengeId": S.optionalWith(S.String, { nullable: true })
}) {}

export class ExecuteTransferResponseApiResult extends S.Class<ExecuteTransferResponseApiResult>("ExecuteTransferResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(ExecuteTransferResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedExecute401 extends S.Struct({
  
}) {}

export class ApiV1TransfersManagedExecute403 extends S.Struct({
  
}) {}

export class CryptocurrencyAddressType extends S.Literal("ethAddress", "btcAddress", "ltcAddress", "solAddress", "algoAddress", "celoAddress", "cardanoAddress", "polygonAddress", "bnbAddress", "elrondAddress", "neoAddress", "xrpAddress", "flowAddress", "harmonyOneAddress", "tronAddress", "dogeAddress", "opAddress") {}

export class ManagedBrokerCryptocurrencyDepositAddressRequest extends S.Class<ManagedBrokerCryptocurrencyDepositAddressRequest>("ManagedBrokerCryptocurrencyDepositAddressRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Symbol of the required cryptocurrency, e.g. ETH or BTC.
* Can be used instead of the `AddressType` field.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.
* Can be used instead of `Symbol` field.
*/
"addressType": S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
  /**
* Specifies which the network to use to obtain the deposit address of the `Symbol` asset.
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect
*/
"mfaCode": S.optionalWith(S.String, { nullable: true })
}) {}

export class BrokerResponseStatus extends S.Literal("unknown", "mfaRequired", "kycRequired") {}

export class B2BBrokerCryptocurrencyDepositAddressResponse extends S.Class<B2BBrokerCryptocurrencyDepositAddressResponse>("B2BBrokerCryptocurrencyDepositAddressResponse")({
  "symbol": S.optionalWith(S.String, { nullable: true }),
  "address": S.optionalWith(S.String, { nullable: true }),
  "chain": S.optionalWith(S.String, { nullable: true }),
  "memo": S.optionalWith(S.String, { nullable: true }),
  "minimumDepositAmount": S.optionalWith(S.String, { nullable: true }),
  "networkId": S.optionalWith(S.String, { nullable: true }),
  "brokerResponseStatus": S.optionalWith(BrokerResponseStatus, { nullable: true }),
  "errorMessage": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerCryptocurrencyDepositAddressResponseApiResult extends S.Class<B2BBrokerCryptocurrencyDepositAddressResponseApiResult>("B2BBrokerCryptocurrencyDepositAddressResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerCryptocurrencyDepositAddressResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedAddressGet401 extends S.Struct({
  
}) {}

export class QuoteTransferRequest extends S.Class<QuoteTransferRequest>("QuoteTransferRequest")({
  /**
* Base amount of fiat currency being transferred
*/
"amountInFiat": S.Number,
  /**
* 3 character currency code, e.g. USD
*/
"fiatCurrency": S.String.pipe(S.minLength(0), S.maxLength(3)),
  /**
* Symbol of destination cryptocurrency, e.g. ETH
*/
"symbol": S.String.pipe(S.minLength(0), S.maxLength(10)),
  /**
* Unique id of destination network
*/
"networkId": S.String,
  /**
* The designated destination for sending the asset.
*/
"toAddress": S.String.pipe(S.minLength(0), S.maxLength(1024)),
  /**
* The type of the integration to send the asset from
*/
"brokerType": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Flat fee in crypto to be charged as a partner fee
*/
"feeFlat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Percentage of transfer amount to be charged as a partner fee, expressed as decimal (ie 0.1 = 10%)
*/
"feePercentage": S.optionalWith(S.Number, { nullable: true })
}) {}

export class QuoteFeesInFiat extends S.Class<QuoteFeesInFiat>("QuoteFeesInFiat")({
  /**
* Max fee charged if funded by payment method
*/
"paymentMethodFeeMaxFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Max fee charged to buy crypto
*/
"tradingFeeMaxFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Fee charged to withdraw crypto
*/
"withdrawalFeeFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Fee charged by partner
*/
"partnerFeeFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Fee charged for network transaction
*/
"networkFeeFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Min of total fees charged in fiat
*/
"minFeesFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Max of total fees charged in fiat
*/
"maxFeesFiat": S.optionalWith(S.Number, { nullable: true })
}) {}

export class QuoteFeesInCrypto extends S.Class<QuoteFeesInCrypto>("QuoteFeesInCrypto")({
  /**
* Max fee charged if funded by payment method
*/
"paymentMethodFeeMax": S.optionalWith(S.Number, { nullable: true }),
  /**
* Max fee charged to buy crypto
*/
"tradingFeeMax": S.optionalWith(S.Number, { nullable: true }),
  /**
* Fee charged to withdraw crypto
*/
"withdrawalFee": S.optionalWith(S.Number, { nullable: true }),
  /**
* Fee charged by partner
*/
"partnerFee": S.optionalWith(S.Number, { nullable: true }),
  /**
* Fee charged for network transaction
*/
"networkFee": S.optionalWith(S.Number, { nullable: true }),
  /**
* Min of total fees charged in crypto
*/
"minFees": S.optionalWith(S.Number, { nullable: true }),
  /**
* Max of total fees charged in crypto
*/
"maxFees": S.optionalWith(S.Number, { nullable: true })
}) {}

export class QuoteFees extends S.Class<QuoteFees>("QuoteFees")({
  /**
* Summary of all possible transfer fees in fiat
*/
"inFiat": S.optionalWith(QuoteFeesInFiat, { nullable: true }),
  /**
* Summary of all possible transfer fees in crypto
*/
"inCrypto": S.optionalWith(QuoteFeesInCrypto, { nullable: true })
}) {}

export class CryptocurrencyFundingOptionType extends S.Literal("existingCryptocurrencyBalance", "buyingPowerPurchase", "paymentMethodDepositUsage", "cryptocurrencyConversion", "stableCoinNoFeeConversion", "cryptocurrencyBuyingPowerConversion", "cryptocurrencyMultiStepConversion") {}

export class BrokerPaymentMethodType extends S.Literal("card", "bankAccount", "digitalWallet", "unknown") {}

export class QuoteFundingOption extends S.Class<QuoteFundingOption>("QuoteFundingOption")({
  /**
* Funding option being quoted
*/
"fundingOption": S.optionalWith(S.Literal("existingCryptocurrencyBalance", "buyingPowerPurchase", "paymentMethodDepositUsage", "cryptocurrencyConversion", "stableCoinNoFeeConversion", "cryptocurrencyBuyingPowerConversion", "cryptocurrencyMultiStepConversion"), { nullable: true }),
  /**
* Payment method being quoted for PaymentMethodDepositUsage funding option
*/
"paymentMethodType": S.optionalWith(BrokerPaymentMethodType, { nullable: true }),
  /**
* Fee charged for this payment method
*/
"paymentMethodFeeFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Fee charged to buy crypto if necessary for this funding option
*/
"tradingFeeFiat": S.optionalWith(S.Number, { nullable: true })
}) {}

export class QuoteTransferResponse extends S.Class<QuoteTransferResponse>("QuoteTransferResponse")({
  /**
* Base amount of fiat currency being transferred (provided in request)
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* 3 character currency code (provided in request)
*/
"fiatCurrency": S.optionalWith(S.String, { nullable: true }),
  /**
* Symbol of destination cryptocurrency (provided in request)
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Unique id of destination network (provided in request)
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* The designated destination for sending the asset.
*/
"toAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* The type of the integration to send the asset from (provided in request)
*/
"brokerType": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* Is the transaction is possible based on the minimum transfer amount of the selected exchange
*/
"isEligible": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Minimum amount eligible to transfer with selected asset, exchange, and network
*/
"minEligibleAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Minimum amount in fiat eligible to transfer with selected asset, exchange, and network
*/
"minEligibleAmountFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Maximum amount eligible to transfer with selected asset, exchange, and network
*/
"maxEligibleAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Maximum amount eligible in fiat to transfer with selected asset, exchange, and network
*/
"maxEligibleAmountFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* The reason a transaction is ineligible, returns none if eligible
*/
"ineligibilityReason": S.optionalWith(NetworkTransferIneligibilityReason, { nullable: true }),
  /**
* Price quote from the broker, falls back to reference price
*/
"brokerPrice": S.optionalWith(S.Number, { nullable: true }),
  /**
* Reference price
*/
"price": S.optionalWith(S.Number, { nullable: true }),
  /**
* Min amount transferred in fiat
*/
"minAmountFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Max amount transferred in fiat
*/
"maxAmountFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Min amount of crypto transferred
*/
"minAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Max amount of crypto transferred
*/
"maxAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Summary of all possible transfer fees
*/
"fees": S.optionalWith(QuoteFees, { nullable: true }),
  /**
* Summary of all possible funding options
*/
"fundingOptions": S.optionalWith(S.Array(QuoteFundingOption), { nullable: true })
}) {}

export class QuoteTransferResponseApiResult extends S.Class<QuoteTransferResponseApiResult>("QuoteTransferResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(QuoteTransferResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedQuote401 extends S.Struct({
  
}) {}

export class TransferStatus extends S.Literal("pending", "succeeded", "failed") {}

export class TransferOrderByFields extends S.Literal("id", "clientTransferId", "userId", "fromType", "amountInFiat", "status", "createdTimestamp", "symbol", "networkName") {}

export class ApiV1TransfersManagedMeshParams extends S.Struct({
  "Count": S.optionalWith(S.Int, { nullable: true }),
  "Offset": S.optionalWith(S.Int, { nullable: true }),
  "Id": S.optionalWith(S.String, { nullable: true }),
  "ClientTransactionId": S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(128)), { nullable: true }),
  "UserId": S.optionalWith(S.String.pipe(S.minLength(0), S.maxLength(50)), { nullable: true }),
  "IntegrationIds": S.optionalWith(S.Array(S.String).pipe(S.maxItems(100)), { nullable: true }),
  "Statuses": S.optionalWith(S.Array(TransferStatus).pipe(S.maxItems(5)), { nullable: true }),
  "FromTimestamp": S.optionalWith(S.Int, { nullable: true }),
  "ToTimestamp": S.optionalWith(S.Int, { nullable: true }),
  "MinAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  "MaxAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  "OrderBy": S.optionalWith(TransferOrderByFields, { nullable: true }),
  "Hash": S.optionalWith(S.String, { nullable: true }),
  "SubClientId": S.optionalWith(S.String, { nullable: true }),
  "DescendingOrder": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class TransferIntegrationWithLogoModel extends S.Class<TransferIntegrationWithLogoModel>("TransferIntegrationWithLogoModel")({
  /**
* Unique identifier of integration.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Type of integration.
*/
"type": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* Name of integration.
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Integration logo URL.
*/
"logoUrl": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* Funding method model.
*/
export class TransferFundingModel extends S.Class<TransferFundingModel>("TransferFundingModel")({
  /**
* Type of the funding method.
*/
"type": S.optionalWith(S.Literal("existingCryptocurrencyBalance", "buyingPowerPurchase", "paymentMethodDepositUsage", "cryptocurrencyConversion", "stableCoinNoFeeConversion", "cryptocurrencyBuyingPowerConversion", "cryptocurrencyMultiStepConversion"), { nullable: true }),
  /**
* Amount funded.
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Amount in fiat.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Symbol purchased.
*/
"toSymbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Amount used.
*/
"fromAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Symbol used.
*/
"fromSymbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Payment method type
*/
"paymentMethodType": S.optionalWith(BrokerPaymentMethodType, { nullable: true }),
  /**
* Fee of funding.
*/
"fee": S.optionalWith(TransferFee, { nullable: true })
}) {}

export class BridgingOperationStatus extends S.Literal("recordCreated", "registeredInProvider", "sourceTransferStarted", "inReview", "providerAwaitingSourceTransfer", "providerFundsReceived", "providerProcessingPayment", "providerProcessedPayment", "providerSetUndeliverable", "returned", "refunded", "canceled", "succeeded", "failed") {}

export class BridgingTransferSide extends S.Class<BridgingTransferSide>("BridgingTransferSide")({
  "networkName": S.optionalWith(S.String, { nullable: true }),
  "symbol": S.optionalWith(S.String, { nullable: true }),
  "amount": S.optionalWith(S.Number, { nullable: true }),
  "transactionHash": S.optionalWith(S.String, { nullable: true }),
  "infoUrl": S.optionalWith(S.String, { nullable: true })
}) {}

export class BridgingTimelineEvent extends S.Class<BridgingTimelineEvent>("BridgingTimelineEvent")({
  "eventType": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(S.String, { nullable: true }),
  "timestamp": S.optionalWith(S.Int, { nullable: true })
}) {}

export class BridgingTransferDetailsModel extends S.Class<BridgingTransferDetailsModel>("BridgingTransferDetailsModel")({
  "status": S.optionalWith(S.Literal("recordCreated", "registeredInProvider", "sourceTransferStarted", "inReview", "providerAwaitingSourceTransfer", "providerFundsReceived", "providerProcessingPayment", "providerProcessedPayment", "providerSetUndeliverable", "returned", "refunded", "canceled", "succeeded", "failed"), { nullable: true }),
  "statusDescription": S.optionalWith(S.String, { nullable: true }),
  "targetSide": S.optionalWith(BridgingTransferSide, { nullable: true }),
  "sourceSide": S.optionalWith(BridgingTransferSide, { nullable: true }),
  "timeline": S.optionalWith(S.Array(BridgingTimelineEvent), { nullable: true })
}) {}

export class TransferModel extends S.Class<TransferModel>("TransferModel")({
  /**
* Mesh transfer identifier.
*/
"id": S.String,
  /**
* Client transaction identifier.
*/
"clientTransactionId": S.optionalWith(S.String, { nullable: true }),
  /**
* Integration transaction identifier.
*/
"institutionTransactionId": S.optionalWith(S.String, { nullable: true }),
  /**
* Client's user identifier.
*/
"userId": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer status.
*/
"status": S.optionalWith(S.Literal("pending", "succeeded", "failed"), { nullable: true }),
  /**
* Transfer amount in fiat.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Actual transfer amount without fees in fiat.
*/
"amountToReceiveInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transfer amount in fiat currency code.
*/
"amountInFiatCurrencyCode": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer amount.
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Actual transfer amount without fees.
*/
"amountToReceive": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transfer cryptocurrency symbol.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer cryptocurrency token contract address (e.g., for ERC20s).
*/
"tokenAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer network name.
*/
"networkName": S.optionalWith(S.String, { nullable: true }),
  /**
* Id of the transfer network.
*/
"networkId": S.optionalWith(S.String, { nullable: true }),
  /**
* Network logo URL.
*/
"networkLogoUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Created timestamp.
*/
"createdTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* From integration.
*/
"from": S.optionalWith(TransferIntegrationWithLogoModel, { nullable: true }),
  /**
* Transfer hash.
*/
"hash": S.optionalWith(S.String, { nullable: true }),
  /**
* Sub-client identifier.
*/
"subClientId": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer info url on blockchain explorer.
*/
"infoUrl": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer network gas fee.
*/
"gasFee": S.optionalWith(TransferFee, { nullable: true }),
  /**
* Financial insitution withdrawal fee.
*/
"withdrawalFee": S.optionalWith(TransferFee, { nullable: true }),
  /**
* Transfer processing fee.
*/
"processingFee": S.optionalWith(TransferFee, { nullable: true }),
  /**
* Transfer executed Unix timestamp.
*/
"executedTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* Type of a transfer.
*/
"transferType": S.optionalWith(TransferTypeEnum, { nullable: true }),
  /**
* Is fee included.
*/
"isFeeIncluded": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Amount what was actually transferred from source account.
*/
"sourceAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Amount what destination actually received.
*/
"destinationAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Amount in fiat what destination actually received.
*/
"destinationAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total fees paid by user to execute this transaction.
*/
"totalFeesAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total fiat transaction amount in origin integration.
*/
"totalTransactionAmountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* The funding methods that were used to fund the transaction.
*/
"fundingMethods": S.optionalWith(S.Array(TransferFundingModel), { nullable: true }),
  /**
* Transfer Destination Address.
*/
"destinationAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer Refund Address.
*/
"refundAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Bridging operation details.
*/
"bridgingDetails": S.optionalWith(BridgingTransferDetailsModel, { nullable: true })
}) {}

export class TransferModelPaginationResponse extends S.Class<TransferModelPaginationResponse>("TransferModelPaginationResponse")({
  /**
* list of items
*/
"items": S.optionalWith(S.Array(TransferModel), { nullable: true }),
  /**
* Total number of items
*/
"total": S.optionalWith(S.Int, { nullable: true })
}) {}

export class TransferModelPaginationResponseApiResult extends S.Class<TransferModelPaginationResponseApiResult>("TransferModelPaginationResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(TransferModelPaginationResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedMesh401 extends S.Struct({
  
}) {}

export class UpdateTransferStatusRequest extends S.Class<UpdateTransferStatusRequest>("UpdateTransferStatusRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Id of the executed transfer.
*/
"transactionId": S.String.pipe(S.minLength(1))
}) {}

/**
* Integration model.
*/
export class TransferIntegrationModel extends S.Class<TransferIntegrationModel>("TransferIntegrationModel")({
  /**
* Unique identifier of integration.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Type of integration.
*/
"type": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* Name of integration.
*/
"name": S.optionalWith(S.String, { nullable: true })
}) {}

export class UpdateTransferModel extends S.Class<UpdateTransferModel>("UpdateTransferModel")({
  /**
* Mesh transfer identifier.
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Client transaction identifier.
*/
"clientTransactionId": S.optionalWith(S.String, { nullable: true }),
  /**
* Integration transaction identifier.
*/
"institutionTransactionId": S.optionalWith(S.String, { nullable: true }),
  /**
* Client's user identifier.
*/
"userId": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer status.
*/
"status": S.optionalWith(S.Literal("pending", "succeeded", "failed"), { nullable: true }),
  /**
* Transfer amount in fiat.
*/
"amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transfer amount in fiat currency code.
*/
"amountInFiatCurrencyCode": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer amount.
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transfer cryptocurrency symbol.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer network name.
*/
"networkName": S.optionalWith(S.String, { nullable: true }),
  /**
* Created timestamp.
*/
"createdTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* From integration.
*/
"from": S.optionalWith(TransferIntegrationModel, { nullable: true }),
  /**
* Transfer hash.
*/
"hash": S.optionalWith(S.String, { nullable: true }),
  /**
* Transfer executed Unix timestamp.
*/
"executedTimestamp": S.optionalWith(S.Int, { nullable: true })
}) {}

export class UpdateTransferResponse extends S.Class<UpdateTransferResponse>("UpdateTransferResponse")({
  /**
* The status of the transfer.
*/
"status": S.optionalWith(S.Literal("pending", "succeeded", "failed"), { nullable: true }),
  /**
* The status details of the transfer.
*/
"statusDetails": S.optionalWith(S.Literal("unknown", "failed", "frozen", "succeeded", "mfaRequired", "pending", "expired", "canceled", "waitingForSignature", "waitingForClearing", "awaitingApproval", "awaitingConfirmation", "awaitingVerification", "rejected", "pendingCancel", "emailVerification", "deviceConfirmationRequired", "mfaFailed", "addressWhitelistRequired", "secondMfaRequired", "emailConfirmationApprovalRequired", "travelRuleRequired"), { nullable: true }),
  /**
* Error message, if the operation did not complete successfully.
*/
"errorMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Result of the transfer initiation.
*/
"transferResult": S.optionalWith(UpdateTransferModel, { nullable: true })
}) {}

export class UpdateTransferResponseApiResult extends S.Class<UpdateTransferResponseApiResult>("UpdateTransferResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(UpdateTransferResponse, { nullable: true })
}) {}

export class ApiV1TransfersManagedUpdate401 extends S.Struct({
  
}) {}

export class ApiV1TransfersManagedUpdate403 extends S.Struct({
  
}) {}

export class PortfolioHoldingsRequest extends S.Class<PortfolioHoldingsRequest>("PortfolioHoldingsRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```OpenSea```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```CexIo```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```BitFlyer```
* ```Coinlist```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```BitfinexDirect```
* ```Bybit```
* ```Paxos```
* ```CoinbasePrime```
* ```BtcTurkDirect```
* ```KuCoinDirect```
* ```OkxOAuth```
* ```ParibuDirect```
* ```RobinhoodConnect```
* ```BlockchainCom```
* ```BitsoDirect```
* ```BinanceOAuth```
* ```BybitDirect```
* ```ParibuOAuth```
* ```BinanceTrDirect```
* ```BybitDirectMobile```
* ```DeFiWallet```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  "includeMarketValue": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class BrokerRequestStatus extends S.Literal("succeeded", "failed", "notAuthorized") {}

/**
* Represents the distribution of a DeFi position across different networks and addresses.
* This class holds the network-specific information, wallet address, and the amount of cryptocurrency
* allocated to each network and address for self-custody (DeFi) wallets.
*/
export class DeFiPositionDistribution extends S.Class<DeFiPositionDistribution>("DeFiPositionDistribution")({
  /**
* Cryptocurrency CAIP-2 network ID associated with this distribution.
*/
"caipNetworkId": S.NullOr(S.String),
  /**
* The wallet address on the specific network.
*/
"address": S.NullOr(S.String),
  /**
* Amount of cryptocurrency allocated to this network and address.
*/
"amount": S.Number
}) {}

export class Position extends S.Class<Position>("Position")({
  /**
* Name of the asset
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Symbol of the asset
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Amount of the asset
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* The total original value (or purchase price) of the asset
*/
"costBasis": S.optionalWith(S.Number, { nullable: true }),
  /**
* Breakdown of crypto distribution across different networks and addresses.
* This data is populated only for self-custody (DeFi) wallets.
*/
"distribution": S.optionalWith(S.Array(DeFiPositionDistribution), { nullable: true })
}) {}

export class B2BNftPosition extends S.Class<B2BNftPosition>("B2BNftPosition")({
  "amount": S.optionalWith(S.Number, { nullable: true }),
  "costBasis": S.optionalWith(S.Number, { nullable: true }),
  "contractAddress": S.optionalWith(S.String, { nullable: true }),
  "name": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(S.String, { nullable: true }),
  "marketplaceId": S.optionalWith(S.String, { nullable: true }),
  "tokenId": S.optionalWith(S.String, { nullable: true }),
  "marketplacePermalink": S.optionalWith(S.String, { nullable: true }),
  "addressType": S.optionalWith(S.Literal("ethAddress", "btcAddress", "ltcAddress", "solAddress", "algoAddress", "celoAddress", "cardanoAddress", "polygonAddress", "bnbAddress", "elrondAddress", "neoAddress", "xrpAddress", "flowAddress", "harmonyOneAddress", "tronAddress", "dogeAddress", "opAddress"), { nullable: true })
}) {}

export class BrokerOptionDirection extends S.Literal("unknown", "buyToOpen", "buyToClose", "sellToOpen", "sellToClose", "buyToCover", "sellShort") {}

export class BrokerOptionType extends S.Literal("unknown", "call", "put") {}

export class B2BOptionPosition extends S.Class<B2BOptionPosition>("B2BOptionPosition")({
  /**
* Symbol of the underlying stock
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Amount of options
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total average paid price
*/
"averageOpenPrice": S.optionalWith(S.Number, { nullable: true }),
  /**
* Side of the option, buy or sell
*/
"direction": S.optionalWith(S.Literal("unknown", "buyToOpen", "buyToClose", "sellToOpen", "sellToClose", "buyToCover", "sellShort"), { nullable: true }),
  "createdTimestamp": S.optionalWith(S.Int, { nullable: true }),
  "updatedTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* Number of shares of the underlying stock
*/
"numberOfSharesInContract": S.optionalWith(S.Number, { nullable: true }),
  /**
* Type of the option, put or call
*/
"optionType": S.optionalWith(S.Literal("unknown", "call", "put"), { nullable: true }),
  /**
* The last day that the option contract is valid
*/
"expirationTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* The price at which a put or call option can be exercised
*/
"strikePrice": S.optionalWith(S.Number, { nullable: true })
}) {}

export class PositionWithMarketValue extends S.Class<PositionWithMarketValue>("PositionWithMarketValue")({
  /**
* Name of the asset
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Symbol of the asset
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Amount of the asset
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* The total original value (or purchase price) of the asset
*/
"costBasis": S.optionalWith(S.Number, { nullable: true }),
  /**
* Breakdown of crypto distribution across different networks and addresses.
* This data is populated only for self-custody (DeFi) wallets.
*/
"distribution": S.optionalWith(S.Array(DeFiPositionDistribution), { nullable: true }),
  /**
* Market value of the asset: amount of asset multiplied by last asset value.
*/
"marketValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* Current last price of the asset.
*/
"lastPrice": S.optionalWith(S.Number, { nullable: true })
}) {}

export class HoldingsModel extends S.Class<HoldingsModel>("HoldingsModel")({
  /**
* Status of the request to the institution's API
*/
"status": S.optionalWith(S.Literal("succeeded", "failed", "notAuthorized"), { nullable: true }),
  /**
* Error message specifying the problem
*/
"errorMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly error message, optimized to be shown to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* The equity positions Front could not recognize
*/
"notSupportedEquityPositions": S.optionalWith(S.Array(Position), { nullable: true }),
  /**
* The cryptocurrency positions Front could not recognize
*/
"notSupportedCryptocurrencyPositions": S.optionalWith(S.Array(Position), { nullable: true }),
  /**
* NFT holdings on the account
*/
"nftPositions": S.optionalWith(S.Array(B2BNftPosition), { nullable: true }),
  /**
* Option holdings on the account
*/
"optionPositions": S.optionalWith(S.Array(B2BOptionPosition), { nullable: true }),
  /**
* Type of the institution
*/
"type": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* External institution's account id (returned by the institution)
*/
"accountId": S.optionalWith(S.String, { nullable: true }),
  /**
* Friendly name of the connected institution
*/
"institutionName": S.optionalWith(S.String, { nullable: true }),
  /**
* Name of the account as returned from the institution
*/
"accountName": S.optionalWith(S.String, { nullable: true }),
  /**
* Equity holdings, such as stocks and ETFs
*/
"equityPositions": S.optionalWith(S.Array(PositionWithMarketValue), { nullable: true }),
  /**
* Cryptocurrency holdings on the account
*/
"cryptocurrencyPositions": S.optionalWith(S.Array(PositionWithMarketValue), { nullable: true })
}) {}

export class HoldingsModelApiResult extends S.Class<HoldingsModelApiResult>("HoldingsModelApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(HoldingsModel, { nullable: true })
}) {}

export class ApiV1HoldingsGet401 extends S.Struct({
  
}) {}

export class ApiV1HoldingsGet403 extends S.Struct({
  
}) {}

export class PortfolioBrokerBaseRequest extends S.Class<PortfolioBrokerBaseRequest>("PortfolioBrokerBaseRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```OpenSea```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```CexIo```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```BitFlyer```
* ```Coinlist```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```BitfinexDirect```
* ```Bybit```
* ```Paxos```
* ```CoinbasePrime```
* ```BtcTurkDirect```
* ```KuCoinDirect```
* ```OkxOAuth```
* ```ParibuDirect```
* ```RobinhoodConnect```
* ```BlockchainCom```
* ```BitsoDirect```
* ```BinanceOAuth```
* ```BybitDirect```
* ```ParibuOAuth```
* ```BinanceTrDirect```
* ```BybitDirectMobile```
* ```DeFiWallet```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile")
}) {}

export class BrokerPortfolioValueModel extends S.Class<BrokerPortfolioValueModel>("BrokerPortfolioValueModel")({
  /**
* Total USD value of portfolio.
*/
"totalValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total performance in percents based on the cost basis.
*/
"totalPerformance": S.optionalWith(S.Number, { nullable: true }),
  /**
* USD value of all equities in the portfolio.
*/
"equitiesValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* Performance in percents of all equities based on the cost basis.
*/
"equitiesPerformance": S.optionalWith(S.Number, { nullable: true }),
  /**
* USD value of all cryptocurrencies in the portfolio.
*/
"cryptocurrenciesValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* Performance in percents of all cryptocurrencies in the portfolio based on the cost basis.
*/
"cryptocurrenciesPerformance": S.optionalWith(S.Number, { nullable: true }),
  /**
* USD value of all NFTs in the portfolio.
*/
"nftsValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* USD value of all fiat currencies in the portfolio.
*/
"fiatValue": S.optionalWith(S.Number, { nullable: true })
}) {}

export class BrokerPortfolioValueModelApiResult extends S.Class<BrokerPortfolioValueModelApiResult>("BrokerPortfolioValueModelApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(BrokerPortfolioValueModel, { nullable: true })
}) {}

export class ApiV1HoldingsValue401 extends S.Struct({
  
}) {}

export class ApiV1HoldingsValue403 extends S.Struct({
  
}) {}

export class ApiV1HoldingsPortfolioParams extends S.Struct({
  "UserId": S.String,
  "TimezoneOffset": S.optionalWith(S.Int, { nullable: true })
}) {}

export class PositionWithReturn extends S.Class<PositionWithReturn>("PositionWithReturn")({
  /**
* Name of the asset
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Symbol of the asset
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Amount of the asset
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* The total original value (or purchase price) of the asset
*/
"costBasis": S.optionalWith(S.Number, { nullable: true }),
  /**
* Breakdown of crypto distribution across different networks and addresses.
* This data is populated only for self-custody (DeFi) wallets.
*/
"distribution": S.optionalWith(S.Array(DeFiPositionDistribution), { nullable: true }),
  /**
* Market value of the asset: amount of asset multiplied by last asset value.
*/
"marketValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* Current last price of the asset.
*/
"lastPrice": S.optionalWith(S.Number, { nullable: true }),
  /**
* What percentage of total portfolio value is taken by this asset.
*/
"portfolioPercentage": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total return of investment of this asset. Can be negative or null. Based on the cost basis of the asset, cost basis
* is not available by some of integrations.
*/
"totalReturn": S.optionalWith(S.Number, { nullable: true }),
  /**
* Percent of return of investment for this asset. Can be negative or null.
*/
"returnPercentage": S.optionalWith(S.Number, { nullable: true }),
  /**
* Company name of the relative asset.
*/
"companyName": S.optionalWith(S.String, { nullable: true }),
  /**
* Total daily return of investment for this asset. Can be negative.
*/
"totalDailyReturn": S.optionalWith(S.Number, { nullable: true }),
  /**
* Daily percent of return of investment for this asset. Can be negative.
*/
"dailyReturnPercentage": S.optionalWith(S.Number, { nullable: true })
}) {}

export class NftOrderSide extends S.Literal("buy", "sell") {}

export class NftOrder extends S.Class<NftOrder>("NftOrder")({
  "orderSide": S.optionalWith(S.Literal("buy", "sell"), { nullable: true }),
  "symbol": S.optionalWith(S.String, { nullable: true }),
  "price": S.optionalWith(S.Number, { nullable: true }),
  "priceUsd": S.optionalWith(S.Number, { nullable: true }),
  "amount": S.optionalWith(S.Number, { nullable: true }),
  "createdTimestamp": S.optionalWith(S.Int, { nullable: true }),
  "updatedTimestamp": S.optionalWith(S.Int, { nullable: true }),
  "symbolLogo": S.optionalWith(S.String, { nullable: true })
}) {}

export class NftBlockchain extends S.Literal("ethereum", "polygon", "klaytn") {}

export class NftPositionWithMarketValues extends S.Class<NftPositionWithMarketValues>("NftPositionWithMarketValues")({
  "amount": S.optionalWith(S.Number, { nullable: true }),
  "costBasis": S.optionalWith(S.Number, { nullable: true }),
  "contractAddress": S.optionalWith(S.String, { nullable: true }),
  "paymentTokenSymbol": S.optionalWith(S.String, { nullable: true }),
  "name": S.optionalWith(S.String, { nullable: true }),
  "description": S.optionalWith(S.String, { nullable: true }),
  "imageUrl": S.optionalWith(S.String, { nullable: true }),
  "imageOriginalUrl": S.optionalWith(S.String, { nullable: true }),
  "animationUrl": S.optionalWith(S.String, { nullable: true }),
  "backgroundColor": S.optionalWith(S.String, { nullable: true }),
  "marketplaceId": S.optionalWith(S.String, { nullable: true }),
  "tokenId": S.optionalWith(S.String, { nullable: true }),
  "numberOfSales": S.optionalWith(S.Int, { nullable: true }),
  "contractType": S.optionalWith(S.String, { nullable: true }),
  "contractName": S.optionalWith(S.String, { nullable: true }),
  "contractSchemaName": S.optionalWith(S.String, { nullable: true }),
  "contractSymbol": S.optionalWith(S.String, { nullable: true }),
  "contractDescription": S.optionalWith(S.String, { nullable: true }),
  "marketplacePermalink": S.optionalWith(S.String, { nullable: true }),
  "contractExternalLink": S.optionalWith(S.String, { nullable: true }),
  "creatorAddress": S.optionalWith(S.String, { nullable: true }),
  "currentOffer": S.optionalWith(NftOrder, { nullable: true }),
  "lastSale": S.optionalWith(NftOrder, { nullable: true }),
  "blockchain": S.optionalWith(S.Literal("ethereum", "polygon", "klaytn"), { nullable: true }),
  "addressExplorerLink": S.optionalWith(S.String, { nullable: true }),
  "twitterUsername": S.optionalWith(S.String, { nullable: true }),
  /**
* Amount of NFTs multiplied by NFT value
*/
"marketValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* What percentage of total portfolio value is taken by this NFT
*/
"portfolioPercentage": S.optionalWith(S.Number, { nullable: true })
}) {}

export class B2BPortfolioModel extends S.Class<B2BPortfolioModel>("B2BPortfolioModel")({
  /**
* Amount of money spent to buy all positions of the portfolio.
*/
"portfolioCostBasis": S.optionalWith(S.Number, { nullable: true }),
  /**
* Actual performance based on the cost basis.
*/
"actualPortfolioPerformance": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total USD portfolio value of all equities (sum(equity price * equity amount)). Does not include cash balance.
*/
"equitiesValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total USD value of all cryptocurrencies in the portfolio.
*/
"cryptocurrenciesValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total USD value of all NFTs in the portfolio.
*/
"nftsValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* List of equity positions
*/
"equityPositions": S.optionalWith(S.Array(PositionWithReturn), { nullable: true }),
  /**
* List of cryptocurrency positions
*/
"cryptocurrencyPositions": S.optionalWith(S.Array(PositionWithReturn), { nullable: true }),
  /**
* List of NFT positions
*/
"nftPositions": S.optionalWith(S.Array(NftPositionWithMarketValues), { nullable: true })
}) {}

export class B2BPortfolioModelApiResult extends S.Class<B2BPortfolioModelApiResult>("B2BPortfolioModelApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BPortfolioModel, { nullable: true })
}) {}

export class ApiV1HoldingsPortfolio401 extends S.Struct({
  
}) {}

export class ApiV1HoldingsPortfolio403 extends S.Struct({
  
}) {}

export class ApiV1CatalogSolanaGetLatestBlockhashParams extends S.Struct({
  "chainId": S.optionalWith(S.String, { nullable: true })
}) {}

export class StringApiResult extends S.Class<StringApiResult>("StringApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(S.String, { nullable: true })
}) {}

export class BrokerOrderStatus extends S.Literal("unknown", "inProgress", "cancelled", "rejected", "failed", "success", "partiallyFilled", "expired") {}

export class TransactionsB2BBrokerOrderListRequest extends S.Class<TransactionsB2BBrokerOrderListRequest>("TransactionsB2BBrokerOrderListRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```CexIo```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```BitFlyer```
* ```Coinlist```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```Bybit```
* ```CoinbasePrime```
* ```RobinhoodConnect```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* The cursor to retrieve the next page of transactions.
* Providing it will cause the response to only return changes after this update.
* If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
*/
"cursor": S.optionalWith(S.String, { nullable: true }),
  /**
* Number of records to include in the response. 
* 
* Default: `100` 
* 
* Maximum: `250`
*/
"count": S.optionalWith(S.Int, { nullable: true }),
  /**
* Return orders of this statuses only. If this field is not provided, orders with all available statuses will be returned.
*/
"statuses": S.optionalWith(S.Array(BrokerOrderStatus), { nullable: true }),
  /**
* Return orders created after this timestamp.
* If this field is not provided, orders will be returned according to the default of the institution.
*/
"from": S.optionalWith(S.Int, { nullable: true })
}) {}

export class BrokerOrderType extends S.Literal("unknown", "buy", "sell") {}

export class B2BAssetType extends S.Literal("equity", "cryptocurrency", "option", "nft") {}

export class B2BBrokerOrderPaymentSymbolType extends S.Literal("fiat", "cryptocurrency") {}

export class BrokerOrderPlaceType extends S.Literal("unknown", "market", "limit", "stopLoss", "stopLimit", "takeProfit", "netDebit", "netCredit", "exercise") {}

export class BrokerOrderTimeInForceType extends S.Literal("goodTillCanceled", "immediateOrCancel", "fillOrKill", "goodForDay", "postOnly", "unknown") {}

export class B2BTransactionType extends S.Literal("order", "conversionTo", "conversionFrom", "ownAccountDeposit", "ownAccountWithdraw", "stake", "dividendReinvestment", "interest", "reward", "unknown", "conversionToFiat", "conversionFromFiat") {}

export class B2BBrokerOptionData extends S.Class<B2BBrokerOptionData>("B2BBrokerOptionData")({
  /**
* Type of option
*/
"optionType": S.optionalWith(S.Literal("unknown", "call", "put"), { nullable: true }),
  /**
* Direction of option
*/
"direction": S.optionalWith(S.Literal("unknown", "buyToOpen", "buyToClose", "sellToOpen", "sellToClose", "buyToCover", "sellShort"), { nullable: true }),
  /**
* Option strike price
*/
"strikePrice": S.optionalWith(S.Number, { nullable: true }),
  /**
* Option expiration timestamp
*/
"expirationTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* Number of shares covered by option
*/
"numberOfSharesInContract": S.optionalWith(S.Number, { nullable: true }),
  /**
* Option complex order strategy type
*/
"complexOrderStrategyType": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerOrder extends S.Class<B2BBrokerOrder>("B2BBrokerOrder")({
  /**
* Transaction id, as provided by the institution
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Side of the transaction
*/
"side": S.optionalWith(S.Literal("unknown", "buy", "sell"), { nullable: true }),
  /**
* Traded symbol
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Name of the traded asset
*/
"name": S.optionalWith(S.String, { nullable: true }),
  /**
* Type of the traded asset
*/
"assetType": S.optionalWith(S.Literal("equity", "cryptocurrency", "option", "nft"), { nullable: true }),
  /**
* Fiat or cryptocurrency symbol used for payment. For transactions with types `ConversionFrom` or `ConversionTo`
* this field specifies the target symbol. For example, for `ETH` to `BTC` conversion, the transaction type is `ConversionTo`, the `Symbol` field is `ETH` and the `PaymentSymbol` is `BTC`
*/
"paymentSymbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Indicates if the payment was performed with fiat or crypto currency
*/
"paymentType": S.optionalWith(S.Literal("fiat", "cryptocurrency"), { nullable: true }),
  /**
* Executed amount
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Price of the unit
*/
"price": S.optionalWith(S.Number, { nullable: true }),
  /**
* Order Fee, taken by the financial institution
*/
"fee": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total value
*/
"value": S.optionalWith(S.Number, { nullable: true }),
  /**
* Unix timestamp in seconds indicating when the order was placed or the transaction was created
*/
"createdTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* Unix timestamp in seconds indicating when the transaction was last updated (e.g. executed)
*/
"updatedTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* Status of the transaction
*/
"status": S.optionalWith(S.Literal("unknown", "inProgress", "cancelled", "rejected", "failed", "success", "partiallyFilled", "expired"), { nullable: true }),
  /**
* Status text, as provided by the institution
*/
"statusDetails": S.optionalWith(S.String, { nullable: true }),
  /**
* Type of the placed order
*/
"orderType": S.optionalWith(BrokerOrderPlaceType, { nullable: true }),
  /**
* Time in force of the order: a value indicating how long the order remains active before it is executed or expires
*/
"timeInForce": S.optionalWith(BrokerOrderTimeInForceType, { nullable: true }),
  /**
* Type of the integration
*/
"brokerType": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* Type of the transaction
*/
"transactionType": S.optionalWith(S.Literal("order", "conversionTo", "conversionFrom", "ownAccountDeposit", "ownAccountWithdraw", "stake", "dividendReinvestment", "interest", "reward", "unknown", "conversionToFiat", "conversionFromFiat"), { nullable: true }),
  /**
* Id of the parent order, applicable to some institutions
*/
"parentOrderId": S.optionalWith(S.String, { nullable: true }),
  /**
* Additional details for options
*/
"optionDetails": S.optionalWith(B2BBrokerOptionData, { nullable: true })
}) {}

export class B2BBrokerOrderListResponse extends S.Class<B2BBrokerOrderListResponse>("B2BBrokerOrderListResponse")({
  /**
* List of obtained transactions.
*/
"transactions": S.optionalWith(S.Array(B2BBrokerOrder), { nullable: true }),
  /**
* The cursor to retrieve the next page of transactions.
*/
"cursor": S.optionalWith(S.String, { nullable: true }),
  /**
* Total amount of records.
*/
"total": S.optionalWith(S.Int, { nullable: true }),
  /**
* Earliest transaction timestamp.
*/
"earliestTimestamp": S.optionalWith(S.Int, { nullable: true })
}) {}

export class B2BBrokerOrderListResponseApiResult extends S.Class<B2BBrokerOrderListResponseApiResult>("B2BBrokerOrderListResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerOrderListResponse, { nullable: true })
}) {}

export class ApiV1TransactionsList401 extends S.Struct({
  
}) {}

export class ApiV1TransactionsList403 extends S.Struct({
  
}) {}

export class TransactionsB2BBrokerOrderRequest extends S.Class<TransactionsB2BBrokerOrderRequest>("TransactionsB2BBrokerOrderRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```CexIo```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```BitFlyer```
* ```Coinlist```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```Bybit```
* ```CoinbasePrime```
* ```RobinhoodConnect```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  "id": S.String.pipe(S.minLength(1)),
  /**
* Should be provided for Coinbase.
*/
"side": S.optionalWith(BrokerOrderType, { nullable: true }),
  /**
* Some Stock and Crypto symbols can intersect, so we need to explicitly specify what type of asset is requested to be bought.
*/
"isCryptocurrency": S.Boolean,
  /**
* Symbol pair of the order (requested by some brokers).
*/
"symbolPair": S.optionalWith(S.String, { nullable: true }),
  /**
* MFA Code to cancel an order (requested by Kraken if MFA is enabled in user settings)
*/
"mfaCode": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerOrderApiResult extends S.Class<B2BBrokerOrderApiResult>("B2BBrokerOrderApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerOrder, { nullable: true })
}) {}

export class ApiV1TransactionsDetails401 extends S.Struct({
  
}) {}

export class ApiV1TransactionsDetails403 extends S.Struct({
  
}) {}

export class TransactionsBrokerBaseRequest extends S.Class<TransactionsBrokerBaseRequest>("TransactionsBrokerBaseRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```CexIo```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```BitFlyer```
* ```Coinlist```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```Bybit```
* ```CoinbasePrime```
* ```RobinhoodConnect```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile")
}) {}

export class B2BBrokerTradingFeatureOrderType extends S.Class<B2BBrokerTradingFeatureOrderType>("B2BBrokerTradingFeatureOrderType")({
  /**
* Specifies if this order type is supported for this integration.
*/
"supported": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Specifies if this order type supports buying or selling in fractional amounts. If this value is `false`, then only whole shares can be traded.
*/
"supportsFractionalShares": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Indicates if pre-market trading or after-hours trading is supported.
*/
"supportsExtendedMarketHours": S.optionalWith(S.Boolean, { nullable: true }),
  "supportsPlacingBuyOrdersInFiatAmount": S.optionalWith(S.Boolean, { nullable: true }),
  "supportsPlacingSellOrdersInFiatAmount": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The list of supported Time-in-force instructions for this order type.
*/
"supportedTimeInForceList": S.optionalWith(S.Array(BrokerOrderTimeInForceType), { nullable: true }),
  /**
* Specifies if this order type supports placing buy orders in payment/quote symbol amounts. For example,
* if payment/quote symbol is USD, and this capability is supported, then the API can be instructed to buy asset for $10 or other dollar amount.
*/
"supportsPlacingBuyOrdersInPaymentSymbolAmount": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Specifies if this order type supports placing sell orders in payment/quote symbol amounts. For example,
* if payment/quote symbol is USD, and this capability is supported, then the API can be instructed to sell asset for $10 or other dollar amount.
*/
"supportsPlacingSellOrdersInPaymentSymbolAmount": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Specifies if this order type supports placing buy orders in base symbol amounts. For example,
* if payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to buy 1 or other amount of AAPL.
*/
"supportsPlacingBuyOrdersInBaseSymbolAmount": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Specifies if this order type supports placing sell orders in base symbol amounts. For example,
* if payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to sell 1 or other amount of AAPL.
*/
"supportsPlacingSellOrdersInBaseSymbolAmount": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class B2BBrokerTradingFeature extends S.Class<B2BBrokerTradingFeature>("B2BBrokerTradingFeature")({
  "supported": S.optionalWith(S.Boolean, { nullable: true }),
  "supportsFiatCurrencyPayment": S.optionalWith(S.Boolean, { nullable: true }),
  "supportsCryptocurrencyPayment": S.optionalWith(S.Boolean, { nullable: true }),
  "supportsMarginOrders": S.optionalWith(S.Boolean, { nullable: true }),
  "supportedCryptocurrencySymbols": S.optionalWith(S.Array(S.String), { nullable: true }),
  "supportedCryptocurrencySymbolsForPayment": S.optionalWith(S.Array(S.String), { nullable: true }),
  "supportedFiatCurrencies": S.optionalWith(S.Array(S.String), { nullable: true }),
  "marketType": S.optionalWith(B2BBrokerTradingFeatureOrderType, { nullable: true }),
  "limitType": S.optionalWith(B2BBrokerTradingFeatureOrderType, { nullable: true }),
  "stopLossType": S.optionalWith(B2BBrokerTradingFeatureOrderType, { nullable: true })
}) {}

export class BrokerPairTradeTimeInForceType extends S.Literal("immediateOrCancel", "goodTillCanceled", "goodTillDate", "fillOrKill") {}

export class B2BBrokerCryptoPairTradeFeatureOrderType extends S.Class<B2BBrokerCryptoPairTradeFeatureOrderType>("B2BBrokerCryptoPairTradeFeatureOrderType")({
  /**
* Specifies if this order type is supported for this integration.
*/
"supported": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* The list of supported Time-in-force instructions for this order type.
*/
"supportedTimeInForceList": S.optionalWith(S.Array(BrokerPairTradeTimeInForceType), { nullable: true }),
  /**
* Specifies if this order type supports placing buy orders in base symbol amounts. For example,
* if payment/quote symbol is USD, base symbol is ETH, and this capability is supported, then the API can be instructed to buy 1 or other amount of ETH.
*/
"supportsPlacingBuyOrdersInBaseSymbolAmount": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Specifies if this order type supports placing sell orders in base symbol amounts. For example,
* if payment/quote symbol is USD, base symbol is ETH, and this capability is supported, then the API can be instructed to sell 1 or other amount of ETH.
*/
"supportsPlacingSellOrdersInBaseSymbolAmount": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Specifies if this order type supports placing buy orders in quote symbol amounts. For example,
* if payment/quote symbol is USDC, and this capability is supported, then the API can be instructed to buy asset for 10 USDC or other amount.
*/
"supportsPlacingBuyOrdersInQuoteSymbolAmount": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Specifies if this order type supports placing sell orders in quote symbol amounts. For example,
* if payment/quote symbol is USDC, and this capability is supported, then the API can be instructed to sell asset for 10 USDC or other amount.
*/
"supportsPlacingSellOrdersInQuoteSymbolAmount": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class B2BBrokerCryptocurrencyPairTradeFeature extends S.Class<B2BBrokerCryptocurrencyPairTradeFeature>("B2BBrokerCryptocurrencyPairTradeFeature")({
  "supported": S.optionalWith(S.Boolean, { nullable: true }),
  "supportedCryptocurrencySymbols": S.optionalWith(S.Array(S.String), { nullable: true }),
  "supportedFiatCurrencies": S.optionalWith(S.Array(S.String), { nullable: true }),
  "supportedTradingPairs": S.optionalWith(S.Array(S.String), { nullable: true }),
  "marketType": S.optionalWith(B2BBrokerCryptoPairTradeFeatureOrderType, { nullable: true }),
  "limitType": S.optionalWith(B2BBrokerCryptoPairTradeFeatureOrderType, { nullable: true })
}) {}

export class B2BBrokerConversionFeature extends S.Class<B2BBrokerConversionFeature>("B2BBrokerConversionFeature")({
  "supported": S.optionalWith(S.Boolean, { nullable: true }),
  "supportsPreview": S.optionalWith(S.Boolean, { nullable: true }),
  "supportedCryptocurrencySymbols": S.optionalWith(S.Array(S.String), { nullable: true }),
  "supportedFiatCurrencies": S.optionalWith(S.Array(S.String), { nullable: true })
}) {}

export class B2BBrokerTradingFeatureInfo extends S.Class<B2BBrokerTradingFeatureInfo>("B2BBrokerTradingFeatureInfo")({
  /**
* Type of the integration.
*/
"brokerType": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* Account Id of the integration.
*/
"accountId": S.optionalWith(S.String, { nullable: true }),
  /**
* Model, describing the ability to place cryptocurrency orders.
*/
"cryptocurrencyOrders": S.optionalWith(B2BBrokerTradingFeature, { nullable: true }),
  /**
* Model, describing the ability to place equity orders.
*/
"stockOrders": S.optionalWith(B2BBrokerTradingFeature, { nullable: true }),
  /**
* Model, describing the asset pair trading ability
*/
"cryptocurrencyAssetPairTrading": S.optionalWith(B2BBrokerCryptocurrencyPairTradeFeature, { nullable: true }),
  /**
* Model, describing the conversion ability
*/
"cryptocurrencyConversion": S.optionalWith(B2BBrokerConversionFeature, { nullable: true }),
  /**
* Status of the request.
*/
"status": S.optionalWith(S.Literal("succeeded", "failed", "notAuthorized"), { nullable: true }),
  /**
* Indicates if the preview of orders (`preview order execution` endpoint) is provided by the institution.
* This allows to validate the order using the API of the institution. If the order preview is not supported,
* Front API validates the order without calling the institution's API.
*/
"supportsOrderPreview": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Supports getting price information directly from the institution.
*/
"supportsPriceQuotes": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Indicates if it is possible to cancel the placed order, while it's in the `InProgress` status.
*/
"supportsOrderCancellation": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Indicates if the integration is available.
*/
"isIntegrationUp": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* Indicates if trading is generally supported at this time.
*/
"isTradingSupported": S.optionalWith(S.Boolean, { nullable: true }),
  /**
* List of fiat balances of the account.
*/
"fiatBalances": S.optionalWith(S.Array(B2BBrokerAccountBalance), { nullable: true }),
  /**
* Limit for history records
*/
"historyRecordLimit": S.optionalWith(S.Int, { nullable: true }),
  /**
* Indicates whether the current exchange uses spreads as costs for trading
*/
"usesSpreads": S.optionalWith(S.Boolean, { nullable: true })
}) {}

export class B2BBrokerTradingFeatureInfoApiResult extends S.Class<B2BBrokerTradingFeatureInfoApiResult>("B2BBrokerTradingFeatureInfoApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerTradingFeatureInfo, { nullable: true })
}) {}

export class ApiV1TransactionsFeatureList401 extends S.Struct({
  
}) {}

export class BrokerOrderPlaceTypeTrade extends S.Literal("market", "limit", "stopLoss") {}

export class TransactionsB2BBrokerCreateOrderRequest extends S.Class<TransactionsB2BBrokerCreateOrderRequest>("TransactionsB2BBrokerCreateOrderRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```CexIo```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```BitFlyer```
* ```Coinlist```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```Bybit```
* ```CoinbasePrime```
* ```RobinhoodConnect```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Symbol to trade. For example, `AAPL` or `ETH`
*/
"symbol": S.String.pipe(S.minLength(1)),
  /**
* Symbol to use for payment, defaults to `USD`.
*/
"paymentSymbol": S.String.pipe(S.minLength(1)),
  /**
* Amount of purchase.
*/
"amount": S.Number,
  /**
* Price of the unit, used for `Limit` and `StopLoss` orders.
*/
"price": S.optionalWith(S.Number, { nullable: true }),
  /**
* Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly.
*/
"isCryptocurrency": S.Boolean,
  /**
* Indicates whether the `PaymentSymbol` is fiat or cryptocurrency
*/
"paymentIsCryptocurrency": S.Boolean,
  "amountIsFiat": S.optionalWith(S.Boolean, { nullable: true }),
  "amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
* performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
* `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
* value is passed.
*/
"amountIsInPaymentSymbol": S.Boolean,
  /**
* Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
* and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
*/
"amountInPaymentSymbol": S.optionalWith(S.Number, { nullable: true }),
  /**
* Specifies if the extended trading hours should be used.
*/
"extendedHours": S.optionalWith(S.Boolean, { nullable: true }),
  "orderType": S.Literal("market", "limit", "stopLoss"),
  "timeInForce": S.Literal("goodTillCanceled", "immediateOrCancel", "fillOrKill", "goodForDay", "postOnly", "unknown"),
  /**
* MFA Code to create an order (requested by Kraken if MFA is enabled in user settings)
*/
"mfaCode": S.optionalWith(S.String, { nullable: true })
}) {}

export class BrokerOrderValidationStatus extends S.Literal("success", "failed") {}

export class B2BBrokerPreviewOrderResult extends S.Class<B2BBrokerPreviewOrderResult>("B2BBrokerPreviewOrderResult")({
  "brokerType": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  "fee": S.optionalWith(S.Number, { nullable: true }),
  "feeText": S.optionalWith(S.String, { nullable: true }),
  "amount": S.optionalWith(S.Number, { nullable: true }),
  "side": S.optionalWith(S.Literal("unknown", "buy", "sell"), { nullable: true }),
  "status": S.optionalWith(S.Literal("success", "failed"), { nullable: true }),
  "errorMessage": S.optionalWith(S.String, { nullable: true }),
  "paymentSymbol": S.optionalWith(S.String, { nullable: true }),
  "paymentIsCryptocurrency": S.optionalWith(S.Boolean, { nullable: true }),
  "estimatedUnitPrice": S.optionalWith(S.Number, { nullable: true })
}) {}

export class B2BBrokerPreviewOrderResultApiResult extends S.Class<B2BBrokerPreviewOrderResultApiResult>("B2BBrokerPreviewOrderResultApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerPreviewOrderResult, { nullable: true })
}) {}

export class ApiV1TransactionsPreviewSide401 extends S.Struct({
  
}) {}

export class ApiV1TransactionsPreviewSide403 extends S.Struct({
  
}) {}

export class BrokerOrderCategory extends S.Literal("order", "trade", "ledger", "historyAction") {}

export class B2BBrokerOrderTrade extends S.Class<B2BBrokerOrderTrade>("B2BBrokerOrderTrade")({
  "tradeId": S.optionalWith(S.String, { nullable: true }),
  "amount": S.optionalWith(S.Number, { nullable: true }),
  "value": S.optionalWith(S.Number, { nullable: true }),
  "price": S.optionalWith(S.Number, { nullable: true }),
  "fee": S.optionalWith(S.Number, { nullable: true }),
  "orderCategory": S.optionalWith(S.Literal("order", "trade", "ledger", "historyAction"), { nullable: true })
}) {}

export class B2BBrokerCreateOrderResult extends S.Class<B2BBrokerCreateOrderResult>("B2BBrokerCreateOrderResult")({
  /**
* Id of the order, as returned from the financial institution. Can be used to get the status of the order.
*/
"orderId": S.optionalWith(S.String, { nullable: true }),
  /**
* Type of the institution.
*/
"brokerType": S.optionalWith(S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"), { nullable: true }),
  /**
* Side of the order.
*/
"side": S.optionalWith(S.Literal("unknown", "buy", "sell"), { nullable: true }),
  /**
* Amount of the order.
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Unit price of the asset.
*/
"price": S.optionalWith(S.Number, { nullable: true }),
  /**
* Total value of the order.
*/
"value": S.optionalWith(S.Number, { nullable: true }),
  /**
* Optional Fee taken by the financial institution.
*/
"fee": S.optionalWith(S.Number, { nullable: true }),
  /**
* Timestamp of the order.
*/
"timestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* Status of the order.
*/
"status": S.optionalWith(S.Literal("unknown", "inProgress", "cancelled", "rejected", "failed", "success", "partiallyFilled", "expired"), { nullable: true }),
  /**
* Text details of the order, if additionally returned from the financial institution.
*/
"statusDetails": S.optionalWith(S.String, { nullable: true }),
  /**
* Value that indicates how long the order will remain active before it is executed or expires.
*/
"timeInForce": S.optionalWith(BrokerOrderTimeInForceType, { nullable: true }),
  /**
* Optional pair of symbols, as returned from the financial institution. Can be required to obtain the status of the order by some institutions.
*/
"symbolPair": S.optionalWith(S.String, { nullable: true }),
  /**
* Id of the parent order, applicable to some institutions if the order was executed in several trades.
*/
"parentOrderId": S.optionalWith(S.String, { nullable: true }),
  /**
* List of trades, provided only if the order was executed in several trades.
*/
"trades": S.optionalWith(S.Array(B2BBrokerOrderTrade), { nullable: true }),
  /**
* A message describing the error if the order wasn't placed.
*/
"errorMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* A user-friendly display message that can be presented to the end user.
*/
"displayMessage": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerCreateOrderResultApiResult extends S.Class<B2BBrokerCreateOrderResultApiResult>("B2BBrokerCreateOrderResultApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerCreateOrderResult, { nullable: true })
}) {}

export class ApiV1TransactionsSide401 extends S.Struct({
  
}) {}

export class ApiV1TransactionsSide403 extends S.Struct({
  
}) {}

export class ApiV1TransactionsCancel401 extends S.Struct({
  
}) {}

export class ApiV1TransactionsCancel403 extends S.Struct({
  
}) {}

export class TransactionsB2BBrokerSymbolInfoForOrderRequest extends S.Class<TransactionsB2BBrokerSymbolInfoForOrderRequest>("TransactionsB2BBrokerSymbolInfoForOrderRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```CexIo```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```BitFlyer```
* ```Coinlist```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```Bybit```
* ```CoinbasePrime```
* ```RobinhoodConnect```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Symbol to trade. For example, `AAPL` or `ETH`
*/
"symbol": S.String.pipe(S.minLength(1)),
  /**
* Symbol to use for payment, defaults to `USD`.
*/
"paymentSymbol": S.String.pipe(S.minLength(1)),
  /**
* Amount of purchase.
*/
"amount": S.Number,
  /**
* Price of the unit, used for `Limit` and `StopLoss` orders.
*/
"price": S.optionalWith(S.Number, { nullable: true }),
  /**
* Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly.
*/
"isCryptocurrency": S.Boolean,
  /**
* Indicates whether the `PaymentSymbol` is fiat or cryptocurrency
*/
"paymentIsCryptocurrency": S.Boolean,
  "amountIsFiat": S.optionalWith(S.Boolean, { nullable: true }),
  "amountInFiat": S.optionalWith(S.Number, { nullable: true }),
  /**
* This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
* performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
* `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
* value is passed.
*/
"amountIsInPaymentSymbol": S.Boolean,
  /**
* Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
* and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
*/
"amountInPaymentSymbol": S.optionalWith(S.Number, { nullable: true }),
  /**
* Specifies if the extended trading hours should be used.
*/
"extendedHours": S.optionalWith(S.Boolean, { nullable: true }),
  "orderType": S.Literal("market", "limit", "stopLoss"),
  "timeInForce": S.Literal("goodTillCanceled", "immediateOrCancel", "fillOrKill", "goodForDay", "postOnly", "unknown"),
  /**
* MFA Code to create an order (requested by Kraken if MFA is enabled in user settings)
*/
"mfaCode": S.optionalWith(S.String, { nullable: true }),
  "side": S.optionalWith(BrokerOrderType, { nullable: true })
}) {}

export class SymbolTradingAllowance extends S.Literal("fractionalTradingAllowed", "fractionalTradingNotAllowed", "tradingNotAllowed", "fractionalTradingPossiblyAllowed") {}

export class B2BBrokerOrderSymbolInfo extends S.Class<B2BBrokerOrderSymbolInfo>("B2BBrokerOrderSymbolInfo")({
  /**
* Specifies if the fractional trading is allowed for the provided symbol
*/
"fractionalTradingAllowance": S.optionalWith(S.Literal("fractionalTradingAllowed", "fractionalTradingNotAllowed", "tradingNotAllowed", "fractionalTradingPossiblyAllowed"), { nullable: true }),
  /**
* Minimum allowed order value
*/
"minimumOrderValue": S.optionalWith(S.Number, { nullable: true }),
  /**
* Maximum number of decimal digits accepted by the symbol
*/
"precisionScale": S.optionalWith(S.Int, { nullable: true })
}) {}

export class B2BBrokerOrderSymbolInfoApiResult extends S.Class<B2BBrokerOrderSymbolInfoApiResult>("B2BBrokerOrderSymbolInfoApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerOrderSymbolInfo, { nullable: true })
}) {}

export class ApiV1TransactionsSymbolinfo401 extends S.Struct({
  
}) {}

export class TransfersBrokerTransactionsListRequest extends S.Class<TransfersBrokerTransactionsListRequest>("TransfersBrokerTransactionsListRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```BitfinexDirect```
* ```Bybit```
* ```Paxos```
* ```CoinbasePrime```
* ```BtcTurkDirect```
* ```ParibuDirect```
* ```RobinhoodConnect```
* ```BlockchainCom```
* ```BinanceConnect```
* ```RevolutConnect```
* ```BinancePay```
* ```ParibuOAuth```
* ```PayPalConnect```
* ```DeFiWallet```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Number of records to include in the response. 
* 
* Default: `100` 
* 
* Maximum: `250`
*/
"count": S.optionalWith(S.Int, { nullable: true }),
  /**
* The cursor to retrieve the next page of transactions.
* Providing it will cause the response to only return changes after this update.
* If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
*/
"cursor": S.optionalWith(S.String, { nullable: true }),
  /**
* If this value is provided, result set is filtered to only include transaction with the provided statuses.
*/
"statuses": S.optionalWith(S.Array(BrokerCryptocurrencyTransactionStatus), { nullable: true }),
  /**
* For cryptocurrency address the type of address is required.
*/
"cryptocurrencyAddressType": S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
  /**
* If this value is provided, result set is filtered to only include transactions created after this timestamp
*/
"from": S.optionalWith(S.Int, { nullable: true })
}) {}

export class BrokerCryptocurrencyTransactionType extends S.Literal("unknown", "deposit", "withdrawal") {}

export class BrokerCryptocurrencyTransactionNetworkFee extends S.Class<BrokerCryptocurrencyTransactionNetworkFee>("BrokerCryptocurrencyTransactionNetworkFee")({
  "gasPrice": S.optionalWith(S.Number, { nullable: true }),
  "gasUsed": S.optionalWith(S.Number, { nullable: true }),
  "amount": S.optionalWith(S.Number, { nullable: true }),
  "symbol": S.optionalWith(S.String, { nullable: true })
}) {}

export class BrokerCryptocurrencyTransactionBlockchainMethod extends S.Literal("transfer", "swap", "mint", "withdraw", "claimRewards", "deposit", "approve", "forgeToken", "multicall", "migrateToken", "claim", "openSeaTransfer", "cancel", "commit", "run", "repay", "execute", "stake", "merge") {}

export class B2BBrokerCryptocurrencyTransaction extends S.Class<B2BBrokerCryptocurrencyTransaction>("B2BBrokerCryptocurrencyTransaction")({
  /**
* Identifier of the transfer, if provided by the financial institution
*/
"id": S.optionalWith(S.String, { nullable: true }),
  /**
* Current status of the transaction
*/
"status": S.optionalWith(S.Literal("unknown", "failed", "frozen", "succeeded", "mfaRequired", "pending", "expired", "canceled", "waitingForSignature", "waitingForClearing", "awaitingApproval", "awaitingConfirmation", "awaitingVerification", "rejected", "pendingCancel", "emailVerification", "deviceConfirmationRequired", "mfaFailed", "addressWhitelistRequired", "secondMfaRequired", "emailConfirmationApprovalRequired", "travelRuleRequired"), { nullable: true }),
  /**
* Details of the current status of the transfer, as provided by the financial institution
*/
"statusDetails": S.optionalWith(S.String, { nullable: true }),
  /**
* The direction of the transaction
*/
"type": S.optionalWith(S.Literal("unknown", "deposit", "withdrawal"), { nullable: true }),
  /**
* Address where the transaction was sent from
*/
"fromAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Address where the transaction was sent to
*/
"targetAddress": S.optionalWith(S.String, { nullable: true }),
  /**
* Ticker of the transaction
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Crypto Chain the transaction belongs to
*/
"chain": S.optionalWith(S.String, { nullable: true }),
  /**
* Memo of the transaction (also called "Tag")
*/
"memo": S.optionalWith(S.String, { nullable: true }),
  /**
* Hash of the transaction
*/
"hash": S.optionalWith(S.String, { nullable: true }),
  /**
* Full amount affected the balance, typically transaction amount plus fee
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Transaction amount
*/
"transactionAmount": S.optionalWith(S.Number, { nullable: true }),
  /**
* Unix timestamp in seconds indicating when the transaction was created
*/
"createdTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* Unix timestamp in seconds indicating when the transaction was last updated
*/
"updatedTimestamp": S.optionalWith(S.Int, { nullable: true }),
  /**
* Fee taken by the network
*/
"networkTransactionFee": S.optionalWith(BrokerCryptocurrencyTransactionNetworkFee, { nullable: true }),
  /**
* Fee taken by the financial institution
*/
"transferFee": S.optionalWith(S.Number, { nullable: true }),
  /**
* Number of confirmations on the blockchain
*/
"confirmations": S.optionalWith(S.Int, { nullable: true }),
  /**
* Name of the executed blockchain function based on decoded input data
*/
"blockchainMethodName": S.optionalWith(S.String, { nullable: true }),
  /**
* Executed blockchain function based on decoded input data. Not guaranteed to be identified
*/
"blockchainMethod": S.optionalWith(S.Literal("transfer", "swap", "mint", "withdraw", "claimRewards", "deposit", "approve", "forgeToken", "multicall", "migrateToken", "claim", "openSeaTransfer", "cancel", "commit", "run", "repay", "execute", "stake", "merge"), { nullable: true })
}) {}

export class B2BBrokerTransactionsListModel extends S.Class<B2BBrokerTransactionsListModel>("B2BBrokerTransactionsListModel")({
  /**
* List of obtained transfers.
*/
"transfers": S.optionalWith(S.Array(B2BBrokerCryptocurrencyTransaction), { nullable: true }),
  /**
* Total amount of records.
*/
"total": S.optionalWith(S.Int, { nullable: true }),
  /**
* The cursor to retrieve the next page of transfers.
*/
"cursor": S.optionalWith(S.String, { nullable: true }),
  /**
* Earliest transfer timestamp.
*/
"earliestTimestamp": S.optionalWith(S.Int, { nullable: true })
}) {}

export class B2BBrokerTransactionsListModelApiResult extends S.Class<B2BBrokerTransactionsListModelApiResult>("B2BBrokerTransactionsListModelApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerTransactionsListModel, { nullable: true })
}) {}

export class ApiV1TransfersList401 extends S.Struct({
  
}) {}

export class ApiV1TransfersList403 extends S.Struct({
  
}) {}

export class TransfersBrokerCryptocurrencyTransactionDetailsRequest extends S.Class<TransfersBrokerCryptocurrencyTransactionDetailsRequest>("TransfersBrokerCryptocurrencyTransactionDetailsRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```BitfinexDirect```
* ```Bybit```
* ```Paxos```
* ```CoinbasePrime```
* ```BtcTurkDirect```
* ```ParibuDirect```
* ```RobinhoodConnect```
* ```BlockchainCom```
* ```BinanceConnect```
* ```RevolutConnect```
* ```BinancePay```
* ```ParibuOAuth```
* ```PayPalConnect```
* ```DeFiWallet```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Type of the address of the transferred asset. Can be used instead of the `Symbol` field.
*/
"addressType": S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
  /**
* Transaction Id by the financial institution
*/
"transactionId": S.optionalWith(S.String, { nullable: true }),
  /**
* Hash of the transaction on the blockchain
*/
"transactionHash": S.optionalWith(S.String, { nullable: true }),
  /**
* Symbol of the transferred asset. Can be provided instead of the `AddressType` field.
*/
"symbol": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerCryptocurrencyTransactionApiResult extends S.Class<B2BBrokerCryptocurrencyTransactionApiResult>("B2BBrokerCryptocurrencyTransactionApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerCryptocurrencyTransaction, { nullable: true })
}) {}

export class ApiV1TransfersDetails401 extends S.Struct({
  
}) {}

export class ApiV1TransfersDetails403 extends S.Struct({
  
}) {}

export class ClientType extends S.Literal("undefined", "wallet", "exchange", "vasp", "merchant", "other", "psp", "neobank", "iGaming", "aggregator") {}

export class TransferTravelRuleOptions extends S.Class<TransferTravelRuleOptions>("TransferTravelRuleOptions")({
  "transferType": S.optionalWith(TransferTypeEnum, { nullable: true }),
  "clientName": S.optionalWith(S.String, { nullable: true }),
  "clientType": S.optionalWith(S.Literal("undefined", "wallet", "exchange", "vasp", "merchant", "other", "psp", "neobank", "iGaming", "aggregator"), { nullable: true }),
  "clientId": S.optionalWith(S.String, { nullable: true })
}) {}

export class TransfersBrokerCreateCryptocurrencyTransactionRequest extends S.Class<TransfersBrokerCreateCryptocurrencyTransactionRequest>("TransfersBrokerCreateCryptocurrencyTransactionRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```BitfinexDirect```
* ```Bybit```
* ```Paxos```
* ```CoinbasePrime```
* ```BtcTurkDirect```
* ```ParibuDirect```
* ```RobinhoodConnect```
* ```BlockchainCom```
* ```BinanceConnect```
* ```RevolutConnect```
* ```BinancePay```
* ```ParibuOAuth```
* ```PayPalConnect```
* ```DeFiWallet```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Additional data to send on-chain (optional, depends on an integration)
*/
"data": S.optionalWith(S.String, { nullable: true }),
  /**
* Target address to transfer the asset to
*/
"targetAddress": S.String.pipe(S.minLength(1)),
  /**
* Amount to transfer
*/
"amount": S.optionalWith(S.Number, { nullable: true }),
  /**
* On-chain fee (optional, depends on an integration)
*/
"fee": S.optionalWith(S.Number, { nullable: true }),
  /**
* Type of the address of symbol to be transferred. Providing `EthAddress` will initiate a transfer of ETH over Ethereum blockchain.
* Can be used instead of `Symbol` and `Chain` fields.
* To transfer assets over non-default chains (e.g. sending USDT over ERC20) please `Symbol` and `Chain` fields.
*/
"addressType": S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
  /**
* 2 Factor auth code (optional, depends on an integration)
*/
"mfaCode": S.optionalWith(S.String, { nullable: true }),
  /**
* Travel rule transaction id (optional, depends on an integration)
*/
"travelRuleTransactionId": S.optionalWith(S.Int, { nullable: true }),
  /**
* 2 Factor auth type (optional, depends on an integration)
*/
"mfaType": S.optionalWith(MfaType, { nullable: true }),
  "verificationSteps": S.optionalWith(S.Array(MfaType), { nullable: true }),
  /**
* Password or pass-phrase, required to send transfers (optional, depends on an integration)
*/
"password": S.optionalWith(S.String, { nullable: true }),
  /**
* Custom chain name, required by some of the integrations. E.g. USDT can be sent over USDT-ERC20, USDT-TRC20, and USDT-Omni.
* Can be used to transfer assets over non-default chains (e.g. sending USDT over ERC20).
* Please use `symbol/details` endpoint to get the list of all possible chains.
*/
"chain": S.optionalWith(S.String, { nullable: true }),
  /**
* Memo (also called "Tag") - address remark.
*/
"memo": S.optionalWith(S.String, { nullable: true }),
  /**
* Symbol to be transferred. Can be provided instead of the `AddressType` field.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  "challengeId": S.optionalWith(S.String, { nullable: true }),
  "tryAnotherMfa": S.optionalWith(S.Boolean, { nullable: true }),
  "travelRuleOptions": S.optionalWith(TransferTravelRuleOptions, { nullable: true })
}) {}

export class B2BBrokerCreateCryptocurrencyTransactionResponse extends S.Class<B2BBrokerCreateCryptocurrencyTransactionResponse>("B2BBrokerCreateCryptocurrencyTransactionResponse")({
  /**
* Transaction Id by the financial institution
*/
"transactionId": S.optionalWith(S.String, { nullable: true }),
  "failed": S.optionalWith(S.Boolean, { nullable: true }),
  "mfaType": S.optionalWith(MfaType, { nullable: true }),
  "verificationSteps": S.optionalWith(S.Array(MfaType), { nullable: true }),
  "qrCode": S.optionalWith(S.String, { nullable: true }),
  "qrCodeLink": S.optionalWith(S.String, { nullable: true }),
  /**
* Status of the operation
*/
"status": S.optionalWith(S.Literal("unknown", "failed", "frozen", "succeeded", "mfaRequired", "pending", "expired", "canceled", "waitingForSignature", "waitingForClearing", "awaitingApproval", "awaitingConfirmation", "awaitingVerification", "rejected", "pendingCancel", "emailVerification", "deviceConfirmationRequired", "mfaFailed", "addressWhitelistRequired", "secondMfaRequired", "emailConfirmationApprovalRequired", "travelRuleRequired"), { nullable: true }),
  /**
* Details of the current status of the transfer, as provided by the financial institution
*/
"statusDetails": S.optionalWith(S.String, { nullable: true }),
  /**
* Details of the created transaction
*/
"transaction": S.optionalWith(B2BBrokerCryptocurrencyTransaction, { nullable: true }),
  "fallbackMfaAvailable": S.optionalWith(S.Boolean, { nullable: true }),
  "challengeId": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerCreateCryptocurrencyTransactionResponseApiResult extends S.Class<B2BBrokerCreateCryptocurrencyTransactionResponseApiResult>("B2BBrokerCreateCryptocurrencyTransactionResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerCreateCryptocurrencyTransactionResponse, { nullable: true })
}) {}

export class ApiV1Transfers401 extends S.Struct({
  
}) {}

export class ApiV1Transfers403 extends S.Struct({
  
}) {}

export class TransfersBrokerCryptocurrencyDepositAddressRequest extends S.Class<TransfersBrokerCryptocurrencyDepositAddressRequest>("TransfersBrokerCryptocurrencyDepositAddressRequest")({
  /**
* Auth token that allows connecting to the target institution
*/
"authToken": S.String.pipe(S.minLength(1)),
  /**
* Type of the institution to connect
* 
* ### Supported integrations:
* ```Robinhood```
* ```Coinbase```
* ```Kraken```
* ```CryptoCom```
* ```Binance```
* ```Gemini```
* ```OkCoin```
* ```KuCoin```
* ```BinanceInternational```
* ```Bitstamp```
* ```GateIo```
* ```Okx```
* ```Huobi```
* ```Bitfinex```
* ```KrakenDirect```
* ```BinanceInternationalDirect```
* ```BitfinexDirect```
* ```Bybit```
* ```Paxos```
* ```CoinbasePrime```
* ```BtcTurkDirect```
* ```ParibuDirect```
* ```RobinhoodConnect```
* ```BlockchainCom```
* ```BinanceConnect```
* ```RevolutConnect```
* ```BinancePay```
* ```ParibuOAuth```
* ```PayPalConnect```
* ```DeFiWallet```
*/
"type": S.Literal("robinhood", "eTrade", "alpaca", "tdAmeritrade", "weBull", "stash", "interactiveBrokers", "public", "coinbase", "kraken", "coinbasePro", "cryptoCom", "openSea", "binanceUs", "gemini", "cryptocurrencyAddress", "cryptocurrencyWallet", "okCoin", "bittrex", "kuCoin", "etoro", "cexIo", "binanceInternational", "bitstamp", "gateIo", "acorns", "okx", "bitFlyer", "coinlist", "huobi", "bitfinex", "deFiWallet", "krakenDirect", "vanguard", "binanceInternationalDirect", "bitfinexDirect", "bybit", "paxos", "coinbasePrime", "btcTurkDirect", "kuCoinDirect", "okxOAuth", "paribuDirect", "robinhoodConnect", "blockchainCom", "bitsoDirect", "binanceConnect", "binanceOAuth", "revolutConnect", "binancePay", "bybitDirect", "paribuOAuth", "payPalConnect", "binanceTrDirect", "coinbaseRamp", "bybitDirectMobile"),
  /**
* Symbol of the required cryptocurrency, e.g. ETH or BTC.
* Can be used instead of the `AddressType` field.
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.
* Can be used instead of `Symbol` field.
*/
"addressType": S.optionalWith(CryptocurrencyAddressType, { nullable: true }),
  /**
* Chain of the required cryptocurrency, e.g. USDT has USDT-ERC20, USDT-TRC20, and USDT-Omni
*/
"chain": S.optionalWith(S.String, { nullable: true }),
  /**
* Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect
*/
"mfaCode": S.optionalWith(S.String, { nullable: true })
}) {}

export class ApiV1TransfersAddressGet401 extends S.Struct({
  
}) {}

export class BrokerCryptocurrencyChain extends S.Class<BrokerCryptocurrencyChain>("BrokerCryptocurrencyChain")({
  /**
* Name of the chain, should be provided when initiating a transfer
*/
"chain": S.optionalWith(S.String, { nullable: true }),
  "feeDescription": S.optionalWith(S.String, { nullable: true }),
  /**
* Notes or tips provided by the integration
*/
"notes": S.optionalWith(S.String, { nullable: true }),
  "fee": S.optionalWith(S.Number, { nullable: true }),
  "minWithdrawAmount": S.optionalWith(S.Number, { nullable: true }),
  "maxWithdrawAmount": S.optionalWith(S.Number, { nullable: true }),
  "networkId": S.optionalWith(S.String, { nullable: true })
}) {}

export class B2BBrokerCryptocurrencySymbolDetailsResponse extends S.Class<B2BBrokerCryptocurrencySymbolDetailsResponse>("B2BBrokerCryptocurrencySymbolDetailsResponse")({
  /**
* Requested symbol
*/
"symbol": S.optionalWith(S.String, { nullable: true }),
  /**
* Supported address types
*/
"addressTypes": S.optionalWith(S.Array(CryptocurrencyAddressType), { nullable: true }),
  /**
* Supported chains. One of the values should be provided to execute transfers
*/
"chains": S.optionalWith(S.Array(BrokerCryptocurrencyChain), { nullable: true })
}) {}

export class B2BBrokerCryptocurrencySymbolDetailsResponseApiResult extends S.Class<B2BBrokerCryptocurrencySymbolDetailsResponseApiResult>("B2BBrokerCryptocurrencySymbolDetailsResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  "content": S.optionalWith(B2BBrokerCryptocurrencySymbolDetailsResponse, { nullable: true })
}) {}

export class ApiV1TransfersSymbolDetails401 extends S.Struct({
  
}) {}

export class ApiV1WalletsVerifyParams extends S.Struct({
  "UserId": S.optionalWith(S.String, { nullable: true }),
  "Address": S.optionalWith(S.String, { nullable: true })
}) {}

/**
* Verifications data.
*/
export class DeFiWalletVerification extends S.Class<DeFiWalletVerification>("DeFiWalletVerification")({
  /**
* User identifier.
*/
"userId": S.optionalWith(S.String, { nullable: true }),
  /**
* Wallet address.
*/
"address": S.optionalWith(S.String, { nullable: true }),
  /**
* Wallet Xpub key for Bitcon wallets.
*/
"xPubKey": S.optionalWith(S.String, { nullable: true }),
  /**
* Wallet network type.
*/
"networkType": S.optionalWith(S.Literal("unknown", "evm", "solana", "bitcoin", "cardano", "tron", "avalancheX", "tezos", "dogecoin", "ripple", "stellar", "litecoin", "sui", "aptos", "tvm", "injective"), { nullable: true }),
  /**
* Verification method.
*/
"verificationMethod": S.optionalWith(S.Literal("signedMessage"), { nullable: true }),
  /**
* Original message.
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* Message signature.
*/
"signedMessageHash": S.optionalWith(S.String, { nullable: true }),
  /**
* Verification created timestamp.
*/
"timestamp": S.optionalWith(S.Int, { nullable: true })
}) {}

/**
* Verifications response.
*/
export class DeFiWalletVerificationResponse extends S.Class<DeFiWalletVerificationResponse>("DeFiWalletVerificationResponse")({
  /**
* List of found verifications.
*/
"verifications": S.optionalWith(S.Array(DeFiWalletVerification), { nullable: true })
}) {}

export class DeFiWalletVerificationResponseApiResult extends S.Class<DeFiWalletVerificationResponseApiResult>("DeFiWalletVerificationResponseApiResult")({
  "status": S.optionalWith(S.Literal("ok", "serverFailure", "permissionDenied", "badRequest", "notFound", "conflict", "tooManyRequest", "locked", "unavailableForLegalReasons"), { nullable: true }),
  /**
* A message generated by the API
*/
"message": S.optionalWith(S.String, { nullable: true }),
  /**
* User-friendly display message that can be presented to the end user
*/
"displayMessage": S.optionalWith(S.String, { nullable: true }),
  /**
* Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
* All possible error types are available in the documentation.
*/
"errorType": S.optionalWith(S.String, { nullable: true }),
  /**
* Verifications response.
*/
"content": S.optionalWith(DeFiWalletVerificationResponse, { nullable: true })
}) {}

export class ApiV1WalletsVerify401 extends S.Struct({
  
}) {}

export const make = (
  httpClient: HttpClient.HttpClient, 
  options: {
    readonly transformClient?: ((client: HttpClient.HttpClient) => Effect.Effect<HttpClient.HttpClient>) | undefined
  } = {}
): Client => {
  const unexpectedStatus = (response: HttpClientResponse.HttpClientResponse) =>
    Effect.flatMap(
      Effect.orElseSucceed(response.json, () => "Unexpected status code"),
      (description) =>
        Effect.fail(
          new HttpClientError.ResponseError({
            request: response.request,
            response,
            reason: "StatusCode",
            description: typeof description === "string" ? description : JSON.stringify(description),
          }),
        ),
    )
  const withResponse: <A, E>(
    f: (response: HttpClientResponse.HttpClientResponse) => Effect.Effect<A, E>,
  ) => (
    request: HttpClientRequest.HttpClientRequest,
  ) => Effect.Effect<any, any> = options.transformClient
    ? (f) => (request) =>
        Effect.flatMap(
          Effect.flatMap(options.transformClient!(httpClient), (client) =>
            client.execute(request),
          ),
          f,
        )
    : (f) => (request) => Effect.flatMap(httpClient.execute(request), f)
  const decodeSuccess =
    <A, I, R>(schema: S.Schema<A, I, R>) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      HttpClientResponse.schemaBodyJson(schema)(response)
  const decodeError =
    <const Tag extends string, A, I, R>(tag: Tag, schema: S.Schema<A, I, R>) =>
    (response: HttpClientResponse.HttpClientResponse) =>
      Effect.flatMap(
        HttpClientResponse.schemaBodyJson(schema)(response),
        (cause) => Effect.fail(ClientError(tag, cause, response)),
      )
  return {
    httpClient,
    "POST/api/v1/account/verify": (options) => HttpClientRequest.post(`/api/v1/account/verify`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerAccountDetailsResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1AccountVerify401", ApiV1AccountVerify401),
      "403": decodeError("ApiV1AccountVerify403", ApiV1AccountVerify403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/exchange/verify": (options) => HttpClientRequest.post(`/api/v1/exchange/verify`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerAccountDetailsResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1ExchangeVerify401", ApiV1ExchangeVerify401),
      "403": decodeError("ApiV1ExchangeVerify403", ApiV1ExchangeVerify403),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/assets/{assetType}": (assetType, options) => HttpClientRequest.get(`/api/v1/assets/${assetType}`).pipe(
    HttpClientRequest.setUrlParams({ "Search": options?.["Search"] as any, "Count": options?.["Count"] as any, "Offset": options?.["Offset"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(AssetPaginationResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1AssetsAssetType401", ApiV1AssetsAssetType401),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/balance/get": (options) => HttpClientRequest.post(`/api/v1/balance/get`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerAccountBalanceModelApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1BalanceGet401", ApiV1BalanceGet401),
      "403": decodeError("ApiV1BalanceGet403", ApiV1BalanceGet403),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/balance/portfolio": (options) => HttpClientRequest.get(`/api/v1/balance/portfolio`).pipe(
    HttpClientRequest.setUrlParams({ "UserId": options?.["UserId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BFiatPortfolioModelApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1BalancePortfolio401", ApiV1BalancePortfolio401),
      "403": decodeError("ApiV1BalancePortfolio403", ApiV1BalancePortfolio403),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/cataloglink": (options) => HttpClientRequest.get(`/api/v1/cataloglink`).pipe(
    HttpClientRequest.setUrlParams({ "UserId": options?.["UserId"] as any, "BrokerType": options?.["BrokerType"] as any, "EnableTransfers": options?.["EnableTransfers"] as any, "RestrictMultipleAccounts": options?.["RestrictMultipleAccounts"] as any, "DisableApiKeyGeneration": options?.["DisableApiKeyGeneration"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CatalogLinkApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1Cataloglink401", ApiV1Cataloglink401),
      "404": decodeError("ApiResult", ApiResult),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/cataloglink": (options) => HttpClientRequest.post(`/api/v1/cataloglink`).pipe(
    HttpClientRequest.setUrlParams({ "UserId": options.params?.["UserId"] as any, "BrokerType": options.params?.["BrokerType"] as any, "EnableTransfers": options.params?.["EnableTransfers"] as any, "RestrictMultipleAccounts": options.params?.["RestrictMultipleAccounts"] as any, "DisableApiKeyGeneration": options.params?.["DisableApiKeyGeneration"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(CatalogLinkApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1Cataloglink401", ApiV1Cataloglink401),
      "404": decodeError("ApiResult", ApiResult),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/linktoken": (options) => HttpClientRequest.post(`/api/v1/linktoken`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(LinkTokenModelApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1Linktoken401", ApiV1Linktoken401),
      "404": decodeError("ApiResult", ApiResult),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/token/refresh": (options) => HttpClientRequest.post(`/api/v1/token/refresh`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerRefreshTokenResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TokenRefresh401", ApiV1TokenRefresh401),
      orElse: unexpectedStatus
    }))
  ),
  "DELETE/api/v1/account": (options) => HttpClientRequest.del(`/api/v1/account`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1Account401", ApiV1Account401),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/status": () => HttpClientRequest.get(`/api/v1/status`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokersHealthStatusListApiResult),
      "401": decodeError("ApiV1Status401", ApiV1Status401),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/authenticationSchemes": () => HttpClientRequest.get(`/api/v1/authenticationSchemes`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(BrokerAuthenticationSchemeIReadOnlyCollectionApiResult),
      "401": decodeError("ApiV1AuthenticationSchemes401", ApiV1AuthenticationSchemes401),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/authenticate": (options) => HttpClientRequest.post(`/api/v1/authenticate`).pipe(
    HttpClientRequest.setUrlParams({ "userId": options.params?.["userId"] as any }),
    HttpClientRequest.bodyUnsafeJson(options.payload),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerAuthResponseApiResult),
      "400": decodeError("ProblemDetails", ProblemDetails),
      "500": () => Effect.void,
      "503": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/authenticate/{brokerType}": (brokerType, options) => HttpClientRequest.get(`/api/v1/authenticate/${brokerType}`).pipe(
    HttpClientRequest.setUrlParams({ "userId": options?.["userId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerAuthPromptResponseApiResult),
      "400": decodeError("ProblemDetails", ProblemDetails),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/integrations": () => HttpClientRequest.get(`/api/v1/integrations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(IntegrationsResponseApiResult),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/transfers/managed/networks": () => HttpClientRequest.get(`/api/v1/transfers/managed/networks`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(NetworkModelResponseApiResult),
      "401": decodeError("ApiV1TransfersManagedNetworks401", ApiV1TransfersManagedNetworks401),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/transfers/managed/integrations": () => HttpClientRequest.get(`/api/v1/transfers/managed/integrations`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(IntegrationNetworkResponseApiResult),
      "401": decodeError("ApiV1TransfersManagedIntegrations401", ApiV1TransfersManagedIntegrations401),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/transfers/managed/tokens": () => HttpClientRequest.get(`/api/v1/transfers/managed/tokens`).pipe(
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(TokenNetworksResponseApiResult),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/transfers/managed/verify": (options) => HttpClientRequest.get(`/api/v1/transfers/managed/verify`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(TransferVerificationResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersManagedVerify401", ApiV1TransfersManagedVerify401),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/managed/configure": (options) => HttpClientRequest.post(`/api/v1/transfers/managed/configure`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ConfigureTransferResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersManagedConfigure401", ApiV1TransfersManagedConfigure401),
      "403": decodeError("ApiV1TransfersManagedConfigure403", ApiV1TransfersManagedConfigure403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/managed/preview": (options) => HttpClientRequest.post(`/api/v1/transfers/managed/preview`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(PreviewTransferResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersManagedPreview401", ApiV1TransfersManagedPreview401),
      "403": decodeError("ApiV1TransfersManagedPreview403", ApiV1TransfersManagedPreview403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/managed/execute": (options) => HttpClientRequest.post(`/api/v1/transfers/managed/execute`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ExecuteTransferResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersManagedExecute401", ApiV1TransfersManagedExecute401),
      "403": decodeError("ApiV1TransfersManagedExecute403", ApiV1TransfersManagedExecute403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/managed/address/get": (options) => HttpClientRequest.post(`/api/v1/transfers/managed/address/get`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerCryptocurrencyDepositAddressResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersManagedAddressGet401", ApiV1TransfersManagedAddressGet401),
      "404": decodeError("ApiResult", ApiResult),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/managed/quote": (options) => HttpClientRequest.post(`/api/v1/transfers/managed/quote`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(QuoteTransferResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersManagedQuote401", ApiV1TransfersManagedQuote401),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/transfers/managed/mesh": (options) => HttpClientRequest.get(`/api/v1/transfers/managed/mesh`).pipe(
    HttpClientRequest.setUrlParams({ "Count": options?.["Count"] as any, "Offset": options?.["Offset"] as any, "Id": options?.["Id"] as any, "ClientTransactionId": options?.["ClientTransactionId"] as any, "UserId": options?.["UserId"] as any, "IntegrationIds": options?.["IntegrationIds"] as any, "Statuses": options?.["Statuses"] as any, "FromTimestamp": options?.["FromTimestamp"] as any, "ToTimestamp": options?.["ToTimestamp"] as any, "MinAmountInFiat": options?.["MinAmountInFiat"] as any, "MaxAmountInFiat": options?.["MaxAmountInFiat"] as any, "OrderBy": options?.["OrderBy"] as any, "Hash": options?.["Hash"] as any, "SubClientId": options?.["SubClientId"] as any, "DescendingOrder": options?.["DescendingOrder"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(TransferModelPaginationResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersManagedMesh401", ApiV1TransfersManagedMesh401),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/managed/update": (options) => HttpClientRequest.post(`/api/v1/transfers/managed/update`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(UpdateTransferResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersManagedUpdate401", ApiV1TransfersManagedUpdate401),
      "403": decodeError("ApiV1TransfersManagedUpdate403", ApiV1TransfersManagedUpdate403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/holdings/get": (options) => HttpClientRequest.post(`/api/v1/holdings/get`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(HoldingsModelApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1HoldingsGet401", ApiV1HoldingsGet401),
      "403": decodeError("ApiV1HoldingsGet403", ApiV1HoldingsGet403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/holdings/value": (options) => HttpClientRequest.post(`/api/v1/holdings/value`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(BrokerPortfolioValueModelApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1HoldingsValue401", ApiV1HoldingsValue401),
      "403": decodeError("ApiV1HoldingsValue403", ApiV1HoldingsValue403),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/holdings/portfolio": (options) => HttpClientRequest.get(`/api/v1/holdings/portfolio`).pipe(
    HttpClientRequest.setUrlParams({ "UserId": options?.["UserId"] as any, "TimezoneOffset": options?.["TimezoneOffset"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BPortfolioModelApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1HoldingsPortfolio401", ApiV1HoldingsPortfolio401),
      "403": decodeError("ApiV1HoldingsPortfolio403", ApiV1HoldingsPortfolio403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/catalog/solana/getLatestBlockhash": (options) => HttpClientRequest.post(`/api/v1/catalog/solana/getLatestBlockhash`).pipe(
    HttpClientRequest.setUrlParams({ "chainId": options?.["chainId"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(StringApiResult),
      "400": decodeError("ProblemDetails", ProblemDetails),
      "500": () => Effect.void,
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transactions/list": (options) => HttpClientRequest.post(`/api/v1/transactions/list`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerOrderListResponseApiResult),
      "401": decodeError("ApiV1TransactionsList401", ApiV1TransactionsList401),
      "403": decodeError("ApiV1TransactionsList403", ApiV1TransactionsList403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transactions/details": (options) => HttpClientRequest.post(`/api/v1/transactions/details`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerOrderApiResult),
      "400": decodeError("ProblemDetails", ProblemDetails),
      "401": decodeError("ApiV1TransactionsDetails401", ApiV1TransactionsDetails401),
      "403": decodeError("ApiV1TransactionsDetails403", ApiV1TransactionsDetails403),
      "404": decodeError("ProblemDetails", ProblemDetails),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transactions/featureList": (options) => HttpClientRequest.post(`/api/v1/transactions/featureList`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerTradingFeatureInfoApiResult),
      "400": decodeError("ProblemDetails", ProblemDetails),
      "401": decodeError("ApiV1TransactionsFeatureList401", ApiV1TransactionsFeatureList401),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transactions/preview/{side}": (side, options) => HttpClientRequest.post(`/api/v1/transactions/preview/${side}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerPreviewOrderResultApiResult),
      "400": decodeError("ProblemDetails", ProblemDetails),
      "401": decodeError("ApiV1TransactionsPreviewSide401", ApiV1TransactionsPreviewSide401),
      "403": decodeError("ApiV1TransactionsPreviewSide403", ApiV1TransactionsPreviewSide403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transactions/{side}": (side, options) => HttpClientRequest.post(`/api/v1/transactions/${side}`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerCreateOrderResultApiResult),
      "400": decodeError("ProblemDetails", ProblemDetails),
      "401": decodeError("ApiV1TransactionsSide401", ApiV1TransactionsSide401),
      "403": decodeError("ApiV1TransactionsSide403", ApiV1TransactionsSide403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transactions/cancel": (options) => HttpClientRequest.post(`/api/v1/transactions/cancel`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(ApiResult),
      "400": decodeError("ProblemDetails", ProblemDetails),
      "401": decodeError("ApiV1TransactionsCancel401", ApiV1TransactionsCancel401),
      "403": decodeError("ApiV1TransactionsCancel403", ApiV1TransactionsCancel403),
      "404": decodeError("ProblemDetails", ProblemDetails),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transactions/symbolinfo": (options) => HttpClientRequest.post(`/api/v1/transactions/symbolinfo`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerOrderSymbolInfoApiResult),
      "400": decodeError("ProblemDetails", ProblemDetails),
      "401": decodeError("ApiV1TransactionsSymbolinfo401", ApiV1TransactionsSymbolinfo401),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/list": (options) => HttpClientRequest.post(`/api/v1/transfers/list`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerTransactionsListModelApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersList401", ApiV1TransfersList401),
      "403": decodeError("ApiV1TransfersList403", ApiV1TransfersList403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/details": (options) => HttpClientRequest.post(`/api/v1/transfers/details`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerCryptocurrencyTransactionApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersDetails401", ApiV1TransfersDetails401),
      "403": decodeError("ApiV1TransfersDetails403", ApiV1TransfersDetails403),
      "404": decodeError("ApiResult", ApiResult),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers": (options) => HttpClientRequest.post(`/api/v1/transfers`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerCreateCryptocurrencyTransactionResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1Transfers401", ApiV1Transfers401),
      "403": decodeError("ApiV1Transfers403", ApiV1Transfers403),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/address/get": (options) => HttpClientRequest.post(`/api/v1/transfers/address/get`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerCryptocurrencyDepositAddressResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersAddressGet401", ApiV1TransfersAddressGet401),
      "404": decodeError("ApiResult", ApiResult),
      orElse: unexpectedStatus
    }))
  ),
  "POST/api/v1/transfers/symbol/details": (options) => HttpClientRequest.post(`/api/v1/transfers/symbol/details`).pipe(
    HttpClientRequest.bodyUnsafeJson(options),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(B2BBrokerCryptocurrencySymbolDetailsResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1TransfersSymbolDetails401", ApiV1TransfersSymbolDetails401),
      "404": decodeError("ApiResult", ApiResult),
      orElse: unexpectedStatus
    }))
  ),
  "GET/api/v1/wallets/verify": (options) => HttpClientRequest.get(`/api/v1/wallets/verify`).pipe(
    HttpClientRequest.setUrlParams({ "UserId": options?.["UserId"] as any, "Address": options?.["Address"] as any }),
    withResponse(HttpClientResponse.matchStatus({
      "2xx": decodeSuccess(DeFiWalletVerificationResponseApiResult),
      "400": decodeError("ApiResult", ApiResult),
      "401": decodeError("ApiV1WalletsVerify401", ApiV1WalletsVerify401),
      orElse: unexpectedStatus
    }))
  )
  }
}

export interface Client {
  readonly httpClient: HttpClient.HttpClient
  /**
* Return KYC details of the user.
*/
readonly "POST/api/v1/account/verify": (options: typeof B2BBrokerAccountDetailsRequest.Encoded) => Effect.Effect<typeof B2BBrokerAccountDetailsResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1AccountVerify401", typeof ApiV1AccountVerify401.Type> | ClientError<"ApiV1AccountVerify403", typeof ApiV1AccountVerify403.Type>>
  /**
* Returns basic profile data of the user's exchange account.
* Available data varies by exchange and linked account.
*/
readonly "POST/api/v1/exchange/verify": (options: typeof ExchangeAccountInfoRequest.Encoded) => Effect.Effect<typeof B2BBrokerAccountDetailsResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1ExchangeVerify401", typeof ApiV1ExchangeVerify401.Type> | ClientError<"ApiV1ExchangeVerify403", typeof ApiV1ExchangeVerify403.Type>>
  /**
* Get available assets
*/
readonly "GET/api/v1/assets/{assetType}": (assetType: string, options?: typeof ApiV1AssetsAssetTypeParams.Encoded | undefined) => Effect.Effect<typeof AssetPaginationResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1AssetsAssetType401", typeof ApiV1AssetsAssetType401.Type>>
  /**
* Get real-time account fiat balances.
*/
readonly "POST/api/v1/balance/get": (options: typeof BalanceBrokerBaseRequest.Encoded) => Effect.Effect<typeof B2BBrokerAccountBalanceModelApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1BalanceGet401", typeof ApiV1BalanceGet401.Type> | ClientError<"ApiV1BalanceGet403", typeof ApiV1BalanceGet403.Type>>
  /**
* Get cached aggregated fiat balances from all connected integrations.
*/
readonly "GET/api/v1/balance/portfolio": (options?: typeof ApiV1BalancePortfolioParams.Encoded | undefined) => Effect.Effect<typeof B2BFiatPortfolioModelApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1BalancePortfolio401", typeof ApiV1BalancePortfolio401.Type> | ClientError<"ApiV1BalancePortfolio403", typeof ApiV1BalancePortfolio403.Type>>
  /**
* Get personalized catalog link for client
*/
readonly "GET/api/v1/cataloglink": (options: typeof ApiV1CataloglinkParams.Encoded) => Effect.Effect<typeof CatalogLinkApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1Cataloglink401", typeof ApiV1Cataloglink401.Type> | ClientError<"ApiResult", typeof ApiResult.Type>>
  /**
* Get personalized catalog link for client supplying parameters for Link actions, such as transfers
*/
readonly "POST/api/v1/cataloglink": (options: { readonly params: typeof ApiV1CataloglinkParams.Encoded; readonly payload: typeof InitializeTransfersForLinkRequest.Encoded }) => Effect.Effect<typeof CatalogLinkApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1Cataloglink401", typeof ApiV1Cataloglink401.Type> | ClientError<"ApiResult", typeof ApiResult.Type>>
  /**
* Get a short lived, one-time use token for initializing a Link session using the client-side SDKs
*/
readonly "POST/api/v1/linktoken": (options: typeof GetLinkTokenRequest.Encoded) => Effect.Effect<typeof LinkTokenModelApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1Linktoken401", typeof ApiV1Linktoken401.Type> | ClientError<"ApiResult", typeof ApiResult.Type>>
  /**
* Refresh auth token of the connected institution.
* Some institutions do not require tokens to be refreshed.
*             
* The following institutions require custom flows:
*             
* WeBull: AuthToken should be provided along with the RefreshToken
*             
* Vanguard: security settings may activate MFA, requiring user action.
* If MFA is triggered, a second refresh request should be sent.
* Second request should contain MFA code and access token obtained from initial response
*/
readonly "POST/api/v1/token/refresh": (options: typeof BrokerRefreshTokenRequest.Encoded) => Effect.Effect<typeof B2BBrokerRefreshTokenResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TokenRefresh401", typeof ApiV1TokenRefresh401.Type>>
  /**
* Remove connection to the financial institution and erase all related data completely.
*/
readonly "DELETE/api/v1/account": (options: typeof BrokerBaseRequest.Encoded) => Effect.Effect<typeof ApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1Account401", typeof ApiV1Account401.Type>>
  /**
* Get the list of supported institutions and their health statuses.
*/
readonly "GET/api/v1/status": () => Effect.Effect<typeof B2BBrokersHealthStatusListApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiV1Status401", typeof ApiV1Status401.Type>>
  /**
* Get authentication schemes of available integrations to perform authentication programmatically (not using
* the Web Catalog UI).
*/
readonly "GET/api/v1/authenticationSchemes": () => Effect.Effect<typeof BrokerAuthenticationSchemeIReadOnlyCollectionApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiV1AuthenticationSchemes401", typeof ApiV1AuthenticationSchemes401.Type>>
  /**
* Authenticate user's brokerage/exchange account programmatically (not using the Web Catalog UI)
*/
readonly "POST/api/v1/authenticate": (options: { readonly params: typeof ApiV1AuthenticateParams.Encoded; readonly payload: typeof B2BBrokerAuthRequest.Encoded }) => Effect.Effect<typeof B2BBrokerAuthResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type>>
  /**
* Get OAuth link for the integrations with `OAuth` AuthenticationSchemeType
*/
readonly "GET/api/v1/authenticate/{brokerType}": (brokerType: string, options: typeof ApiV1AuthenticateBrokerTypeParams.Encoded) => Effect.Effect<typeof B2BBrokerAuthPromptResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type>>
  /**
* Returns a list of integrations with details including the integration ID, name, type,
* DeFi wallet provider ID, and categories.
*/
readonly "GET/api/v1/integrations": () => Effect.Effect<typeof IntegrationsResponseApiResult.Type, HttpClientError.HttpClientError | ParseError>
  /**
* **Get supported networks list.**
* 
* 
* ---
* Get the list of all networks supported by Mesh to perform transfers, including which tokens and integrations are supported.
*/
readonly "GET/api/v1/transfers/managed/networks": () => Effect.Effect<typeof NetworkModelResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiV1TransfersManagedNetworks401", typeof ApiV1TransfersManagedNetworks401.Type>>
  /**
* **Get supported integrations list.**
* 
* 
* ---
* Get the list of all integrations supported by Mesh to perform transfers, including which tokens and networks are supported.
*/
readonly "GET/api/v1/transfers/managed/integrations": () => Effect.Effect<typeof IntegrationNetworkResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiV1TransfersManagedIntegrations401", typeof ApiV1TransfersManagedIntegrations401.Type>>
  /**
* Get the list of all tokens supported by Mesh to perform transfers, including which networks and integrations are supported.
*/
readonly "GET/api/v1/transfers/managed/tokens": () => Effect.Effect<typeof TokenNetworksResponseApiResult.Type, HttpClientError.HttpClientError | ParseError>
  /**
* Checks if the combination of integration ID, network ID, token is correct for transfer.
* Checks if the target address is in the correct format.
*/
readonly "GET/api/v1/transfers/managed/verify": (options: typeof TransferVerificationRequest.Encoded) => Effect.Effect<typeof TransferVerificationResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersManagedVerify401", typeof ApiV1TransfersManagedVerify401.Type>>
  /**
* **Get the list of networks and tokens eligible for a transfer, based on the provided request data.**
* 
* 
* ---
* Transfers can be configured either from one connected account to another connected account, or
* from a connected account to any arbitrary address or addresses.
* 
* 
* * **From one connected account to another connected account:**
* 
* 
* The API client provides `FromAuthToken` that is representing the source account and `ToAuthToken` that is representing the target account. Front API maps networks and tokens supported by both accounts and returns all tokens and networks eligible for a transfer as the result.
* 
* 
* * **From a connected account to any arbitrary address:**
* 
* 
* The API client provides `FromAuthToken` that is representing the source account and the list of target addresses using the `ToAddresses` field. Front API verifies the addresses and returns the list of tokens, eligible to be transferred as the result of the operation.
* 
* 
* 
* Returns the list of holdings on the account that can be used to perform the transfer. Each holdings item
* contains the list of supported networks that can be used to transfer the corresponding asset.
* Each network contains details such as gas fees and the amount eligible to be transferred.
*/
readonly "POST/api/v1/transfers/managed/configure": (options: typeof ConfigureTransferRequest.Encoded) => Effect.Effect<typeof ConfigureTransferResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersManagedConfigure401", typeof ApiV1TransfersManagedConfigure401.Type> | ClientError<"ApiV1TransfersManagedConfigure403", typeof ApiV1TransfersManagedConfigure403.Type>>
  /**
* **Validate and preview the transfer.**
* 
* 
* ---
* Validates the transfer, calculates the relevant amount in crypto if requested amount was in fiat and updates
* the current network fee values.
* 
* 
* This endpoint uses the `NetworkId` field to specify which network will be used to perform the transfer. The target `NetworkId`
* should be selected after configuring the transfer using `/configure` endpoint.
* 
* 
* 
* Returns the `PreviewId` value that can be used to commit the transfer.
*/
readonly "POST/api/v1/transfers/managed/preview": (options: typeof PreviewTransferRequest.Encoded) => Effect.Effect<typeof PreviewTransferResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersManagedPreview401", typeof ApiV1TransfersManagedPreview401.Type> | ClientError<"ApiV1TransfersManagedPreview403", typeof ApiV1TransfersManagedPreview403.Type>>
  /**
* **Commit the previously previewed transfer.**
* 
* 
* ---
* Previews the transfer, using the `PreviewId` value.
* 
* 
* Handles multi-factor authentication codes if the account is configured to use them for additional security.
* 
* 
* 
* Returns the status of the transfer and the details of the transfer if it was initiated successfully.
*/
readonly "POST/api/v1/transfers/managed/execute": (options: typeof ExecuteTransferRequest.Encoded) => Effect.Effect<typeof ExecuteTransferResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersManagedExecute401", typeof ApiV1TransfersManagedExecute401.Type> | ClientError<"ApiV1TransfersManagedExecute403", typeof ApiV1TransfersManagedExecute403.Type>>
  /**
* Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
*/
readonly "POST/api/v1/transfers/managed/address/get": (options: typeof ManagedBrokerCryptocurrencyDepositAddressRequest.Encoded) => Effect.Effect<typeof B2BBrokerCryptocurrencyDepositAddressResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersManagedAddressGet401", typeof ApiV1TransfersManagedAddressGet401.Type> | ClientError<"ApiResult", typeof ApiResult.Type>>
  /**
* Get a quote for transferring a fiat amount from a brokerage account in a given cryptocurrency over a specified network.
* Returns min and max fees and amounts to account for different funding sources (existing crypto balance, cash balance or
* ACH/debit deposit). Currently only supported for Coinbase.
*/
readonly "POST/api/v1/transfers/managed/quote": (options: typeof QuoteTransferRequest.Encoded) => Effect.Effect<typeof QuoteTransferResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersManagedQuote401", typeof ApiV1TransfersManagedQuote401.Type>>
  /**
* Get cryptocurrency transfers initiated by Mesh on exchanges or self-custody wallets.
*/
readonly "GET/api/v1/transfers/managed/mesh": (options?: typeof ApiV1TransfersManagedMeshParams.Encoded | undefined) => Effect.Effect<typeof TransferModelPaginationResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersManagedMesh401", typeof ApiV1TransfersManagedMesh401.Type>>
  /**
* **Updates the previously executed transfer.**
* 
* 
* ---
* Updates the transfer status, using the `TransactionId` value.
* Returns the status of the transfer and the details of the transfer.
*/
readonly "POST/api/v1/transfers/managed/update": (options: typeof UpdateTransferStatusRequest.Encoded) => Effect.Effect<typeof UpdateTransferResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersManagedUpdate401", typeof ApiV1TransfersManagedUpdate401.Type> | ClientError<"ApiV1TransfersManagedUpdate403", typeof ApiV1TransfersManagedUpdate403.Type>>
  /**
* Obtain assets from the connected investment account. Performs realtime API call to the underlying integration.
*/
readonly "POST/api/v1/holdings/get": (options: typeof PortfolioHoldingsRequest.Encoded) => Effect.Effect<typeof HoldingsModelApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1HoldingsGet401", typeof ApiV1HoldingsGet401.Type> | ClientError<"ApiV1HoldingsGet403", typeof ApiV1HoldingsGet403.Type>>
  /**
* Obtain assets from the connected investment account and return total value and performance.
* Performs realtime API call to the underlying integration.
*/
readonly "POST/api/v1/holdings/value": (options: typeof PortfolioBrokerBaseRequest.Encoded) => Effect.Effect<typeof BrokerPortfolioValueModelApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1HoldingsValue401", typeof ApiV1HoldingsValue401.Type> | ClientError<"ApiV1HoldingsValue403", typeof ApiV1HoldingsValue403.Type>>
  /**
* Get the aggregated portfolio of the user containing market values.
*/
readonly "GET/api/v1/holdings/portfolio": (options: typeof ApiV1HoldingsPortfolioParams.Encoded) => Effect.Effect<typeof B2BPortfolioModelApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1HoldingsPortfolio401", typeof ApiV1HoldingsPortfolio401.Type> | ClientError<"ApiV1HoldingsPortfolio403", typeof ApiV1HoldingsPortfolio403.Type>>
  readonly "POST/api/v1/catalog/solana/getLatestBlockhash": (options?: typeof ApiV1CatalogSolanaGetLatestBlockhashParams.Encoded | undefined) => Effect.Effect<typeof StringApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type>>
  /**
* Get transactions on the account - the paginated history of the executed orders along with the pending orders.
*/
readonly "POST/api/v1/transactions/list": (options: typeof TransactionsB2BBrokerOrderListRequest.Encoded) => Effect.Effect<typeof B2BBrokerOrderListResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiV1TransactionsList401", typeof ApiV1TransactionsList401.Type> | ClientError<"ApiV1TransactionsList403", typeof ApiV1TransactionsList403.Type>>
  /**
* Get details of an executed order. Typically used to poll the status of the previously executed order.
*/
readonly "POST/api/v1/transactions/details": (options: typeof TransactionsB2BBrokerOrderRequest.Encoded) => Effect.Effect<typeof B2BBrokerOrderApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type> | ClientError<"ApiV1TransactionsDetails401", typeof ApiV1TransactionsDetails401.Type> | ClientError<"ApiV1TransactionsDetails403", typeof ApiV1TransactionsDetails403.Type> | ClientError<"ProblemDetails", typeof ProblemDetails.Type>>
  /**
* Get supported features for trading for a particular financial institution. Different institutions support different
* features (e.g. different `OrderType` or different sets of `TimeInForce` values), so this endpoint is used to
* describe such features for provided financial institution.
*/
readonly "POST/api/v1/transactions/featureList": (options: typeof TransactionsBrokerBaseRequest.Encoded) => Effect.Effect<typeof B2BBrokerTradingFeatureInfoApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type> | ClientError<"ApiV1TransactionsFeatureList401", typeof ApiV1TransactionsFeatureList401.Type>>
  /**
* Validates the order information (such as necessary balance availability), and returns additional information,
* such as expected order fee.
* Does not execute the order.
*/
readonly "POST/api/v1/transactions/preview/{side}": (side: string, options: typeof TransactionsB2BBrokerCreateOrderRequest.Encoded) => Effect.Effect<typeof B2BBrokerPreviewOrderResultApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type> | ClientError<"ApiV1TransactionsPreviewSide401", typeof ApiV1TransactionsPreviewSide401.Type> | ClientError<"ApiV1TransactionsPreviewSide403", typeof ApiV1TransactionsPreviewSide403.Type>>
  /**
* Validates the order information and then calls institution's API to execute an order.
* It's recommended to call this endpoint after calling the `preview` endpoint to make sure that the
* order execution request is correct.
*/
readonly "POST/api/v1/transactions/{side}": (side: string, options: typeof TransactionsB2BBrokerCreateOrderRequest.Encoded) => Effect.Effect<typeof B2BBrokerCreateOrderResultApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type> | ClientError<"ApiV1TransactionsSide401", typeof ApiV1TransactionsSide401.Type> | ClientError<"ApiV1TransactionsSide403", typeof ApiV1TransactionsSide403.Type>>
  /**
* Cancels a pending order (an order with `InProgress` status).
* `SymbolPair` is required to be provided for `Binance`, `BinanceInternational`, `Okx` and `BitFlyer` institutions.
* This value
*/
readonly "POST/api/v1/transactions/cancel": (options: typeof TransactionsB2BBrokerOrderRequest.Encoded) => Effect.Effect<typeof ApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type> | ClientError<"ApiV1TransactionsCancel401", typeof ApiV1TransactionsCancel401.Type> | ClientError<"ApiV1TransactionsCancel403", typeof ApiV1TransactionsCancel403.Type> | ClientError<"ProblemDetails", typeof ProblemDetails.Type>>
  /**
* Returns information on trading allowance for a provided symbol.
* For example - some institutions allow fractional trading for some symbols, but do not allow it
* for others. So before placing an order the API client can check if the required symbol can be traded fractionally
* with the provided institution.
*/
readonly "POST/api/v1/transactions/symbolinfo": (options: typeof TransactionsB2BBrokerSymbolInfoForOrderRequest.Encoded) => Effect.Effect<typeof B2BBrokerOrderSymbolInfoApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ProblemDetails", typeof ProblemDetails.Type> | ClientError<"ApiV1TransactionsSymbolinfo401", typeof ApiV1TransactionsSymbolinfo401.Type>>
  /**
* Get entire history of cryptocurrency transfers (withdrawals or deposits) executed from an exchange.
* Only supports Exchange integrations.
*/
readonly "POST/api/v1/transfers/list": (options: typeof TransfersBrokerTransactionsListRequest.Encoded) => Effect.Effect<typeof B2BBrokerTransactionsListModelApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersList401", typeof ApiV1TransfersList401.Type> | ClientError<"ApiV1TransfersList403", typeof ApiV1TransfersList403.Type>>
  /**
* Get details of a specific transfer (withdrawals or deposits) executed from an exchange.
* Only supports Exchange integrations.
*/
readonly "POST/api/v1/transfers/details": (options: typeof TransfersBrokerCryptocurrencyTransactionDetailsRequest.Encoded) => Effect.Effect<typeof B2BBrokerCryptocurrencyTransactionApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersDetails401", typeof ApiV1TransfersDetails401.Type> | ClientError<"ApiV1TransfersDetails403", typeof ApiV1TransfersDetails403.Type> | ClientError<"ApiResult", typeof ApiResult.Type>>
  /**
* Initiate a new cryptocurrency transfer on a blockchain, cryptocurrency broker or cryptocurrency exchange.
* Obsolete endpoint, please use POST /transfers/managed/execute endpoint instead.
*/
readonly "POST/api/v1/transfers": (options: typeof TransfersBrokerCreateCryptocurrencyTransactionRequest.Encoded) => Effect.Effect<typeof B2BBrokerCreateCryptocurrencyTransactionResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1Transfers401", typeof ApiV1Transfers401.Type> | ClientError<"ApiV1Transfers403", typeof ApiV1Transfers403.Type>>
  /**
* Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
*/
readonly "POST/api/v1/transfers/address/get": (options: typeof TransfersBrokerCryptocurrencyDepositAddressRequest.Encoded) => Effect.Effect<typeof B2BBrokerCryptocurrencyDepositAddressResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersAddressGet401", typeof ApiV1TransfersAddressGet401.Type> | ClientError<"ApiResult", typeof ApiResult.Type>>
  /**
* Get details of the asset for deposit or withdrawal. For example, several exchanges support same tokens over multiple
* blockchains, and thus require the name of chain to be supplied for transfers. This endpoint allows getting such details.
*/
readonly "POST/api/v1/transfers/symbol/details": (options: typeof TransfersBrokerCryptocurrencyDepositAddressRequest.Encoded) => Effect.Effect<typeof B2BBrokerCryptocurrencySymbolDetailsResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1TransfersSymbolDetails401", typeof ApiV1TransfersSymbolDetails401.Type> | ClientError<"ApiResult", typeof ApiResult.Type>>
  /**
* Get wallet verifications for user and address.
*/
readonly "GET/api/v1/wallets/verify": (options?: typeof ApiV1WalletsVerifyParams.Encoded | undefined) => Effect.Effect<typeof DeFiWalletVerificationResponseApiResult.Type, HttpClientError.HttpClientError | ParseError | ClientError<"ApiResult", typeof ApiResult.Type> | ClientError<"ApiV1WalletsVerify401", typeof ApiV1WalletsVerify401.Type>>
}

export interface ClientError<Tag extends string, E> {
  readonly _tag: Tag
  readonly request: HttpClientRequest.HttpClientRequest
  readonly response: HttpClientResponse.HttpClientResponse
  readonly cause: E
}

class ClientErrorImpl extends Data.Error<{
  _tag: string
  cause: any
  request: HttpClientRequest.HttpClientRequest
  response: HttpClientResponse.HttpClientResponse
}> {}

export const ClientError = <Tag extends string, E>(
  tag: Tag,
  cause: E,
  response: HttpClientResponse.HttpClientResponse,
): ClientError<Tag, E> =>
  new ClientErrorImpl({
    _tag: tag,
    cause,
    response,
    request: response.request,
  }) as any
</file>

<file path="experimental_client/openapi.json">
{
  "openapi": "3.0.1",
  "info": {
    "title": "Mesh Connect Integration API",
    "description": "\nMesh allows users to connect accounts of financial institutions,\ncrypto exchanges, and self-custody wallets. Mesh handles credential\nvalidation, MFA, and error handling for each integration. After\nan account is connected, Mesh allows client applications to read holdings,\ntransaction history and balances and execute crypto transfers (with user approval).",
    "version": "1.0"
  },
  "servers": [
    {
      "url": "https://integration-api.meshconnect.com"
    },
    {
      "url": "https://sandbox-integration-api.meshconnect.com"
    }
  ],
  "paths": {
    "/api/v1/account/verify": {
      "post": {
        "tags": [
          "Integrations account information"
        ],
        "summary": "Verify account identity. Replaced by exchange/verify endpoint.",
        "description": "Return KYC details of the user.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/B2BBrokerAccountDetailsRequest"
                  }
                ]
              },
              "example": {"authToken":"Secret authentication token","integrationId":"4d3364d9-fa09-4382-ad4e-5cab2e355fd4"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully returns account details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerAccountDetailsResponseApiResult"
                },
                "example": {"content":{"integrationName":"Coinbase","firstName":"Firstname","middleName":"Midlename","lastName":"Lastname","accountNumber":"1234567","email":"enduser@domain.com","mobileNumber":"123456798","companyName":"MyCorp Inc.","countryCode":"GB","city":"City Name","postalCode":"4251","idType":"idCard","idNumber":"123","dateOfBirth":574732800},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Request to retrieve account details is not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/v1/exchange/verify": {
      "post": {
        "tags": [
          "Integrations account information"
        ],
        "summary": "Verify account identity.",
        "description": "Returns basic profile data of the user's exchange account.\r\nAvailable data varies by exchange and linked account.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExchangeAccountInfoRequest"
                  }
                ],
                "description": "Exchange account info request."
              },
              "example": {"authToken":"Secret authentication token","integrationId":"4d3364d9-fa09-4382-ad4e-5cab2e355fd4","accountInfo":["companyName","firstName","lastName"]}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successfully returns account details.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerAccountDetailsResponseApiResult"
                },
                "example": {"content":{"integrationName":"Coinbase","firstName":"Firstname","middleName":"Midlename","lastName":"Lastname","accountNumber":"1234567","email":"enduser@domain.com","mobileNumber":"123456798","companyName":"MyCorp Inc.","countryCode":"GB","city":"City Name","postalCode":"4251","idType":"idCard","idNumber":"123","dateOfBirth":574732800},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Request to retrieve account details is not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/assets/{assetType}": {
      "get": {
        "tags": [
          "Assets"
        ],
        "summary": "Get available assets",
        "parameters": [
          {
            "name": "assetType",
            "in": "path",
            "required": true,
            "schema": {
              "enum": [
                "equity",
                "cryptocurrency"
              ],
              "allOf": [
                {
                  "$ref": "#/components/schemas/AssetType"
                }
              ]
            }
          },
          {
            "name": "Search",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "Count",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "Offset",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetPaginationResponseApiResult"
                },
                "example": {"content":{"items":[{"symbol":"AAPL","name":"Apple Inc","type":"equity"},{"symbol":"MSFT","name":"Microsoft Inc","type":"equity"}],"total":5},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/balance/get": {
      "post": {
        "tags": [
          "Balance"
        ],
        "summary": "Get account balance",
        "description": "Get real-time account fiat balances.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BalanceBrokerBaseRequest"
                  }
                ]
              },
              "example": {"authToken":"Secret authentication token","type":"binanceInternationalDirect"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerAccountBalanceModelApiResult"
                },
                "example": {"content":{"balances":[{"cash":158.5,"buyingPower":258.5,"currencyCode":"USD"},{"cash":10,"buyingPower":10,"currencyCode":"EUR"}],"totalCashUsdValue":10,"totalBuyingPowerUsdValue":10},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have read permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/balance/portfolio": {
      "get": {
        "tags": [
          "Balance"
        ],
        "summary": "Get aggregated portfolio fiat balances",
        "description": "Get cached aggregated fiat balances from all connected integrations.",
        "parameters": [
          {
            "name": "UserId",
            "in": "query",
            "description": "End user ID to get the aggregated portfolio for.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BFiatPortfolioModelApiResult"
                },
                "example": {"content":{"fiatBalances":[{"symbol":"USD","cash":3.099,"buyingPower":3.099},{"symbol":"EUR","cash":-102.880,"buyingPower":1293.596}]},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have read permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/cataloglink": {
      "get": {
        "tags": [
          "Managed Account Authentication"
        ],
        "summary": "Get catalog link",
        "description": "Get personalized catalog link for client",
        "parameters": [
          {
            "name": "UserId",
            "in": "query",
            "description": "A unique Id representing the end user. Typically this will be a user Id from the\r\nclient application. Personally identifiable information, such as an email address or phone number,\r\nshould not be used. 50 characters length maximum.",
            "required": true,
            "schema": {
              "maxLength": 50,
              "type": "string"
            }
          },
          {
            "name": "BrokerType",
            "in": "query",
            "description": "Type of integration to redirect to. Will redirect to catalog if not provided.\r\nNot supported types: DeFiWallet, CryptocurrencyAddress, CryptocurrencyWallet.",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/BrokerType"
                }
              ]
            }
          },
          {
            "name": "EnableTransfers",
            "in": "query",
            "description": "Link Configuration identifier - an optional paramater for used configuration.\r\nIf not provided default configuration with all avaialbe integrations will be used.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "RestrictMultipleAccounts",
            "in": "query",
            "description": "The final screen of Link allows users to “continue” back to your app or “Link another account.”\r\nIf this param is present then this button will be hidden.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "DisableApiKeyGeneration",
            "in": "query",
            "description": "For direct integrations that also support API keys, Link presents the user with the option to generate an API key for seamless access.\r\nIf this param is true, this feature will be disabled.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Catalog link created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogLinkApiResult"
                },
                "example": {"content":{"url":"https://web.meshconnect.com/broker-connect?auth_code={authCode}","iFrameUrl":"https://web.meshconnect.com/b2b-iframe/{clientId}/broker-connect?auth_code={authCode}"},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "404": {
            "description": "API Client not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"notFound","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "400": {
            "description": "BadRequest can happen in following cases:\r\n<list type=\"number\"><item><description>userId parameter not specified</description></item><item><description>Callback url parameter is invalid</description></item><item><description>Client does not have callback url specified</description></item></list>",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        },
        "deprecated": true
      },
      "post": {
        "tags": [
          "Managed Account Authentication"
        ],
        "summary": "Get catalog link with parameters",
        "description": "Get personalized catalog link for client supplying parameters for Link actions, such as transfers",
        "parameters": [
          {
            "name": "UserId",
            "in": "query",
            "description": "A unique Id representing the end user. Typically this will be a user Id from the\r\nclient application. Personally identifiable information, such as an email address or phone number,\r\nshould not be used. 50 characters length maximum.",
            "required": true,
            "schema": {
              "maxLength": 50,
              "type": "string"
            }
          },
          {
            "name": "BrokerType",
            "in": "query",
            "description": "Type of integration to redirect to. Will redirect to catalog if not provided.\r\nNot supported types: DeFiWallet, CryptocurrencyAddress, CryptocurrencyWallet.",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/BrokerType"
                }
              ]
            }
          },
          {
            "name": "EnableTransfers",
            "in": "query",
            "description": "Link Configuration identifier - an optional paramater for used configuration.\r\nIf not provided default configuration with all avaialbe integrations will be used.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "RestrictMultipleAccounts",
            "in": "query",
            "description": "The final screen of Link allows users to “continue” back to your app or “Link another account.”\r\nIf this param is present then this button will be hidden.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "DisableApiKeyGeneration",
            "in": "query",
            "description": "For direct integrations that also support API keys, Link presents the user with the option to generate an API key for seamless access.\r\nIf this param is true, this feature will be disabled.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "description": "Data to execute transfer.",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InitializeTransfersForLinkRequest"
                  }
                ]
              },
              "example": {"toAddresses":[{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"ETH","address":"0x00000000000000000000000"},{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"USDC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"MATIC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDC","address":"0x00000000000000000000000"}],"clientFee":0,"isCustomClientFeeProvided":false,"isInclusiveFeeEnabled":false}
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InitializeTransfersForLinkRequest"
                  }
                ]
              },
              "example": {"toAddresses":[{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"ETH","address":"0x00000000000000000000000"},{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"USDC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"MATIC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDC","address":"0x00000000000000000000000"}],"clientFee":0,"isCustomClientFeeProvided":false,"isInclusiveFeeEnabled":false}
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InitializeTransfersForLinkRequest"
                  }
                ]
              },
              "example": {"toAddresses":[{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"ETH","address":"0x00000000000000000000000"},{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"USDC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"MATIC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDC","address":"0x00000000000000000000000"}],"clientFee":0,"isCustomClientFeeProvided":false,"isInclusiveFeeEnabled":false}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Catalog link created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogLinkApiResult"
                },
                "example": {"content":{"url":"https://web.meshconnect.com/broker-connect?auth_code={authCode}","iFrameUrl":"https://web.meshconnect.com/b2b-iframe/{clientId}/broker-connect?auth_code={authCode}"},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "404": {
            "description": "API Client not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"notFound","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "400": {
            "description": "BadRequest can happen in following cases:\r\n<list type=\"number\"><item><description>userId parameter not specified</description></item><item><description>Callback url parameter is invalid</description></item><item><description>Client does not have callback url specified</description></item></list>",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/v1/linktoken": {
      "post": {
        "tags": [
          "Managed Account Authentication"
        ],
        "summary": "Get Link token with parameters",
        "description": "Get a short lived, one-time use token for initializing a Link session using the client-side SDKs",
        "requestBody": {
          "description": "Create Link token request.",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GetLinkTokenRequest"
                  }
                ]
              },
              "example": {"userId":"UserId","configurationId":"18a20b11-e47f-43b9-8546-94284e9ee547","restrictMultipleAccounts":true,"transferOptions":{"toAddresses":[{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"ETH","address":"0x00000000000000000000000"},{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"USDC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"MATIC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDC","address":"0x00000000000000000000000"}],"amountInFiat":10,"isInclusiveFeeEnabled":false,"generatePayLink":false},"disableApiKeyGeneration":false}
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GetLinkTokenRequest"
                  }
                ]
              },
              "example": {"userId":"UserId","configurationId":"18a20b11-e47f-43b9-8546-94284e9ee547","restrictMultipleAccounts":true,"transferOptions":{"toAddresses":[{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"ETH","address":"0x00000000000000000000000"},{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"USDC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"MATIC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDC","address":"0x00000000000000000000000"}],"amountInFiat":10,"isInclusiveFeeEnabled":false,"generatePayLink":false},"disableApiKeyGeneration":false}
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/GetLinkTokenRequest"
                  }
                ]
              },
              "example": {"userId":"UserId","configurationId":"18a20b11-e47f-43b9-8546-94284e9ee547","restrictMultipleAccounts":true,"transferOptions":{"toAddresses":[{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"ETH","address":"0x00000000000000000000000"},{"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","symbol":"USDC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"MATIC","address":"0x00000000000000000000000"},{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDC","address":"0x00000000000000000000000"}],"amountInFiat":10,"isInclusiveFeeEnabled":false,"generatePayLink":false},"disableApiKeyGeneration":false}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Link token created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LinkTokenModelApiResult"
                },
                "example": {"content":{"linkToken":"aHR0cHM6Ly93ZWIubWVzaGNvbm5lY3QuY29tL2IyYi1pZnJhbWUve2NsaWVudElkfS9icm9rZXItY29ubmVjdD9hdXRoX2NvZGU9e2F1dGhDb2RlfQ=="},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "404": {
            "description": "API Client not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"notFound","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "400": {
            "description": "BadRequest can happen in following cases:\r\n<list type=\"number\"><item><description>userId parameter not specified</description></item><item><description>Network not supported by the selected DeFi wallet.</description></item></list>",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/token/refresh": {
      "post": {
        "tags": [
          "Managed Account Authentication"
        ],
        "summary": "Refresh auth token",
        "description": "Refresh auth token of the connected institution.\r\nSome institutions do not require tokens to be refreshed.\r\n            \r\nThe following institutions require custom flows:\r\n            \r\nWeBull: AuthToken should be provided along with the RefreshToken\r\n            \r\nVanguard: security settings may activate MFA, requiring user action.\r\nIf MFA is triggered, a second refresh request should be sent.\r\nSecond request should contain MFA code and access token obtained from initial response",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BrokerRefreshTokenRequest"
                  }
                ]
              },
              "example": {"refreshToken":"Secret refresh token","type":"coinbase"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerRefreshTokenResponseApiResult"
                },
                "example": {"content":{"status":"succeeded","expiresInSeconds":86400,"brokerAccountTokens":[{"accessToken":"New secret token","refreshToken":"New secret refresh token"}]},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Unauthorized token","displayMessage":"Could not refresh the authentication token. The provided data is not correct","errorType":"badRequest"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/account": {
      "delete": {
        "tags": [
          "Managed Account Authentication"
        ],
        "summary": "Remove connection",
        "description": "Remove connection to the financial institution and erase all related data completely.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BrokerBaseRequest"
                  }
                ]
              },
              "example": {"authToken":"Secret authentication token","type":"robinhood"}
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BrokerBaseRequest"
                  }
                ]
              },
              "example": {"authToken":"Secret authentication token","type":"robinhood"}
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/BrokerBaseRequest"
                  }
                ]
              },
              "example": {"authToken":"Secret authentication token","type":"robinhood"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/status": {
      "get": {
        "tags": [
          "Managed Account Authentication"
        ],
        "summary": "Get health status",
        "description": "Get the list of supported institutions and their health statuses.",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokersHealthStatusListApiResult"
                },
                "example": {"content":[{"type":"robinhood","name":"Robinhood","isUp":true,"supportedProducts":["balance","holdings","identity","orders","transfers"]},{"type":"celsius","name":"Celsius","isUp":false,"description":"Temporarily disabled","downTimeStart":1655891444,"supportedProducts":["balance","orders","transfers","holdings"]},{"type":"deFiWallet","name":"MetaMask","isUp":false,"supportedProducts":["transfers","holdings"],"deFiWalletData":{"id":"34aeb688-decb-485f-9d80-b66466783394","name":"MetaMask"}}],"status":"ok","message":"","errorType":""}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/authenticationSchemes": {
      "get": {
        "tags": [
          "Self Managed Account Authentication"
        ],
        "summary": "Get authentication schemes",
        "description": "Get authentication schemes of available integrations to perform authentication programmatically (not using\r\nthe Web Catalog UI).",
        "responses": {
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BrokerAuthenticationSchemeIReadOnlyCollectionApiResult"
                },
                "example": {"content":[{"brokerType":"binanceInternational","authenticationSchemeType":"apiKey","initialAuthenticationModel":{"fields":[{"name":"Username","description":"API key"},{"name":"Password","description":"Secret key"},{"name":"AuthToken","description":"Passphrase"},{"name":"Type","description":"BinanceInternational"}]},"mfaSchemes":[]}],"status":"ok","message":"","errorType":""}
              }
            }
          }
        }
      }
    },
    "/api/v1/authenticate": {
      "post": {
        "tags": [
          "Self Managed Account Authentication"
        ],
        "summary": "Authenticate user's account",
        "description": "Authenticate user's brokerage/exchange account programmatically (not using the Web Catalog UI)",
        "parameters": [
          {
            "name": "userId",
            "in": "query",
            "description": "Id of the end-user",
            "required": true,
            "schema": {
              "maxLength": 50,
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Authentication request.",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/B2BBrokerAuthRequest"
                  }
                ]
              },
              "example": {"username":"username","password":"password","mfaCode":"000000","mfaType":"phone","isSensitiveFieldsEncrypted":false,"isTryingAnotherWay":false,"type":"robinhood"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerAuthResponseApiResult"
                },
                "example": {"content":{"status":"succeeded","expiresInSeconds":7200,"accountTokens":[{"account":{"meshAccountId":"00000000-0000-0000-0000-000000000000","frontAccountId":"00000000-0000-0000-0000-000000000000","accountId":"Id of the account","accountName":"Name of the account"},"accessToken":"Access token, allowing access to the integration","refreshToken":"Optional refresh token, allowing to refresh the access token"}]},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          },
          "503": {
            "description": "Service Unavailable"
          }
        }
      }
    },
    "/api/v1/authenticate/{brokerType}": {
      "get": {
        "tags": [
          "Self Managed Account Authentication"
        ],
        "summary": "Get OAuth authentication link",
        "description": "Get OAuth link for the integrations with `OAuth` AuthenticationSchemeType",
        "parameters": [
          {
            "name": "brokerType",
            "in": "path",
            "description": "Type of the integration to connect",
            "required": true,
            "schema": {
              "enum": [
                "robinhood",
                "eTrade",
                "alpaca",
                "tdAmeritrade",
                "weBull",
                "stash",
                "interactiveBrokers",
                "public",
                "coinbase",
                "kraken",
                "coinbasePro",
                "cryptoCom",
                "openSea",
                "binanceUs",
                "gemini",
                "cryptocurrencyAddress",
                "cryptocurrencyWallet",
                "okCoin",
                "bittrex",
                "kuCoin",
                "etoro",
                "cexIo",
                "binanceInternational",
                "bitstamp",
                "gateIo",
                "acorns",
                "okx",
                "bitFlyer",
                "coinlist",
                "huobi",
                "bitfinex",
                "deFiWallet",
                "krakenDirect",
                "vanguard",
                "binanceInternationalDirect",
                "bitfinexDirect",
                "bybit",
                "paxos",
                "coinbasePrime",
                "btcTurkDirect",
                "kuCoinDirect",
                "okxOAuth",
                "paribuDirect",
                "robinhoodConnect",
                "blockchainCom",
                "bitsoDirect",
                "binanceConnect",
                "binanceOAuth",
                "revolutConnect",
                "binancePay",
                "bybitDirect",
                "paribuOAuth",
                "payPalConnect",
                "binanceTrDirect",
                "coinbaseRamp",
                "bybitDirectMobile"
              ],
              "allOf": [
                {
                  "$ref": "#/components/schemas/BrokerType"
                }
              ]
            }
          },
          {
            "name": "userId",
            "in": "query",
            "description": "Id of the end-user",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerAuthPromptResponseApiResult"
                },
                "example": {"content":{"status":"redirect","redirectLink":"https://web.meshconnect.com/broker-connect/callback","linkToken":"Link to the integration's site"},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/integrations": {
      "get": {
        "tags": [
          "Managed Account Authentication"
        ],
        "summary": "Retrieve the list of all available integrations.",
        "description": "Returns a list of integrations with details including the integration ID, name, type,\r\nDeFi wallet provider ID, and categories.",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntegrationsResponseApiResult"
                },
                "example": {"content":{"items":[{"id":"47624467-e52e-4938-a41a-7926b6c27acf","name":"Coinbase","type":"coinbase","style":{"fieldActiveLight":"0052FF","buttonPrimaryLight":"0052FF","buttonHoverLight":"014CEC","buttonTextLight":"FFFFFF","buttonTextHoverLight":"FFFFFF","fieldActiveDark":"578BFA","buttonPrimaryDark":"578BFA","buttonHoverDark":"507FE5","buttonTextDark":"0A0B0D","buttonTextHoverDark":"0A0B0D"},"logo":{"logoLightUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Logo_Light.svg","logoDarkUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Logo_Dark.svg","logoWhiteUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Logo_White.svg","logoBlackUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Logo_Black.svg","logoColorUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Logo_Color.svg","iconLightUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Icon_Light.svg","iconDarkUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Icon_Dark.svg","iconWhiteUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Icon_White.svg","iconBlackUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Icon_Black.svg","iconColorUrl":"https://frontuserfilecdn.azureedge.net/public/logos/Coinbase_Icon_Color.svg","base64Logo":"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAA1VBMVEUAAAAAgP8AVf8AM/8AVdUAROgAQ+kAROkAROkAQ+oAQuoAROoAQ+gAROkAQ+kAQ+kAROkAQ+kAQ+kAROkAQugAQ+kAQ+kAROkAQ+kAQ+kAQ+kAQ+kAQ+kXVesOTuoAQ+kBROkERukFR+kNTeoOTeoUUusZVeshW+wpYe0qYu0uZe0yaO00ae05be5fifFgivGMqvWSr/amvfeqwPi7zfnE0/rO2/vU3/vY4vzc5fze5/zh6fzi6vzl7P3m7f3p7/3u8v7x9f73+f75+/76+//+/v////94Z10/AAAAH3RSTlMAAgMFBk9QUlNUVVZXiImKi4ykptfY2dvc3fHz9Pr8ZrpFhQAAAAFiS0dERhe6+e0AAADPSURBVBgZncHXVsJAFAXQExM6UhJCwEGPYsfesKCiAvf/P8m5swIhPLI3thbUo3gwiKNagJxyn6leCZmdNte0PCy1mdNAqswNRThBn+r0/n3+/XRAKwmg6lTnnyI/s2c6VaiI6kVerzg8phNCdWmNZHHBlRjK0LqVCTMGytC6kwkze1BdWteyGHElhopoHY7l7YZHJ3RCqBrV5VTk9288pKpABT2qs4eP2dfjPq3Eh1PihgJSLebsYslrck3DQ6aYMJUUkONXw44xnbDiY1v/vNIqVzlyMewAAAAASUVORK5CYII="},"cryptoTransfersSupported":true},{"id":"3d8f5c31-9fc0-4b61-bdfb-00fb18cbb9ad","name":"CoinCircle","type":"deFiWallet","deFiWalletProviderId":"36d8d9c0c7fe2957149ce8e878f3a01...","categories":["deFiWallet"],"style":{"fieldActiveLight":"0052FF","buttonPrimaryLight":"0052FF","buttonHoverLight":"014CEC","buttonTextLight":"FFFFFF","buttonTextHoverLight":"FFFFFF","fieldActiveDark":"578BFA","buttonPrimaryDark":"578BFA","buttonHoverDark":"507FE5","buttonTextDark":"0A0B0D","buttonTextHoverDark":"0A0B0D"},"logo":{"logoColorUrl":"https://frontuserfilecdn.azureedge.net/public/logos/CoinCircle_Logo_Color.svg","iconColorUrl":"https://frontuserfilecdn.azureedge.net/public/logos/CoinCircle_Icon_Color.svg"},"cryptoTransfersSupported":true}]},"status":"ok","message":"","errorType":""}
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/networks": {
      "get": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Get networks",
        "description": "**Get supported networks list.**\r\n\n\r\n---\r\nGet the list of all networks supported by Mesh to perform transfers, including which tokens and integrations are supported.",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NetworkModelResponseApiResult"
                },
                "example": {"content":{"networks":[{"networkType":"evm","tokens":[{"symbol":"ETH","logoUrl":"https://frontuserfilecdn.azureedge.net/public/logos/tokens/ETH.svg"},{"symbol":"USDC","logoUrl":"https://frontuserfilecdn.azureedge.net/public/logos/tokens/USDC.svg"},{"symbol":"USDT","logoUrl":"https://frontuserfilecdn.azureedge.net/public/logos/tokens/USDT.svg"}],"supportedBrokerTypes":["deFiWallet","robinhood","coinbase","kraken","binanceInternational","binanceUs"],"supportedTokens":["ETH","USDC","USDT"],"nativeSymbol":"ETH","id":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","name":"Ethereum","chainId":"1","logoUrl":"https://frontuserfilecdn.azureedge.net/public/logos/networks/Ethereum.svg"}]},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/integrations": {
      "get": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Get integrations",
        "description": "**Get supported integrations list.**\r\n\n\r\n---\r\nGet the list of all integrations supported by Mesh to perform transfers, including which tokens and networks are supported.",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IntegrationNetworkResponseApiResult"
                },
                "example": {"content":{"integrations":[{"id":"00000000-0000-0000-0000-000000000000","type":"robinhood","networks":[{"supportedDevices":["android","ios","web"],"supportedTokens":["USDC","ETH"],"nativeSymbol":"ETH","id":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","name":"Ethereum","chainId":"1","logoUrl":"https://frontuserfilecdn.azureedge.net/public/logos/networks/Ethereum.svg"},{"supportedDevices":["web"],"supportedTokens":["MATIC","ETH"],"nativeSymbol":"MATIC","id":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","name":"Polygon","chainId":"137","logoUrl":"https://frontuserfilecdn.azureedge.net/public/logos/networks/Polygon.svg"}],"supportsOutgoingTransfers":true,"supportsIncomingTransfers":true}]},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/tokens": {
      "get": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Get supported tokens list",
        "description": "Get the list of all tokens supported by Mesh to perform transfers, including which networks and integrations are supported.",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenNetworksResponseApiResult"
                },
                "example": {"content":{"tokens":[{"token":"ADA","networks":[{"id":"f7a660cd-bac0-4ae8-8ddb-c54d321b55dc","name":"Cardano","logoUrl":"https://frontuserfilecdn.azureedge.net/public/logos/networks/Cardano.svg"}],"supportedIntegrations":["gemini","binanceInternational"]}]},"status":"ok","message":"","errorType":""}
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/verify": {
      "get": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Verify the transfer request without authenticating the integration accounts",
        "description": "Checks if the combination of integration ID, network ID, token is correct for transfer.\r\nChecks if the target address is in the correct format.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransferVerificationRequest"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransferVerificationResponseApiResult"
                },
                "example": {"content":{"status":"succeeded","errorMessage":"transfer request verification is successful"},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/configure": {
      "post": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Configure transfer",
        "description": "**Get the list of networks and tokens eligible for a transfer, based on the provided request data.**\r\n\n\r\n---\r\nTransfers can be configured either from one connected account to another connected account, or\r\nfrom a connected account to any arbitrary address or addresses.\r\n\n\r\n* **From one connected account to another connected account:**\r\n\n\r\nThe API client provides `FromAuthToken` that is representing the source account and `ToAuthToken` that is representing the target account. Front API maps networks and tokens supported by both accounts and returns all tokens and networks eligible for a transfer as the result.\r\n\n\r\n* **From a connected account to any arbitrary address:**\r\n\n\r\nThe API client provides `FromAuthToken` that is representing the source account and the list of target addresses using the `ToAddresses` field. Front API verifies the addresses and returns the list of tokens, eligible to be transferred as the result of the operation.\r\n\n\n\r\nReturns the list of holdings on the account that can be used to perform the transfer. Each holdings item\r\ncontains the list of supported networks that can be used to transfer the corresponding asset.\r\nEach network contains details such as gas fees and the amount eligible to be transferred.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ConfigureTransferRequest"
                  }
                ]
              },
              "examples": {
                "Configure with provided list of addresses": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAddresses":[{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","address":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6"},{"networkId":"0291810a-5947-424d-9a59-e88bb33e999d","symbol":"USDT","address":"HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH"},{"networkId":"0880db06-7c7c-4738-898f-cf74efc03c47","symbol":"BTC","address":"3FZbgi29cpjq2GjdwV8eyHuJJnkLtktZc5"}]}
                },
                "Configure transfer between two connected accounts": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase"}
                },
                "Configure with provided list of addresses, symbol and amount": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAddresses":[{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","address":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6"},{"networkId":"0291810a-5947-424d-9a59-e88bb33e999d","symbol":"USDT","address":"HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH"},{"networkId":"0880db06-7c7c-4738-898f-cf74efc03c47","symbol":"BTC","address":"3FZbgi29cpjq2GjdwV8eyHuJJnkLtktZc5"}],"symbol":"USDT","amount":130,"fiatCurrency":"USD"}
                },
                "Configure transfer between two connected accounts, symbol, amount in fiat and preferred network": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase","symbol":"USDT","amountInFiat":130,"fiatCurrency":"USD","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12"}
                }
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ConfigureTransferRequest"
                  }
                ]
              },
              "examples": {
                "Configure with provided list of addresses": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAddresses":[{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","address":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6"},{"networkId":"0291810a-5947-424d-9a59-e88bb33e999d","symbol":"USDT","address":"HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH"},{"networkId":"0880db06-7c7c-4738-898f-cf74efc03c47","symbol":"BTC","address":"3FZbgi29cpjq2GjdwV8eyHuJJnkLtktZc5"}]}
                },
                "Configure transfer between two connected accounts": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase"}
                },
                "Configure with provided list of addresses, symbol and amount": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAddresses":[{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","address":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6"},{"networkId":"0291810a-5947-424d-9a59-e88bb33e999d","symbol":"USDT","address":"HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH"},{"networkId":"0880db06-7c7c-4738-898f-cf74efc03c47","symbol":"BTC","address":"3FZbgi29cpjq2GjdwV8eyHuJJnkLtktZc5"}],"symbol":"USDT","amount":130,"fiatCurrency":"USD"}
                },
                "Configure transfer between two connected accounts, symbol, amount in fiat and preferred network": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase","symbol":"USDT","amountInFiat":130,"fiatCurrency":"USD","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12"}
                }
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ConfigureTransferRequest"
                  }
                ]
              },
              "examples": {
                "Configure with provided list of addresses": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAddresses":[{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","address":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6"},{"networkId":"0291810a-5947-424d-9a59-e88bb33e999d","symbol":"USDT","address":"HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH"},{"networkId":"0880db06-7c7c-4738-898f-cf74efc03c47","symbol":"BTC","address":"3FZbgi29cpjq2GjdwV8eyHuJJnkLtktZc5"}]}
                },
                "Configure transfer between two connected accounts": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase"}
                },
                "Configure with provided list of addresses, symbol and amount": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAddresses":[{"networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","address":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6"},{"networkId":"0291810a-5947-424d-9a59-e88bb33e999d","symbol":"USDT","address":"HN7cABqLq46Es1jh92dQQisAq662SmxELLLsHHe4YWrH"},{"networkId":"0880db06-7c7c-4738-898f-cf74efc03c47","symbol":"BTC","address":"3FZbgi29cpjq2GjdwV8eyHuJJnkLtktZc5"}],"symbol":"USDT","amount":130,"fiatCurrency":"USD"}
                },
                "Configure transfer between two connected accounts, symbol, amount in fiat and preferred network": {
                  "value": {"isInclusiveFeeEnabled":false,"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase","symbol":"USDT","amountInFiat":130,"fiatCurrency":"USD","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12"}
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigureTransferResponseApiResult"
                },
                "examples": {
                  "Successful transfer configuration": {
                    "value": {"content":{"status":"succeeded","holdings":[{"symbol":"USDC","availableBalance":130,"availableBalanceInFiat":0,"eligibleForTransfer":true,"networks":[{"name":"Ethereum","id":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","minimumAmount":1,"totalEstimatedTransferFeeInFiat":1.8,"estimatedNetworkGasFee":{"fee":0.000850608941007,"feeCurrency":"ETH","feeInFiat":1.8},"institutionTransferFee":{"fee":0,"feeCurrency":"ETH","feeInFiat":0},"eligibleForTransfer":true,"eligibleForTransferWithFunding":false},{"name":"Solana","id":"0291810a-5947-424d-9a59-e88bb33e999d","minimumAmount":1,"totalEstimatedTransferFeeInFiat":0.1,"estimatedNetworkGasFee":{"fee":0.00025,"feeCurrency":"SOL","feeInFiat":0.1},"institutionTransferFee":{"fee":0,"feeCurrency":"SOL","feeInFiat":0},"eligibleForTransfer":true,"eligibleForTransferWithFunding":false}],"eligibleForTransferWithFunding":false}]},"status":"ok","message":"","errorType":""}
                  },
                  "Transfer configuration with failed validation": {
                    "value": {"status":"badRequest","message":"Either `ToAddresses` or `ToAuthToken` should be provided.","errorType":"invalidField"}
                  },
                  "Transfer configuration with no eligible tokens to transfer": {
                    "value": {"content":{"status":"succeeded","holdings":[{"symbol":"USDC","availableBalance":1,"availableBalanceInFiat":0,"eligibleForTransfer":false,"eligibleForTransferWithFunding":false},{"symbol":"ETH","availableBalance":0.00001,"availableBalanceInFiat":0,"eligibleForTransfer":false,"eligibleForTransferWithFunding":false}]},"status":"ok","message":"","errorType":""}
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have write permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/preview": {
      "post": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Preview transfer",
        "description": "**Validate and preview the transfer.**\r\n\n\r\n---\r\nValidates the transfer, calculates the relevant amount in crypto if requested amount was in fiat and updates\r\nthe current network fee values.\r\n\n\r\nThis endpoint uses the `NetworkId` field to specify which network will be used to perform the transfer. The target `NetworkId`\r\nshould be selected after configuring the transfer using `/configure` endpoint.\r\n\n\n\r\nReturns the `PreviewId` value that can be used to commit the transfer.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PreviewTransferRequest"
                  }
                ]
              },
              "examples": {
                "Preview with provided address": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","toAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","amount":10}
                },
                "Preview transfer between two connected accounts": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","toAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","amount":10}
                },
                "Preview transfer between two connected accounts, using fiat amount": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","toAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","amountInFiat":10}
                }
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PreviewTransferRequest"
                  }
                ]
              },
              "examples": {
                "Preview with provided address": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","toAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","amount":10}
                },
                "Preview transfer between two connected accounts": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","toAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","amount":10}
                },
                "Preview transfer between two connected accounts, using fiat amount": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","toAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","amountInFiat":10}
                }
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PreviewTransferRequest"
                  }
                ]
              },
              "examples": {
                "Preview with provided address": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","toAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","amount":10}
                },
                "Preview transfer between two connected accounts": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","toAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","amount":10}
                },
                "Preview transfer between two connected accounts, using fiat amount": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","toAuthToken":"Secret authentication token","toType":"coinbase","networkId":"7436e9d0-ba42-4d2b-b4c0-8e4e606b2c12","symbol":"USDT","toAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","amountInFiat":10}
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PreviewTransferResponseApiResult"
                },
                "examples": {
                  "Successful transfer preview": {
                    "value": {"content":{"status":"succeeded","previewResult":{"previewId":"29b185b1-2305-40fb-a0e2-929d61451568","previewExpiresIn":300,"fromAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","toAddress":"0x326a8825472bb0f4719998e708a1eeeb4473ed1b","symbol":"USDT","amount":10,"amountInFiat":10,"totalEstimatedAmount":11.21,"totalEstimatedAmountInFiat":11.21,"networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","institutionTransferFee":{"fee":0,"feeCurrency":"USDT","feeInFiat":0},"estimatedNetworkGasFee":{"fee":1.1,"feeCurrency":"USDT","feeInFiat":1.1},"unitPrice":0,"customClientFee":{"fee":0.011,"feeCurrency":"USDT","feeInFiat":0.011},"transferType":"deposit","isCustomClientFeeProvided":false,"amountWithCustomClientFee":"0","isFeeIncluded":false,"amountToReceive":0,"amountToReceiveInFiat":0,"transferAmountToRequest":0,"isMaximumAmount":false,"isBridging":false}},"status":"ok","message":"","errorType":""}
                  },
                  "Failed transfer preview": {
                    "value": {"status":"badRequest","message":"The\u00A0specified amount is greater than the maximum amount allowed.","displayMessage":"The\u00A0specified amount is greater than the maximum amount allowed.","errorType":"invalidField"}
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have write permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/execute": {
      "post": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Execute transfer",
        "description": "**Commit the previously previewed transfer.**\r\n\n\r\n---\r\nPreviews the transfer, using the `PreviewId` value.\r\n\n\r\nHandles multi-factor authentication codes if the account is configured to use them for additional security.\r\n\n\n\r\nReturns the status of the transfer and the details of the transfer if it was initiated successfully.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExecuteTransferRequest"
                  }
                ]
              },
              "examples": {
                "Execute transfer": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","previewId":"29b185b1-2305-40fb-a0e2-929d61451568","tryAnotherMfa":false}
                },
                "Execute transfer providing the MFA code": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","previewId":"29b185b1-2305-40fb-a0e2-929d61451568","mfaCode":"112457","tryAnotherMfa":false}
                }
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExecuteTransferRequest"
                  }
                ]
              },
              "examples": {
                "Execute transfer": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","previewId":"29b185b1-2305-40fb-a0e2-929d61451568","tryAnotherMfa":false}
                },
                "Execute transfer providing the MFA code": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","previewId":"29b185b1-2305-40fb-a0e2-929d61451568","mfaCode":"112457","tryAnotherMfa":false}
                }
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ExecuteTransferRequest"
                  }
                ]
              },
              "examples": {
                "Execute transfer": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","previewId":"29b185b1-2305-40fb-a0e2-929d61451568","tryAnotherMfa":false}
                },
                "Execute transfer providing the MFA code": {
                  "value": {"fromAuthToken":"Secret authentication token","fromType":"robinhood","previewId":"29b185b1-2305-40fb-a0e2-929d61451568","mfaCode":"112457","tryAnotherMfa":false}
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteTransferResponseApiResult"
                },
                "examples": {
                  "Successful transfer preview": {
                    "value": {"content":{"status":"succeeded","executeTransferResult":{"transferId":"e332336c-de22-11ed-b5ea-0242ac120002","status":"pending","statusDetails":"In progress","fromAddress":"0x9Bf6207f8A3f4278E0C989527015deFe10e5D7c6","toAddress":"0x326a8825472bb0f4719998e708a1eeeb4473ed1b","symbol":"USDT","networkName":"Ethereum","networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","hash":"0xdcfd72635a9b16d3bc0e75311f6fe0612970e9714a1e9e93de0ea5acffc6a454","amount":10,"amountInFiat":10,"totalAmountInFiat":11.1,"completedConfirmations":1,"institutionTransferFee":{"fee":0,"feeCurrency":"USDT","feeInFiat":0},"networkGasFee":{"fee":1.1,"feeCurrency":"USDT","feeInFiat":1.1}},"fallbackMfaAvailable":false},"status":"ok","message":"","errorType":""}
                  },
                  "Transfer preview when MFA is required": {
                    "value": {"content":{"status":"mfaRequired","fallbackMfaAvailable":false},"status":"ok","message":"","errorType":""}
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have write permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/address/get": {
      "post": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Get deposit address",
        "description": "Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ManagedBrokerCryptocurrencyDepositAddressRequest"
                  }
                ]
              },
              "example": {"symbol":"DOGE","networkId":"34b66a94-f9f9-49ef-81e8-6ebd5a866f9d","authToken":"Secret authentication token","type":"binanceInternational"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Address successfully obtained or generation initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerCryptocurrencyDepositAddressResponseApiResult"
                },
                "example": {"content":{"symbol":"DOGE","address":"D641Fmzx...","chain":"DOGE"},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Request details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "404": {
            "description": "Address for the required symbol is not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"notFound","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/quote": {
      "post": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Quote transfer",
        "description": "Get a quote for transferring a fiat amount from a brokerage account in a given cryptocurrency over a specified network.\r\nReturns min and max fees and amounts to account for different funding sources (existing crypto balance, cash balance or\r\nACH/debit deposit). Currently only supported for Coinbase.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/QuoteTransferRequest"
                  }
                ]
              },
              "examples": {
                "Quote transfer with no partner fee": {
                  "value": {"amountInFiat":10,"fiatCurrency":"USD","symbol":"ETH","networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","toAddress":"0xc096a91fDFB100ECED14e4810FA06061C0b3058B","brokerType":"coinbase"}
                },
                "Quote transfer with flat partner fee": {
                  "value": {"amountInFiat":10,"fiatCurrency":"USD","symbol":"ETH","networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","toAddress":"0xc096a91fDFB100ECED14e4810FA06061C0b3058B","brokerType":"coinbase","feeFlat":0.0004}
                },
                "Quote transfer with percentage partner fee": {
                  "value": {"amountInFiat":10,"fiatCurrency":"USD","symbol":"ETH","networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","toAddress":"0xc096a91fDFB100ECED14e4810FA06061C0b3058B","brokerType":"coinbase","feePercentage":1}
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Quote obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QuoteTransferResponseApiResult"
                },
                "examples": {
                  "Successful transfer quote": {
                    "value": {"content":{"amountInFiat":100,"fiatCurrency":"USD","symbol":"ETH","networkId":"e3c7fdd8-b1fc-4e51-85ae-bb276e075611","toAddress":"0xc096a91fDFB100ECED14e4810FA06061C0b3058B","brokerType":"coinbase","isEligible":true,"minEligibleAmount":0.0001,"minEligibleAmountFiat":0,"brokerPrice":2247.5,"price":2246.9,"minAmountFiat":97.08,"maxAmountFiat":97.88,"minAmount":0.0432080770227800702300947973,"maxAmount":0.0435641231307510524722951622,"fees":{"inFiat":{"paymentMethodFeeMaxFiat":0,"tradingFeeMaxFiat":0.80,"withdrawalFeeFiat":0,"partnerFeeFiat":1.00,"networkFeeFiat":1.12,"minFeesFiat":2.12,"maxFeesFiat":2.92},"inCrypto":{"paymentMethodFeeMax":0,"tradingFeeMax":0.0003560461079709822422003649,"withdrawalFee":0,"partnerFee":0.0004450576349637278027504562,"networkFee":0.000496582730658000,"minFees":0.0009416403656217278027504562,"maxFees":0.0012976864735927100449508211}},"fundingOptions":[{"fundingOption":"existingCryptocurrencyBalance","paymentMethodFeeFiat":0,"tradingFeeFiat":0},{"fundingOption":"buyingPowerPurchase","paymentMethodFeeFiat":0,"tradingFeeFiat":0.80},{"fundingOption":"paymentMethodDepositUsage","paymentMethodType":"bankAccount","paymentMethodFeeFiat":0,"tradingFeeFiat":0.80}]},"status":"ok","message":"","errorType":""}
                  }
                }
              }
            }
          },
          "400": {
            "description": "Request details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/mesh": {
      "get": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Get transfers initiated by Mesh",
        "description": "Get cryptocurrency transfers initiated by Mesh on exchanges or self-custody wallets.",
        "parameters": [
          {
            "name": "Count",
            "in": "query",
            "description": "Number of items to return. Default 10, maximum - 100.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "Offset",
            "in": "query",
            "description": "Number of items to skip.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "Id",
            "in": "query",
            "description": "Mesh transfer identifier.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "ClientTransactionId",
            "in": "query",
            "description": "Client transaction identifier.",
            "schema": {
              "maxLength": 128,
              "minLength": 0,
              "type": "string"
            }
          },
          {
            "name": "UserId",
            "in": "query",
            "description": "Client's user identifier.",
            "schema": {
              "maxLength": 50,
              "minLength": 0,
              "type": "string"
            }
          },
          {
            "name": "IntegrationIds",
            "in": "query",
            "description": "Transfered integration.",
            "schema": {
              "maxItems": 100,
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              }
            }
          },
          {
            "name": "Statuses",
            "in": "query",
            "description": "Transfer statuses.",
            "schema": {
              "maxItems": 5,
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TransferStatus"
              }
            }
          },
          {
            "name": "FromTimestamp",
            "in": "query",
            "description": "Transfer created minimum timestamp.",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "ToTimestamp",
            "in": "query",
            "description": "Transfer created maximum timestamp.",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "MinAmountInFiat",
            "in": "query",
            "description": "Minimum amount in fiat.",
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "MaxAmountInFiat",
            "in": "query",
            "description": "Maximum amount in fiat.",
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "OrderBy",
            "in": "query",
            "description": "Order by column.",
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/TransferOrderByFields"
                }
              ]
            }
          },
          {
            "name": "Hash",
            "in": "query",
            "description": "Transfer hash.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "SubClientId",
            "in": "query",
            "description": "Sub-client identifier.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "DescendingOrder",
            "in": "query",
            "description": "Value indicating if ordering is descending.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Transfers obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransferModelPaginationResponseApiResult"
                },
                "example": {"content":{"items":[{"id":"8e25acb5-a9e2-4d00-8772-a255f010a2a9","clientTransactionId":"123456","institutionTransactionId":"456789","userId":"123456798","status":"succeeded","amountInFiat":1000.3,"amountToReceiveInFiat":0,"amountInFiatCurrencyCode":"USD","amount":10.123,"amountToReceive":0,"symbol":"WETH","tokenAddress":"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619","networkName":"Polygon","networkId":"00000000-0000-0000-0000-000000000000","networkLogoUrl":"https://frontuserfilecdn.azureedge.net/public/logos/networks/Polygon.svg","createdTimestamp":1653211113,"from":{"logoUrl":"https://logo.com/logo.jpg","id":"8e25acb5-a9e2-4d00-8772-a255f010a2a9","type":"robinhood","name":"Robinhood"},"hash":"0x77f3a280aa5cfe956a5759c24cf774325504070b32b4159...","infoUrl":"https://polygonscan.com/tx/0x5b0ac59e43b63f2985d78994b6270d747f1019777201ca18ebb36ad1e1a8693e","gasFee":{"fee":0.0001,"feeCurrency":"MATIC","feeInFiat":0.1},"withdrawalFee":{"fee":0.0001,"feeCurrency":"WETH","feeInFiat":0.1},"processingFee":{"fee":0.0001,"feeCurrency":"WETH","feeInFiat":0.1},"executedTimestamp":1707462614,"transferType":"payment","isFeeIncluded":false,"sourceAmount":10.122,"destinationAmount":10,"totalFeesAmountInFiat":0.5,"totalTransactionAmountInFiat":1000.5,"fundingMethods":[{"type":"cryptocurrencyConversion","amount":2,"amountInFiat":20,"toSymbol":"WETH","fromAmount":1,"fromSymbol":"BTC","fee":{"fee":0.0001,"feeCurrency":"ETH","feeInFiat":0.1}},{"type":"paymentMethodDepositUsage","amount":3,"amountInFiat":30,"toSymbol":"WETH","fromAmount":1,"fromSymbol":"USD","paymentMethodType":"bankAccount","fee":{"fee":0.0001,"feeCurrency":"USD","feeInFiat":0.1}},{"type":"existingCryptocurrencyBalance","amount":5,"amountInFiat":50,"toSymbol":"WETH","fromAmount":5,"fromSymbol":"ETH"}]},{"id":"12345678-a9e2-4d00-8772-a255f010a2a9","clientTransactionId":"123456","institutionTransactionId":"456789","userId":"123456798","status":"failed","amountInFiat":10.3,"amountToReceiveInFiat":0,"amountInFiatCurrencyCode":"USD","amount":0.123,"amountToReceive":0,"symbol":"WETH","tokenAddress":"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619","networkName":"Polygon","networkId":"00000000-0000-0000-0000-000000000000","createdTimestamp":1653211113,"from":{"logoUrl":"https://logo.com/logo.jpg","id":"8e25acb5-a9e2-4d00-8772-a255f010a2a9","type":"deFiWallet","name":"MetaMask"},"hash":"0x77f3a280aa5cfe956a5759c24cf774325504070b32b4159...","isFeeIncluded":false,"totalFeesAmountInFiat":0,"totalTransactionAmountInFiat":10.3,"fundingMethods":[]}],"total":10},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/managed/update": {
      "post": {
        "tags": [
          "Managed Transfers"
        ],
        "summary": "Update transfer status",
        "description": "**Updates the previously executed transfer.**\r\n\n\r\n---\r\nUpdates the transfer status, using the `TransactionId` value.\r\nReturns the status of the transfer and the details of the transfer.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateTransferStatusRequest"
                  }
                ]
              },
              "examples": {
                "Update transfer status": {
                  "value": {"transactionId":"29B185B1-2305-40FB-A0E2-929D61451568","authToken":"Secret authentication token","type":"robinhood"}
                }
              }
            },
            "text/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateTransferStatusRequest"
                  }
                ]
              },
              "examples": {
                "Update transfer status": {
                  "value": {"transactionId":"29B185B1-2305-40FB-A0E2-929D61451568","authToken":"Secret authentication token","type":"robinhood"}
                }
              }
            },
            "application/*+json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/UpdateTransferStatusRequest"
                  }
                ]
              },
              "examples": {
                "Update transfer status": {
                  "value": {"transactionId":"29B185B1-2305-40FB-A0E2-929D61451568","authToken":"Secret authentication token","type":"robinhood"}
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateTransferResponseApiResult"
                },
                "examples": {
                  "Successful transfer update": {
                    "value": {"content":{"status":"succeeded","statusDetails":"unknown","transferResult":{"id":"e332336c-de22-11ed-b5ea-0242ac120002","clientTransactionId":"client-transaction-id","status":"succeeded","amountInFiat":10,"amount":10,"symbol":"USDT","networkName":"Ethereum","createdTimestamp":0,"hash":"0xdcfd72635a9b16d3bc0e75311f6fe0612970e9714a1e9e93de0ea5acffc6a454"}},"status":"ok","message":"","errorType":""}
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have write permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/holdings/get": {
      "post": {
        "tags": [
          "Portfolio"
        ],
        "summary": "Get holdings.",
        "description": "Obtain assets from the connected investment account. Performs realtime API call to the underlying integration.",
        "requestBody": {
          "description": "Request containing authentication token",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PortfolioHoldingsRequest"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Holdings obtained",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HoldingsModelApiResult"
                },
                "examples": {
                  "Trading platform example": {
                    "value": {"content":{"equityPositions":[{"symbol":"AAPL","amount":3,"costBasis":109},{"symbol":"F","amount":27,"costBasis":7.05791}],"cryptocurrencyPositions":[{"marketValue":75.15,"lastPrice":0.05,"symbol":"DOGE","amount":1503,"costBasis":0.033},{"symbol":"BTC","amount":3.00016720,"costBasis":18000}],"status":"succeeded","errorMessage":"","displayMessage":"","notSupportedEquityPositions":[{"symbol":"CUSIP38259P508","amount":1}],"notSupportedCryptocurrencyPositions":[],"nftPositions":[],"optionPositions":[],"type":"robinhood","accountId":"5FUVPB0","institutionName":"Robinhood","accountName":"Margin account"},"status":"ok","message":"","errorType":""}
                  },
                  "Self-custody cryptocurrency wallet example": {
                    "value": {"content":{"equityPositions":[],"cryptocurrencyPositions":[{"marketValue":75.15,"lastPrice":0.05,"symbol":"DOGE","amount":1503,"costBasis":0.033,"distribution":[{"caipNetworkId":"eip155:1","address":"0x1111111111111111111111111111111111111111","amount":1500},{"caipNetworkId":"eip155:42161","address":"0x1111111111111111111111111111111111111111","amount":3}]},{"symbol":"BTC","amount":3.00016720,"costBasis":18000,"distribution":[{"caipNetworkId":"bip122:000000000019d6689c085ae165831e93","address":"bc1q5cyxnuxmeuwuvkwfem96lxyepd5t0gd5nqf6h4","amount":1},{"caipNetworkId":"bip122:000000000019d6689c085ae165831e93","address":"bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf7du0","amount":1},{"caipNetworkId":"bip122:000000000019d6689c085ae165831e93","address":"bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh","amount":1.00016720}]}],"status":"succeeded","errorMessage":"","displayMessage":"","notSupportedEquityPositions":[],"notSupportedCryptocurrencyPositions":[],"nftPositions":[],"optionPositions":[],"type":"deFiWallet","accountId":"8c02d545753b596075ecbc20e2b7d3fb5b380c52","institutionName":"DeFiWallet","accountName":"MetaMask wallet"},"status":"ok","message":"","errorType":""}
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have read permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/holdings/value": {
      "post": {
        "tags": [
          "Portfolio"
        ],
        "summary": "Get holdings values.",
        "description": "Obtain assets from the connected investment account and return total value and performance.\r\nPerforms realtime API call to the underlying integration.",
        "requestBody": {
          "description": "Request with authentication token.",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PortfolioBrokerBaseRequest"
                  }
                ]
              },
              "example": {"authToken":"Secret authentication token","type":"binanceInternationalDirect"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Market values of assets",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BrokerPortfolioValueModelApiResult"
                },
                "example": {"content":{"totalValue":186.03,"totalPerformance":6.23,"equitiesValue":100.12,"equitiesPerformance":5.3457,"cryptocurrenciesValue":50.37,"cryptocurrenciesPerformance":7.23,"nftsValue":15.34,"fiatValue":20.2},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have read permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/holdings/portfolio": {
      "get": {
        "tags": [
          "Portfolio"
        ],
        "summary": "Get aggregated portfolio",
        "description": "Get the aggregated portfolio of the user containing market values.",
        "parameters": [
          {
            "name": "UserId",
            "in": "query",
            "description": "End user ID to get the aggregated portfolio for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "TimezoneOffset",
            "in": "query",
            "description": "Offset in second, used to calculate daily return for cryptocurrencies.",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Portfolio obtained",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BPortfolioModelApiResult"
                },
                "examples": {
                  "CEX example": {
                    "value": {"content":{"portfolioCostBasis":1819.90,"actualPortfolioPerformance":6.1,"equitiesValue":1934.78,"cryptocurrenciesValue":1185.12,"nftsValue":0,"equityPositions":[{"portfolioPercentage":0.44,"totalReturn":-1.30,"returnPercentage":-8.67,"companyName":"Tesla","totalDailyReturn":0.45,"dailyReturnPercentage":3.45,"marketValue":13.69,"lastPrice":214.44,"symbol":"TSLA","amount":0.063,"costBasis":234.80},{"portfolioPercentage":38.98,"totalReturn":144.97,"returnPercentage":13.71,"companyName":"Apple","totalDailyReturn":31.65,"dailyReturnPercentage":2.70,"marketValue":1201.67,"lastPrice":147.27,"symbol":"AAPL","amount":8.15,"costBasis":129.50}],"cryptocurrencyPositions":[{"portfolioPercentage":11.4018,"totalReturn":-592.6533,"returnPercentage":-62.7737,"companyName":"Ethereum","totalDailyReturn":-3.6081,"dailyReturnPercentage":-1.0162,"marketValue":351.4570,"lastPrice":1350.07,"symbol":"ETH","amount":0.260325000,"costBasis":3626.660},{"portfolioPercentage":7.80,"totalReturn":-85.45,"returnPercentage":-26.20,"companyName":"Dogecoin","totalDailyReturn":-2.45,"dailyReturnPercentage":-1.0103,"marketValue":240.5754,"lastPrice":0.05977,"symbol":"DOGE","amount":4025.02,"costBasis":0.081}],"nftPositions":[]},"status":"ok","message":"","errorType":""}
                  },
                  "Self-custody cryptocurrency wallet example": {
                    "value": {"content":{"portfolioCostBasis":3626.74,"actualPortfolioPerformance":5.4,"equitiesValue":0,"cryptocurrenciesValue":592.03,"nftsValue":0,"equityPositions":[],"cryptocurrencyPositions":[{"portfolioPercentage":11.4018,"totalReturn":-592.6533,"returnPercentage":-62.7737,"companyName":"Ethereum","totalDailyReturn":-3.6081,"dailyReturnPercentage":-1.0162,"marketValue":351.4570,"lastPrice":1350.07,"symbol":"ETH","amount":0.260325000,"costBasis":3626.660,"distribution":[{"caipNetworkId":"eip155:1","address":"0x1111111111111111111111111111111111111111","amount":0.16},{"caipNetworkId":"eip155:42161","address":"0x1111111111111111111111111111111111111111","amount":0.100325000}]},{"portfolioPercentage":7.80,"totalReturn":-85.45,"returnPercentage":-26.20,"companyName":"Dogecoin","totalDailyReturn":-2.45,"dailyReturnPercentage":-1.0103,"marketValue":240.5754,"lastPrice":0.05977,"symbol":"DOGE","amount":4025.02,"costBasis":0.081,"distribution":[{"caipNetworkId":"eip155:1","address":"0x1111111111111111111111111111111111111111","amount":2025.02},{"caipNetworkId":"eip155:42161","address":"0x1111111111111111111111111111111111111111","amount":2000}]}],"nftPositions":[]},"status":"ok","message":"","errorType":""}
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"ok","message":"","errorType":""}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have read permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/catalog/solana/getLatestBlockhash": {
      "post": {
        "tags": [
          "QuickNode"
        ],
        "parameters": [
          {
            "name": "chainId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StringApiResult"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/api/v1/transactions/list": {
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get transactions",
        "description": "Get transactions on the account - the paginated history of the executed orders along with the pending orders.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransactionsB2BBrokerOrderListRequest"
                  }
                ]
              },
              "example": {"count":20,"statuses":["success"],"authToken":"Secret authentication token","type":"robinhood"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transactions obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerOrderListResponseApiResult"
                },
                "example": {"content":{"transactions":[{"id":"17EC1243-D91A-48B6-B0CE-ECFDB134F8A0","side":"buy","symbol":"AAPL","name":"APPLE INC","assetType":"option","paymentSymbol":"USD","paymentType":"fiat","amount":1,"price":120,"value":120,"createdTimestamp":1653215676,"updatedTimestamp":1653215697,"status":"success","orderType":"market","timeInForce":"goodForDay","brokerType":"robinhood","transactionType":"order","optionDetails":{"optionType":"call","direction":"buyToOpen","strikePrice":200,"expirationTimestamp":1673215697,"numberOfSharesInContract":100,"complexOrderStrategyType":"NONE"}},{"id":"F9E932AE-A780-42F3-B887-82D888D594E5","side":"sell","symbol":"AAPL","name":"APPLE INC","assetType":"equity","paymentSymbol":"USD","paymentType":"fiat","amount":2,"price":130,"value":260,"createdTimestamp":1651739676,"updatedTimestamp":1651739781,"status":"success","orderType":"market","timeInForce":"goodTillCanceled","brokerType":"robinhood","transactionType":"order"},{"id":"9B5827E4-7D08-4A71-B4C0-B1B4E5562592","side":"buy","symbol":"BTC","name":"Bitcoin","assetType":"cryptocurrency","paymentSymbol":"ETH","paymentType":"cryptocurrency","amount":0.3,"price":18604.8197,"value":5581.44591,"createdTimestamp":1651739676,"updatedTimestamp":1651739781,"status":"success","orderType":"limit","timeInForce":"goodTillCanceled","brokerType":"robinhood","transactionType":"order"}],"cursor":"N2VkZDI0MDMtNmRhYy01NThhLTk5NDUDYzI12M3GQ3ZmQ2","total":3,"earliestTimestamp":1651739676},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have read permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transactions/details": {
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get transaction details",
        "description": "Get details of an executed order. Typically used to poll the status of the previously executed order.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransactionsB2BBrokerOrderRequest"
                  }
                ]
              },
              "example": {"id":"17EC1243-D91A-48B6-B0CE-ECFDB134F8A0","isCryptocurrency":true,"authToken":"Secret authentication token","type":"robinhood"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transactions obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerOrderApiResult"
                },
                "example": {"id":"17EC1243-D91A-48B6-B0CE-ECFDB134F8A0","side":"buy","symbol":"AAPL","assetType":"equity","paymentType":"fiat","amount":1,"price":120,"value":120,"createdTimestamp":1653215676,"updatedTimestamp":1653215697,"status":"success","statusDetails":"","brokerType":"robinhood","transactionType":"order"}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have read permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "404": {
            "description": "Transaction is not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/transactions/featureList": {
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get supported order features for institution",
        "description": "Get supported features for trading for a particular financial institution. Different institutions support different\r\nfeatures (e.g. different `OrderType` or different sets of `TimeInForce` values), so this endpoint is used to\r\ndescribe such features for provided financial institution.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransactionsBrokerBaseRequest"
                  }
                ]
              },
              "example": {"authToken":"Secret authentication token","type":"binanceInternationalDirect"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Feature list obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerTradingFeatureInfoApiResult"
                },
                "example": {"content":{"brokerType":"robinhood","accountId":"5K9N3VO1","cryptocurrencyOrders":{"supported":true,"supportsFiatCurrencyPayment":true,"supportsCryptocurrencyPayment":false,"supportsMarginOrders":true,"supportedCryptocurrencySymbols":["BTC","ETH","SOL","DOGE"],"supportedFiatCurrencies":["USD"],"marketType":{"supported":true,"supportsFractionalShares":true,"supportsExtendedMarketHours":true,"supportsPlacingBuyOrdersInFiatAmount":false,"supportsPlacingSellOrdersInFiatAmount":false,"supportedTimeInForceList":["fillOrKill","goodForDay","goodTillCanceled","immediateOrCancel"],"supportsPlacingBuyOrdersInPaymentSymbolAmount":false,"supportsPlacingSellOrdersInPaymentSymbolAmount":false,"supportsPlacingBuyOrdersInBaseSymbolAmount":true,"supportsPlacingSellOrdersInBaseSymbolAmount":true},"limitType":{"supported":true,"supportsFractionalShares":true,"supportsExtendedMarketHours":true,"supportsPlacingBuyOrdersInFiatAmount":false,"supportsPlacingSellOrdersInFiatAmount":false,"supportedTimeInForceList":["goodForDay","goodTillCanceled","immediateOrCancel"],"supportsPlacingBuyOrdersInPaymentSymbolAmount":false,"supportsPlacingSellOrdersInPaymentSymbolAmount":false,"supportsPlacingBuyOrdersInBaseSymbolAmount":true,"supportsPlacingSellOrdersInBaseSymbolAmount":true},"stopLossType":{"supported":true,"supportsFractionalShares":true,"supportsExtendedMarketHours":true,"supportsPlacingBuyOrdersInFiatAmount":false,"supportsPlacingSellOrdersInFiatAmount":false,"supportedTimeInForceList":["fillOrKill","goodForDay","goodTillCanceled","immediateOrCancel"],"supportsPlacingBuyOrdersInPaymentSymbolAmount":false,"supportsPlacingSellOrdersInPaymentSymbolAmount":false,"supportsPlacingBuyOrdersInBaseSymbolAmount":true,"supportsPlacingSellOrdersInBaseSymbolAmount":true}},"stockOrders":{"supported":true,"supportsFiatCurrencyPayment":true,"supportsCryptocurrencyPayment":false,"supportsMarginOrders":true,"supportedFiatCurrencies":["USD"],"marketType":{"supported":true,"supportsFractionalShares":true,"supportsExtendedMarketHours":true,"supportsPlacingBuyOrdersInFiatAmount":false,"supportsPlacingSellOrdersInFiatAmount":false,"supportedTimeInForceList":["fillOrKill","goodForDay","goodTillCanceled","immediateOrCancel"],"supportsPlacingBuyOrdersInPaymentSymbolAmount":false,"supportsPlacingSellOrdersInPaymentSymbolAmount":false,"supportsPlacingBuyOrdersInBaseSymbolAmount":false,"supportsPlacingSellOrdersInBaseSymbolAmount":false},"limitType":{"supported":true,"supportsFractionalShares":true,"supportsExtendedMarketHours":true,"supportsPlacingBuyOrdersInFiatAmount":false,"supportsPlacingSellOrdersInFiatAmount":false,"supportedTimeInForceList":["goodForDay","goodTillCanceled","immediateOrCancel"],"supportsPlacingBuyOrdersInPaymentSymbolAmount":false,"supportsPlacingSellOrdersInPaymentSymbolAmount":false,"supportsPlacingBuyOrdersInBaseSymbolAmount":false,"supportsPlacingSellOrdersInBaseSymbolAmount":false},"stopLossType":{"supported":true,"supportsFractionalShares":true,"supportsExtendedMarketHours":true,"supportsPlacingBuyOrdersInFiatAmount":false,"supportsPlacingSellOrdersInFiatAmount":false,"supportedTimeInForceList":["fillOrKill","goodForDay","goodTillCanceled","immediateOrCancel"],"supportsPlacingBuyOrdersInPaymentSymbolAmount":false,"supportsPlacingSellOrdersInPaymentSymbolAmount":false,"supportsPlacingBuyOrdersInBaseSymbolAmount":false,"supportsPlacingSellOrdersInBaseSymbolAmount":false}},"cryptocurrencyAssetPairTrading":{"supported":true,"supportedCryptocurrencySymbols":["BTC","ETH","SOL","DOGE"],"supportedFiatCurrencies":["USD"],"supportedTradingPairs":["BTC-ETH","BTC-USD","ETH-SOL","ETH-USD","SOL-USD","DOGE-USD"],"marketType":{"supported":true,"supportedTimeInForceList":["immediateOrCancel"],"supportsPlacingBuyOrdersInBaseSymbolAmount":false,"supportsPlacingSellOrdersInBaseSymbolAmount":true,"supportsPlacingBuyOrdersInQuoteSymbolAmount":true,"supportsPlacingSellOrdersInQuoteSymbolAmount":false},"limitType":{"supported":true,"supportedTimeInForceList":["goodTillCanceled","goodTillDate"],"supportsPlacingBuyOrdersInBaseSymbolAmount":true,"supportsPlacingSellOrdersInBaseSymbolAmount":true,"supportsPlacingBuyOrdersInQuoteSymbolAmount":true,"supportsPlacingSellOrdersInQuoteSymbolAmount":true}},"cryptocurrencyConversion":{"supported":true,"supportsPreview":true,"supportedCryptocurrencySymbols":["BTC","ETH","SOL","DOGE"],"supportedFiatCurrencies":["USD"]},"status":"succeeded","supportsOrderPreview":true,"supportsPriceQuotes":false,"supportsOrderCancellation":true,"isIntegrationUp":true,"isTradingSupported":true,"fiatBalances":[{"cash":1355,"buyingPower":1355,"cryptocurrencyBuyingPower":1355,"currencyCode":"USD"}],"usesSpreads":false},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transactions/preview/{side}": {
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Preview order execution",
        "description": "Validates the order information (such as necessary balance availability), and returns additional information,\r\nsuch as expected order fee.\r\nDoes not execute the order.",
        "parameters": [
          {
            "name": "side",
            "in": "path",
            "required": true,
            "schema": {
              "enum": [
                "unknown",
                "buy",
                "sell"
              ],
              "allOf": [
                {
                  "$ref": "#/components/schemas/BrokerOrderType"
                }
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransactionsB2BBrokerCreateOrderRequest"
                  }
                ]
              },
              "examples": {
                "Cryptocurrency Limit example": {
                  "value": {"symbol":"ETH","paymentSymbol":"USD","amount":1,"price":1200,"isCryptocurrency":true,"paymentIsCryptocurrency":false,"amountIsFiat":false,"amountIsInPaymentSymbol":false,"extendedHours":false,"orderType":"limit","timeInForce":"goodForDay","authToken":"Secret authentication token","type":"robinhood"}
                },
                "Stock Market example": {
                  "value": {"symbol":"AAPL","paymentSymbol":"USD","amount":1,"price":0,"isCryptocurrency":false,"paymentIsCryptocurrency":false,"amountIsFiat":false,"amountIsInPaymentSymbol":false,"extendedHours":false,"orderType":"market","timeInForce":"goodTillCanceled","authToken":"Secret authentication token","type":"robinhood"}
                },
                "Stock Payment/Quote amount example ('buy TSLA for $10')": {
                  "value": {"symbol":"TSLA","paymentSymbol":"USD","amount":0,"price":0,"isCryptocurrency":false,"paymentIsCryptocurrency":false,"amountIsFiat":true,"amountInFiat":10,"amountIsInPaymentSymbol":true,"amountInPaymentSymbol":10,"extendedHours":false,"orderType":"market","timeInForce":"goodTillCanceled","authToken":"Secret authentication token","type":"robinhood"}
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Order preview obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerPreviewOrderResultApiResult"
                },
                "example": {"content":{"brokerType":"robinhood","fee":1.99,"feeText":"","amount":1,"side":"buy","status":"success","paymentSymbol":"USD","paymentIsCryptocurrency":false,"estimatedUnitPrice":1200},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Request details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have write permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transactions/{side}": {
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Execute order",
        "description": "Validates the order information and then calls institution's API to execute an order.\r\nIt's recommended to call this endpoint after calling the `preview` endpoint to make sure that the\r\norder execution request is correct.",
        "parameters": [
          {
            "name": "side",
            "in": "path",
            "required": true,
            "schema": {
              "enum": [
                "unknown",
                "buy",
                "sell"
              ],
              "allOf": [
                {
                  "$ref": "#/components/schemas/BrokerOrderType"
                }
              ]
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransactionsB2BBrokerCreateOrderRequest"
                  }
                ]
              },
              "examples": {
                "Cryptocurrency Limit example": {
                  "value": {"symbol":"ETH","paymentSymbol":"USD","amount":1,"price":1200,"isCryptocurrency":true,"paymentIsCryptocurrency":false,"amountIsFiat":false,"amountIsInPaymentSymbol":false,"extendedHours":false,"orderType":"limit","timeInForce":"goodForDay","authToken":"Secret authentication token","type":"robinhood"}
                },
                "Stock Market example": {
                  "value": {"symbol":"AAPL","paymentSymbol":"USD","amount":1,"price":0,"isCryptocurrency":false,"paymentIsCryptocurrency":false,"amountIsFiat":false,"amountIsInPaymentSymbol":false,"extendedHours":false,"orderType":"market","timeInForce":"goodTillCanceled","authToken":"Secret authentication token","type":"robinhood"}
                },
                "Stock Payment/Quote amount example ('buy TSLA for $10')": {
                  "value": {"symbol":"TSLA","paymentSymbol":"USD","amount":0,"price":0,"isCryptocurrency":false,"paymentIsCryptocurrency":false,"amountIsFiat":true,"amountInFiat":10,"amountIsInPaymentSymbol":true,"amountInPaymentSymbol":10,"extendedHours":false,"orderType":"market","timeInForce":"goodTillCanceled","authToken":"Secret authentication token","type":"robinhood"}
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Order executed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerCreateOrderResultApiResult"
                },
                "example": {"content":{"orderId":"6713DCDC-3D2E-46BC-ACB6-CF5FDE431CE2","brokerType":"robinhood","side":"buy","amount":1,"price":1200,"value":1200,"fee":1.99,"timestamp":1661904014,"status":"success","statusDetails":"Executed successfully","timeInForce":"goodTillCanceled"},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Request details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have write permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transactions/cancel": {
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Cancel order execution",
        "description": "Cancels a pending order (an order with `InProgress` status).\r\n`SymbolPair` is required to be provided for `Binance`, `BinanceInternational`, `Okx` and `BitFlyer` institutions.\r\nThis value",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransactionsB2BBrokerOrderRequest"
                  }
                ]
              },
              "example": {"id":"17EC1243-D91A-48B6-B0CE-ECFDB134F8A0","isCryptocurrency":true,"authToken":"Secret authentication token","type":"robinhood"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Order canceled.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                }
              }
            }
          },
          "400": {
            "description": "Request details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have write permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/transactions/symbolinfo": {
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get symbol information",
        "description": "Returns information on trading allowance for a provided symbol.\r\nFor example - some institutions allow fractional trading for some symbols, but do not allow it\r\nfor others. So before placing an order the API client can check if the required symbol can be traded fractionally\r\nwith the provided institution.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransactionsB2BBrokerSymbolInfoForOrderRequest"
                  }
                ]
              },
              "example": {"side":"buy","symbol":"BTC","amount":0,"price":0,"isCryptocurrency":false,"paymentIsCryptocurrency":false,"amountIsFiat":false,"amountIsInPaymentSymbol":false,"extendedHours":false,"orderType":"market","timeInForce":"goodTillCanceled","type":"robinhood"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Information for symbol obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerOrderSymbolInfoApiResult"
                },
                "example": {"content":{"fractionalTradingAllowance":"fractionalTradingAllowed","minimumOrderValue":0.001,"precisionScale":6},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Request details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProblemDetails"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/list": {
      "post": {
        "tags": [
          "Transfers"
        ],
        "summary": "Get transfer history",
        "description": "Get entire history of cryptocurrency transfers (withdrawals or deposits) executed from an exchange.\r\nOnly supports Exchange integrations.",
        "requestBody": {
          "description": "Authentication token and integration type to obtain the list of transfers.",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransfersBrokerTransactionsListRequest"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transfers obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerTransactionsListModelApiResult"
                },
                "example": {"content":{"transfers":[{"id":"8E25ACB5-A9E2-4D00-8772-A255F010A2A9","status":"succeeded","type":"deposit","fromAddress":"D5PumQwt...","targetAddress":"D641Fmzx...","symbol":"DOGE","hash":"3310c6202aaeb44754a118ce11f255382d012060ade0d6d9f...","amount":15,"transactionAmount":10,"createdTimestamp":1653215600,"updatedTimestamp":1653215600,"networkTransactionFee":{"amount":5,"symbol":"DOGE"},"confirmations":17,"blockchainMethod":"transfer"},{"id":"70E6E3CF-5ACF-49C5-A4E1-5FB85A567F26","status":"succeeded","type":"withdrawal","fromAddress":"0x7BDE8361Fe587daD0e35448E754...","targetAddress":"0x83C8F28c26bF6aaca652Df1DbBE...","symbol":"ETH","hash":"0x77f3a280aa5cfe956a5759c24cf774325504070b32b4159...","amount":0.1,"transactionAmount":0.099,"createdTimestamp":1653211113,"updatedTimestamp":1653211113,"networkTransactionFee":{"amount":0.001,"symbol":"ETH"},"confirmations":18,"blockchainMethod":"transfer"}],"total":2,"cursor":"N2VkZDI0MDMtNmRhYy01NThhLTk5NDUDYzI12M3GQ3ZmQ2","earliestTimestamp":1653211113},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have read permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/details": {
      "post": {
        "tags": [
          "Transfers"
        ],
        "summary": "Get transfer details",
        "description": "Get details of a specific transfer (withdrawals or deposits) executed from an exchange.\r\nOnly supports Exchange integrations.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransfersBrokerCryptocurrencyTransactionDetailsRequest"
                  }
                ]
              },
              "example": {"transactionId":"63F1A6B6-BF45-4E51-A624-EC52B5680D48","authToken":"Secret authentication token","type":"robinhood"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transfer details obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerCryptocurrencyTransactionApiResult"
                },
                "example": {"content":{"id":"8E25ACB5-A9E2-4D00-8772-A255F010A2A9","status":"succeeded","type":"deposit","fromAddress":"D5PumQwt...","targetAddress":"D641Fmzx...","symbol":"DOGE","hash":"3310c6202aaeb44754a118ce11f255382d012060ade0d6d9f...","amount":15,"transactionAmount":10,"createdTimestamp":1653215600,"updatedTimestamp":1653215600,"networkTransactionFee":{"amount":5,"symbol":"DOGE"},"confirmations":17,"blockchainMethod":"transfer"},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Transfer details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have read permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "404": {
            "description": "Transfer with provided id was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"notFound","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers": {
      "post": {
        "tags": [
          "Transfers"
        ],
        "summary": "Initiate a transfer",
        "description": "Initiate a new cryptocurrency transfer on a blockchain, cryptocurrency broker or cryptocurrency exchange.\r\nObsolete endpoint, please use POST /transfers/managed/execute endpoint instead.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransfersBrokerCreateCryptocurrencyTransactionRequest"
                  }
                ]
              },
              "examples": {
                "Transfer using AddressType (DOGE over DOGE chain)": {
                  "value": {"data":"Some memo","targetAddress":"D641Fmzx...","amount":100,"fee":5,"addressType":"dogeAddress","mfaCode":"000000","password":"$sb7u26","tryAnotherMfa":false,"authToken":"Secret authentication token","type":"coinbase"}
                },
                "Transfer using symbol and chain (USDT as ERC-20 over Ethereum chain)": {
                  "value": {"data":"Some memo","targetAddress":"0x4Df61A3CcfB...","amount":100,"fee":0,"mfaCode":"000000","chain":"ETH","symbol":"USDT","tryAnotherMfa":false,"authToken":"Secret authentication token","type":"coinbase"}
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transfer successfully initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerCreateCryptocurrencyTransactionResponseApiResult"
                },
                "example": {"content":{"failed":false,"status":"pending","statusDetails":"Accepted","transaction":{"id":"8E25ACB5-A9E2-4D00-8772-A255F010A2A9","status":"pending","type":"withdrawal","fromAddress":"D5PumQwt...","targetAddress":"D641Fmzx...","symbol":"DOGE","hash":"3310c6202aaeb44754a118ce11f255382d012060ade0d6d9f...","amount":105,"transactionAmount":100,"createdTimestamp":1653215600,"updatedTimestamp":1653215600,"networkTransactionFee":{"amount":5,"symbol":"DOGE"},"confirmations":3,"blockchainMethod":"transfer"},"fallbackMfaAvailable":false},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Transfer details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          },
          "403": {
            "description": "The API key used does not have write permission to call this Mesh endpoint.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        },
        "deprecated": true
      }
    },
    "/api/v1/transfers/address/get": {
      "post": {
        "tags": [
          "Transfers"
        ],
        "summary": "Get deposit address",
        "description": "Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransfersBrokerCryptocurrencyDepositAddressRequest"
                  }
                ]
              },
              "example": {"symbol":"DOGE","chain":"DOGE","authToken":"Secret authentication token","type":"robinhood"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Address successfully obtained or generation initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerCryptocurrencyDepositAddressResponseApiResult"
                },
                "example": {"content":{"symbol":"DOGE","address":"D641Fmzx...","chain":"DOGE"},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Request details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "404": {
            "description": "Address for the required symbol is not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"notFound","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/transfers/symbol/details": {
      "post": {
        "tags": [
          "Transfers"
        ],
        "summary": "Get details of asset",
        "description": "Get details of the asset for deposit or withdrawal. For example, several exchanges support same tokens over multiple\r\nblockchains, and thus require the name of chain to be supplied for transfers. This endpoint allows getting such details.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TransfersBrokerCryptocurrencyDepositAddressRequest"
                  }
                ]
              },
              "example": {"symbol":"DOGE","chain":"DOGE","authToken":"Secret authentication token","type":"robinhood"}
            }
          }
        },
        "responses": {
          "200": {
            "description": "Address successfully obtained or generation initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/B2BBrokerCryptocurrencySymbolDetailsResponseApiResult"
                },
                "example": {"content":{"symbol":"ETH","addressTypes":["ethAddress"],"chains":[{"chain":"Ethereum","fee":0.00001}]},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Request details are not correct.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "404": {
            "description": "Asset details for provided symbol are not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"notFound","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    },
    "/api/v1/wallets/verify": {
      "get": {
        "tags": [
          "Wallets"
        ],
        "summary": "Get wallet verifications for user and address.",
        "parameters": [
          {
            "name": "UserId",
            "in": "query",
            "description": "User identifier.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "Address",
            "in": "query",
            "description": "Address of the wallet.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Verifications obtained.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeFiWalletVerificationResponseApiResult"
                },
                "example": {"content":{"verifications":[{"userId":"user-1","address":"address-1","networkType":"evm","verificationMethod":"signedMessage","message":"Some test message","signedMessageHash":"signature-1","timestamp":1733896980},{"userId":"user-1","address":"address-2","networkType":"evm","verificationMethod":"signedMessage","message":"Some test message","signedMessageHash":"signature-2","timestamp":1733896980}]},"status":"ok","message":"","errorType":""}
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResult"
                },
                "example": {"status":"badRequest","message":"Error message","displayMessage":"Optional display message","errorType":"missingField"}
              }
            }
          },
          "401": {
            "description": "Unauthorized: Client Id or Client Secret are not correct or missing.",
            "content": {
              "application/json": {
                "schema": { }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AccountInfoType": {
        "enum": [
          "firstName",
          "middleName",
          "lastName",
          "accountNumber",
          "email",
          "mobileNumber",
          "companyName",
          "countryCode",
          "city",
          "postalCode",
          "address",
          "id",
          "dateOfBirth"
        ],
        "type": "string"
      },
      "ApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          }
        },
        "additionalProperties": false
      },
      "ApiResultStatus": {
        "enum": [
          "ok",
          "serverFailure",
          "permissionDenied",
          "badRequest",
          "notFound",
          "conflict",
          "tooManyRequest",
          "locked",
          "unavailableForLegalReasons"
        ],
        "type": "string"
      },
      "Asset": {
        "type": "object",
        "properties": {
          "symbol": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "type": {
            "enum": [
              "equity",
              "cryptocurrency"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetType"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AssetPaginationResponse": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Asset"
            },
            "description": "list of items",
            "nullable": true
          },
          "total": {
            "type": "integer",
            "description": "Total number of items",
            "format": "int32"
          }
        },
        "additionalProperties": false
      },
      "AssetPaginationResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AssetPaginationResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AssetType": {
        "enum": [
          "equity",
          "cryptocurrency"
        ],
        "type": "string"
      },
      "AuthFlowStep": {
        "enum": [
          "loginPassword",
          "mfaFlow",
          "faceVerification",
          "createAPIKey",
          "loginQrCode"
        ],
        "type": "string"
      },
      "AuthenticationFieldDescription": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the field, as expected from the API",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AuthenticationModel": {
        "type": "object",
        "properties": {
          "authResponse": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerAuthResponse"
              }
            ],
            "nullable": true
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AuthenticationFieldDescription"
            },
            "description": "Set of fields that are expected to be provided based on the status of the AuthResponse",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "AuthenticationSchemeType": {
        "enum": [
          "usernamePassword",
          "oAuth",
          "apiKey",
          "blockchainAddress",
          "trueAuth"
        ],
        "type": "string"
      },
      "B2BAssetType": {
        "enum": [
          "equity",
          "cryptocurrency",
          "option",
          "nft"
        ],
        "type": "string"
      },
      "B2BBrokerAccountBalance": {
        "type": "object",
        "properties": {
          "cash": {
            "type": "number",
            "description": "Withdrawable cash amount on the account.",
            "format": "double",
            "nullable": true
          },
          "buyingPower": {
            "type": "number",
            "description": "Buying power indicating the maximum amount the user can spend to buy assets. E.g. available margin.",
            "format": "double",
            "nullable": true
          },
          "cryptocurrencyBuyingPower": {
            "type": "number",
            "description": "Buying power available for placing cryptocurrency orders.",
            "format": "double",
            "nullable": true
          },
          "currencyCode": {
            "type": "string",
            "description": "ISO 4217 currency code.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAccountBalanceModel": {
        "type": "object",
        "properties": {
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/B2BBrokerAccountBalance"
            },
            "nullable": true
          },
          "totalCashUsdValue": {
            "type": "number",
            "description": "Total USD value of all currencies",
            "format": "double",
            "nullable": true
          },
          "totalBuyingPowerUsdValue": {
            "type": "number",
            "description": "Total USD value of all Buying Power",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAccountBalanceModelApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerAccountBalanceModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAccountDetailsRequest": {
        "required": [
          "authToken",
          "integrationId"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution."
          },
          "integrationId": {
            "type": "string",
            "description": "The Id which uniquely identifies the integration.",
            "format": "uuid"
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAccountDetailsResponse": {
        "type": "object",
        "properties": {
          "integrationName": {
            "type": "string",
            "nullable": true
          },
          "firstName": {
            "type": "string",
            "nullable": true
          },
          "middleName": {
            "type": "string",
            "nullable": true
          },
          "lastName": {
            "type": "string",
            "nullable": true
          },
          "accountNumber": {
            "type": "string",
            "nullable": true
          },
          "email": {
            "type": "string",
            "nullable": true
          },
          "mobileNumber": {
            "type": "string",
            "nullable": true
          },
          "companyName": {
            "type": "string",
            "nullable": true
          },
          "countryCode": {
            "type": "string",
            "nullable": true
          },
          "city": {
            "type": "string",
            "nullable": true
          },
          "postalCode": {
            "type": "string",
            "nullable": true
          },
          "address": {
            "type": "string",
            "nullable": true
          },
          "idType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserIdentificationType"
              }
            ],
            "nullable": true
          },
          "idNumber": {
            "type": "string",
            "nullable": true
          },
          "dateOfBirth": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAccountDetailsResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerAccountDetailsResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAuthPromptResponse": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "failed",
              "redirect",
              "openInBrokerModule"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerAuthPromptStatus"
              }
            ]
          },
          "redirectLink": {
            "type": "string",
            "nullable": true
          },
          "linkToken": {
            "type": "string",
            "nullable": true
          },
          "errorMessage": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAuthPromptResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerAuthPromptResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAuthRequest": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ]
          },
          "phone": {
            "type": "string",
            "nullable": true
          },
          "username": {
            "type": "string",
            "nullable": true
          },
          "password": {
            "type": "string",
            "nullable": true
          },
          "tradePin": {
            "type": "string",
            "nullable": true
          },
          "countryInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CountryInfo"
              }
            ],
            "nullable": true
          },
          "challengeId": {
            "type": "string",
            "nullable": true
          },
          "challengeCode": {
            "type": "string",
            "nullable": true
          },
          "challengeType": {
            "type": "string",
            "nullable": true
          },
          "challengeAnswer": {
            "type": "string",
            "description": "Used to provide answers to security questions",
            "nullable": true
          },
          "mfaCode": {
            "type": "string",
            "nullable": true
          },
          "mfaType": {
            "enum": [
              "phone",
              "email",
              "totp",
              "phoneAndEmail",
              "requireNextSecurityQuestion",
              "readEmail",
              "face",
              "tradingPin",
              "qrCode",
              "password",
              "roaming",
              "mobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/MfaType"
              }
            ]
          },
          "deviceInfo": {
            "type": "string",
            "nullable": true
          },
          "webData": {
            "type": "string",
            "nullable": true
          },
          "authFlowStep": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AuthFlowStep"
              }
            ],
            "nullable": true
          },
          "key": {
            "type": "string",
            "nullable": true
          },
          "authToken": {
            "type": "string",
            "nullable": true
          },
          "redirectLink": {
            "type": "string",
            "nullable": true
          },
          "confirmationEmail": {
            "type": "string",
            "nullable": true
          },
          "trueAuthAuthRequest": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TrueAuthAuthRequest"
              }
            ],
            "nullable": true
          },
          "isSensitiveFieldsEncrypted": {
            "type": "boolean",
            "description": "Indicates whether the sensitive fields in this request are encrypted.\r\nWhen set to true, the following fields should be encrypted using Base64 encoding:\r\n- Username\r\n- Password\r\n- Phone\r\n- TradePin\r\n- ChallengeAnswer\r\n- MfaCode\r\n- DeviceInfo\r\n- ConfirmationEmail\r\n            \r\nBase64 encoding is used to encode these fields into a format that can be safely transmitted and stored."
          },
          "isTryingAnotherWay": {
            "type": "boolean",
            "description": "Flag indicating that the user is attempting to switch to the next available 2FA\r\nmethod (e.g., Email, Google Authenticator) after failing to complete or canceling\r\nthe current verification method (e.g., Roaming 2FA).\r\n            \r\nThis field is primarily used for Robinhood and BinanceInternationalDirect on the DeviceConfirmationPage\r\nwhen a user clicks the \"Try Another Way\" button. It informs the backend to move to the next\r\nMFA method instead of retrying the current one."
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAuthResponse": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "failed",
              "challengeFailed",
              "succeeded",
              "challengeIssued",
              "mfaRequired",
              "openInBrokerModule",
              "delayed",
              "deviceConfirmationRequired",
              "emailVerification",
              "emailReceived",
              "captchaChallenge",
              "faceVerification",
              "bindMfaRequired",
              "apiKeyGenerationError",
              "qrCodeRequired",
              "qrCodeExpired",
              "deviceLoginVerified"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerAuthStatus"
              }
            ],
            "description": "Status of the request"
          },
          "mfaType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MfaType"
              }
            ],
            "nullable": true
          },
          "authFlowStep": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AuthFlowStep"
              }
            ],
            "description": "The AuthFlowStep is used to determine which state the authentication is in, for initial requests without MFA verification the value should be LoginPassword and when calling with MFA code it should be MfaFlow (currently used for BinanceInternationalDirect only).",
            "nullable": true
          },
          "qrCode": {
            "type": "string",
            "description": "Qr code used to scan and solve facial verification (currently used for BinanceInternationalDirect only).",
            "nullable": true
          },
          "qrCodeLink": {
            "type": "string",
            "nullable": true
          },
          "qrCodeLinkIOS": {
            "type": "string",
            "nullable": true
          },
          "challengeId": {
            "type": "string",
            "description": "Id of the challenge, relevant when the status is `ChallengeIssued`",
            "nullable": true
          },
          "challengeText": {
            "type": "string",
            "nullable": true
          },
          "challengeExpiresInSeconds": {
            "type": "integer",
            "description": "Life span of the challenge",
            "format": "int32",
            "nullable": true
          },
          "errorMessage": {
            "type": "string",
            "nullable": true
          },
          "accessToken": {
            "type": "string",
            "nullable": true,
            "deprecated": true
          },
          "refreshToken": {
            "type": "string",
            "nullable": true,
            "deprecated": true
          },
          "expiresInSeconds": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "refreshTokenExpiresInSeconds": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "account": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerAccount"
              }
            ],
            "nullable": true,
            "deprecated": true
          },
          "accountTokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerAccountTokens"
            },
            "nullable": true
          },
          "requiresReauthentication": {
            "type": "boolean",
            "nullable": true
          },
          "email": {
            "type": "string",
            "nullable": true
          },
          "allocatedIPAddress": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAuthResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerAuthResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerAuthStatus": {
        "enum": [
          "failed",
          "succeeded",
          "mfaRequired"
        ],
        "type": "string"
      },
      "B2BBrokerConversionFeature": {
        "type": "object",
        "properties": {
          "supported": {
            "type": "boolean"
          },
          "supportsPreview": {
            "type": "boolean"
          },
          "supportedCryptocurrencySymbols": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "supportedFiatCurrencies": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCreateCryptocurrencyTransactionResponse": {
        "type": "object",
        "properties": {
          "transactionId": {
            "type": "string",
            "description": "Transaction Id by the financial institution",
            "nullable": true
          },
          "failed": {
            "type": "boolean"
          },
          "mfaType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MfaType"
              }
            ],
            "nullable": true
          },
          "verificationSteps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MfaType"
            },
            "nullable": true
          },
          "qrCode": {
            "type": "string",
            "nullable": true
          },
          "qrCodeLink": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "enum": [
              "unknown",
              "failed",
              "frozen",
              "succeeded",
              "mfaRequired",
              "pending",
              "expired",
              "canceled",
              "waitingForSignature",
              "waitingForClearing",
              "awaitingApproval",
              "awaitingConfirmation",
              "awaitingVerification",
              "rejected",
              "pendingCancel",
              "emailVerification",
              "deviceConfirmationRequired",
              "mfaFailed",
              "addressWhitelistRequired",
              "secondMfaRequired",
              "emailConfirmationApprovalRequired",
              "travelRuleRequired"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerCryptocurrencyTransactionStatus"
              }
            ],
            "description": "Status of the operation"
          },
          "statusDetails": {
            "type": "string",
            "description": "Details of the current status of the transfer, as provided by the financial institution",
            "nullable": true
          },
          "transaction": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerCryptocurrencyTransaction"
              }
            ],
            "description": "Details of the created transaction",
            "nullable": true
          },
          "fallbackMfaAvailable": {
            "type": "boolean"
          },
          "challengeId": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCreateCryptocurrencyTransactionResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerCreateCryptocurrencyTransactionResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCreateOrderRequest": {
        "required": [
          "amount",
          "amountIsInPaymentSymbol",
          "authToken",
          "isCryptocurrency",
          "orderType",
          "paymentIsCryptocurrency",
          "paymentSymbol",
          "symbol",
          "timeInForce",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "symbol": {
            "minLength": 1,
            "type": "string",
            "description": "Symbol to trade. For example, `AAPL` or `ETH`"
          },
          "paymentSymbol": {
            "minLength": 1,
            "type": "string",
            "description": "Symbol to use for payment, defaults to `USD`."
          },
          "amount": {
            "type": "number",
            "description": "Amount of purchase.",
            "format": "double"
          },
          "price": {
            "type": "number",
            "description": "Price of the unit, used for `Limit` and `StopLoss` orders.",
            "format": "double"
          },
          "isCryptocurrency": {
            "type": "boolean",
            "description": "Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly."
          },
          "paymentIsCryptocurrency": {
            "type": "boolean",
            "description": "Indicates whether the `PaymentSymbol` is fiat or cryptocurrency"
          },
          "amountIsFiat": {
            "type": "boolean",
            "nullable": true,
            "deprecated": true
          },
          "amountInFiat": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "deprecated": true
          },
          "amountIsInPaymentSymbol": {
            "type": "boolean",
            "description": "This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be\r\nperformed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and\r\n`SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`\r\nvalue is passed."
          },
          "amountInPaymentSymbol": {
            "type": "number",
            "description": "Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`\r\nand `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.",
            "format": "double",
            "nullable": true
          },
          "extendedHours": {
            "type": "boolean",
            "description": "Specifies if the extended trading hours should be used."
          },
          "orderType": {
            "enum": [
              "market",
              "limit",
              "stopLoss"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderPlaceTypeTrade"
              }
            ]
          },
          "timeInForce": {
            "enum": [
              "goodTillCanceled",
              "immediateOrCancel",
              "fillOrKill",
              "goodForDay",
              "postOnly",
              "unknown"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderTimeInForceType"
              }
            ]
          },
          "mfaCode": {
            "type": "string",
            "description": "MFA Code to create an order (requested by Kraken if MFA is enabled in user settings)",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCreateOrderResult": {
        "type": "object",
        "properties": {
          "orderId": {
            "type": "string",
            "description": "Id of the order, as returned from the financial institution. Can be used to get the status of the order.",
            "nullable": true
          },
          "brokerType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution."
          },
          "side": {
            "enum": [
              "unknown",
              "buy",
              "sell"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderType"
              }
            ],
            "description": "Side of the order."
          },
          "amount": {
            "type": "number",
            "description": "Amount of the order.",
            "format": "double"
          },
          "price": {
            "type": "number",
            "description": "Unit price of the asset.",
            "format": "double",
            "nullable": true
          },
          "value": {
            "type": "number",
            "description": "Total value of the order.",
            "format": "double",
            "nullable": true
          },
          "fee": {
            "type": "number",
            "description": "Optional Fee taken by the financial institution.",
            "format": "double",
            "nullable": true
          },
          "timestamp": {
            "type": "integer",
            "description": "Timestamp of the order.",
            "format": "int64"
          },
          "status": {
            "enum": [
              "unknown",
              "inProgress",
              "cancelled",
              "rejected",
              "failed",
              "success",
              "partiallyFilled",
              "expired"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderStatus"
              }
            ],
            "description": "Status of the order."
          },
          "statusDetails": {
            "type": "string",
            "description": "Text details of the order, if additionally returned from the financial institution.",
            "nullable": true
          },
          "timeInForce": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderTimeInForceType"
              }
            ],
            "description": "Value that indicates how long the order will remain active before it is executed or expires.",
            "nullable": true
          },
          "symbolPair": {
            "type": "string",
            "description": "Optional pair of symbols, as returned from the financial institution. Can be required to obtain the status of the order by some institutions.",
            "nullable": true
          },
          "parentOrderId": {
            "type": "string",
            "description": "Id of the parent order, applicable to some institutions if the order was executed in several trades.",
            "nullable": true
          },
          "trades": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/B2BBrokerOrderTrade"
            },
            "description": "List of trades, provided only if the order was executed in several trades.",
            "nullable": true
          },
          "errorMessage": {
            "type": "string",
            "description": "A message describing the error if the order wasn't placed.",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "A user-friendly display message that can be presented to the end user.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCreateOrderResultApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerCreateOrderResult"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCryptoPairTradeFeatureOrderType": {
        "type": "object",
        "properties": {
          "supported": {
            "type": "boolean",
            "description": "Specifies if this order type is supported for this integration."
          },
          "supportedTimeInForceList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerPairTradeTimeInForceType"
            },
            "description": "The list of supported Time-in-force instructions for this order type.",
            "nullable": true
          },
          "supportsPlacingBuyOrdersInBaseSymbolAmount": {
            "type": "boolean",
            "description": "Specifies if this order type supports placing buy orders in base symbol amounts. For example,\r\nif payment/quote symbol is USD, base symbol is ETH, and this capability is supported, then the API can be instructed to buy 1 or other amount of ETH."
          },
          "supportsPlacingSellOrdersInBaseSymbolAmount": {
            "type": "boolean",
            "description": "Specifies if this order type supports placing sell orders in base symbol amounts. For example,\r\nif payment/quote symbol is USD, base symbol is ETH, and this capability is supported, then the API can be instructed to sell 1 or other amount of ETH."
          },
          "supportsPlacingBuyOrdersInQuoteSymbolAmount": {
            "type": "boolean",
            "description": "Specifies if this order type supports placing buy orders in quote symbol amounts. For example,\r\nif payment/quote symbol is USDC, and this capability is supported, then the API can be instructed to buy asset for 10 USDC or other amount."
          },
          "supportsPlacingSellOrdersInQuoteSymbolAmount": {
            "type": "boolean",
            "description": "Specifies if this order type supports placing sell orders in quote symbol amounts. For example,\r\nif payment/quote symbol is USDC, and this capability is supported, then the API can be instructed to sell asset for 10 USDC or other amount."
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCryptocurrencyDepositAddressResponse": {
        "type": "object",
        "properties": {
          "symbol": {
            "type": "string",
            "nullable": true
          },
          "address": {
            "type": "string",
            "nullable": true
          },
          "chain": {
            "type": "string",
            "nullable": true
          },
          "memo": {
            "type": "string",
            "nullable": true
          },
          "minimumDepositAmount": {
            "type": "string",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "brokerResponseStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerResponseStatus"
              }
            ],
            "nullable": true
          },
          "errorMessage": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCryptocurrencyDepositAddressResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerCryptocurrencyDepositAddressResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCryptocurrencyPairTradeFeature": {
        "type": "object",
        "properties": {
          "supported": {
            "type": "boolean"
          },
          "supportedCryptocurrencySymbols": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "supportedFiatCurrencies": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "supportedTradingPairs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "marketType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerCryptoPairTradeFeatureOrderType"
              }
            ],
            "nullable": true
          },
          "limitType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerCryptoPairTradeFeatureOrderType"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCryptocurrencySymbolDetailsResponse": {
        "type": "object",
        "properties": {
          "symbol": {
            "type": "string",
            "description": "Requested symbol",
            "nullable": true
          },
          "addressTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CryptocurrencyAddressType"
            },
            "description": "Supported address types",
            "nullable": true
          },
          "chains": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerCryptocurrencyChain"
            },
            "description": "Supported chains. One of the values should be provided to execute transfers",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCryptocurrencySymbolDetailsResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerCryptocurrencySymbolDetailsResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCryptocurrencyTransaction": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Identifier of the transfer, if provided by the financial institution",
            "nullable": true
          },
          "status": {
            "enum": [
              "unknown",
              "failed",
              "frozen",
              "succeeded",
              "mfaRequired",
              "pending",
              "expired",
              "canceled",
              "waitingForSignature",
              "waitingForClearing",
              "awaitingApproval",
              "awaitingConfirmation",
              "awaitingVerification",
              "rejected",
              "pendingCancel",
              "emailVerification",
              "deviceConfirmationRequired",
              "mfaFailed",
              "addressWhitelistRequired",
              "secondMfaRequired",
              "emailConfirmationApprovalRequired",
              "travelRuleRequired"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerCryptocurrencyTransactionStatus"
              }
            ],
            "description": "Current status of the transaction"
          },
          "statusDetails": {
            "type": "string",
            "description": "Details of the current status of the transfer, as provided by the financial institution",
            "nullable": true
          },
          "type": {
            "enum": [
              "unknown",
              "deposit",
              "withdrawal"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerCryptocurrencyTransactionType"
              }
            ],
            "description": "The direction of the transaction"
          },
          "fromAddress": {
            "type": "string",
            "description": "Address where the transaction was sent from",
            "nullable": true
          },
          "targetAddress": {
            "type": "string",
            "description": "Address where the transaction was sent to",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Ticker of the transaction",
            "nullable": true
          },
          "chain": {
            "type": "string",
            "description": "Crypto Chain the transaction belongs to",
            "nullable": true
          },
          "memo": {
            "type": "string",
            "description": "Memo of the transaction (also called \"Tag\")",
            "nullable": true
          },
          "hash": {
            "type": "string",
            "description": "Hash of the transaction",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Full amount affected the balance, typically transaction amount plus fee",
            "format": "double"
          },
          "transactionAmount": {
            "type": "number",
            "description": "Transaction amount",
            "format": "double",
            "nullable": true
          },
          "createdTimestamp": {
            "type": "integer",
            "description": "Unix timestamp in seconds indicating when the transaction was created",
            "format": "int64"
          },
          "updatedTimestamp": {
            "type": "integer",
            "description": "Unix timestamp in seconds indicating when the transaction was last updated",
            "format": "int64"
          },
          "networkTransactionFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerCryptocurrencyTransactionNetworkFee"
              }
            ],
            "description": "Fee taken by the network",
            "nullable": true
          },
          "transferFee": {
            "type": "number",
            "description": "Fee taken by the financial institution",
            "format": "double",
            "nullable": true
          },
          "confirmations": {
            "type": "integer",
            "description": "Number of confirmations on the blockchain",
            "format": "int64",
            "nullable": true
          },
          "blockchainMethodName": {
            "type": "string",
            "description": "Name of the executed blockchain function based on decoded input data",
            "nullable": true
          },
          "blockchainMethod": {
            "enum": [
              "transfer",
              "swap",
              "mint",
              "withdraw",
              "claimRewards",
              "deposit",
              "approve",
              "forgeToken",
              "multicall",
              "migrateToken",
              "claim",
              "openSeaTransfer",
              "cancel",
              "commit",
              "run",
              "repay",
              "execute",
              "stake",
              "merge"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerCryptocurrencyTransactionBlockchainMethod"
              }
            ],
            "description": "Executed blockchain function based on decoded input data. Not guaranteed to be identified"
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerCryptocurrencyTransactionApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerCryptocurrencyTransaction"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOptionData": {
        "type": "object",
        "properties": {
          "optionType": {
            "enum": [
              "unknown",
              "call",
              "put"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOptionType"
              }
            ],
            "description": "Type of option"
          },
          "direction": {
            "enum": [
              "unknown",
              "buyToOpen",
              "buyToClose",
              "sellToOpen",
              "sellToClose",
              "buyToCover",
              "sellShort"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOptionDirection"
              }
            ],
            "description": "Direction of option"
          },
          "strikePrice": {
            "type": "number",
            "description": "Option strike price",
            "format": "double"
          },
          "expirationTimestamp": {
            "type": "integer",
            "description": "Option expiration timestamp",
            "format": "int64"
          },
          "numberOfSharesInContract": {
            "type": "number",
            "description": "Number of shares covered by option",
            "format": "double"
          },
          "complexOrderStrategyType": {
            "type": "string",
            "description": "Option complex order strategy type",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOrder": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Transaction id, as provided by the institution",
            "nullable": true
          },
          "side": {
            "enum": [
              "unknown",
              "buy",
              "sell"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderType"
              }
            ],
            "description": "Side of the transaction"
          },
          "symbol": {
            "type": "string",
            "description": "Traded symbol",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "Name of the traded asset",
            "nullable": true
          },
          "assetType": {
            "enum": [
              "equity",
              "cryptocurrency",
              "option",
              "nft"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BAssetType"
              }
            ],
            "description": "Type of the traded asset"
          },
          "paymentSymbol": {
            "type": "string",
            "description": "Fiat or cryptocurrency symbol used for payment. For transactions with types `ConversionFrom` or `ConversionTo`\r\nthis field specifies the target symbol. For example, for `ETH` to `BTC` conversion, the transaction type is `ConversionTo`, the `Symbol` field is `ETH` and the `PaymentSymbol` is `BTC`",
            "nullable": true
          },
          "paymentType": {
            "enum": [
              "fiat",
              "cryptocurrency"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerOrderPaymentSymbolType"
              }
            ],
            "description": "Indicates if the payment was performed with fiat or crypto currency"
          },
          "amount": {
            "type": "number",
            "description": "Executed amount",
            "format": "double",
            "nullable": true
          },
          "price": {
            "type": "number",
            "description": "Price of the unit",
            "format": "double",
            "nullable": true
          },
          "fee": {
            "type": "number",
            "description": "Order Fee, taken by the financial institution",
            "format": "double",
            "nullable": true
          },
          "value": {
            "type": "number",
            "description": "Total value",
            "format": "double",
            "nullable": true
          },
          "createdTimestamp": {
            "type": "integer",
            "description": "Unix timestamp in seconds indicating when the order was placed or the transaction was created",
            "format": "int64"
          },
          "updatedTimestamp": {
            "type": "integer",
            "description": "Unix timestamp in seconds indicating when the transaction was last updated (e.g. executed)",
            "format": "int64"
          },
          "status": {
            "enum": [
              "unknown",
              "inProgress",
              "cancelled",
              "rejected",
              "failed",
              "success",
              "partiallyFilled",
              "expired"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderStatus"
              }
            ],
            "description": "Status of the transaction"
          },
          "statusDetails": {
            "type": "string",
            "description": "Status text, as provided by the institution",
            "nullable": true
          },
          "orderType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderPlaceType"
              }
            ],
            "description": "Type of the placed order",
            "nullable": true
          },
          "timeInForce": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderTimeInForceType"
              }
            ],
            "description": "Time in force of the order: a value indicating how long the order remains active before it is executed or expires",
            "nullable": true
          },
          "brokerType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the integration"
          },
          "transactionType": {
            "enum": [
              "order",
              "conversionTo",
              "conversionFrom",
              "ownAccountDeposit",
              "ownAccountWithdraw",
              "stake",
              "dividendReinvestment",
              "interest",
              "reward",
              "unknown",
              "conversionToFiat",
              "conversionFromFiat"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BTransactionType"
              }
            ],
            "description": "Type of the transaction"
          },
          "parentOrderId": {
            "type": "string",
            "description": "Id of the parent order, applicable to some institutions",
            "nullable": true
          },
          "optionDetails": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerOptionData"
              }
            ],
            "description": "Additional details for options",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOrderApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerOrder"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOrderListRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "cursor": {
            "type": "string",
            "description": "The cursor to retrieve the next page of transactions.\r\nProviding it will cause the response to only return changes after this update.\r\nIf this field is not provided, the history of transactions will be returned starting with the first-added transaction.",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "description": "Number of records to include in the response. \n\r\nDefault: `100` \n\r\nMaximum: `250`",
            "format": "int32"
          },
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerOrderStatus"
            },
            "description": "Return orders of this statuses only. If this field is not provided, orders with all available statuses will be returned.",
            "nullable": true
          },
          "from": {
            "type": "integer",
            "description": "Return orders created after this timestamp.\r\nIf this field is not provided, orders will be returned according to the default of the institution.",
            "format": "int64",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOrderListResponse": {
        "type": "object",
        "properties": {
          "transactions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/B2BBrokerOrder"
            },
            "description": "List of obtained transactions.",
            "nullable": true
          },
          "cursor": {
            "type": "string",
            "description": "The cursor to retrieve the next page of transactions.",
            "nullable": true
          },
          "total": {
            "type": "integer",
            "description": "Total amount of records.",
            "format": "int64"
          },
          "earliestTimestamp": {
            "type": "integer",
            "description": "Earliest transaction timestamp.",
            "format": "int64"
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOrderListResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerOrderListResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOrderPaymentSymbolType": {
        "enum": [
          "fiat",
          "cryptocurrency"
        ],
        "type": "string"
      },
      "B2BBrokerOrderRequest": {
        "required": [
          "authToken",
          "id",
          "isCryptocurrency",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "id": {
            "minLength": 1,
            "type": "string"
          },
          "side": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderType"
              }
            ],
            "description": "Should be provided for Coinbase.",
            "nullable": true
          },
          "isCryptocurrency": {
            "type": "boolean",
            "description": "Some Stock and Crypto symbols can intersect, so we need to explicitly specify what type of asset is requested to be bought."
          },
          "symbolPair": {
            "type": "string",
            "description": "Symbol pair of the order (requested by some brokers).",
            "nullable": true
          },
          "mfaCode": {
            "type": "string",
            "description": "MFA Code to cancel an order (requested by Kraken if MFA is enabled in user settings)",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOrderSymbolInfo": {
        "type": "object",
        "properties": {
          "fractionalTradingAllowance": {
            "enum": [
              "fractionalTradingAllowed",
              "fractionalTradingNotAllowed",
              "tradingNotAllowed",
              "fractionalTradingPossiblyAllowed"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/SymbolTradingAllowance"
              }
            ],
            "description": "Specifies if the fractional trading is allowed for the provided symbol"
          },
          "minimumOrderValue": {
            "type": "number",
            "description": "Minimum allowed order value",
            "format": "double"
          },
          "precisionScale": {
            "type": "integer",
            "description": "Maximum number of decimal digits accepted by the symbol",
            "format": "int32",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOrderSymbolInfoApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerOrderSymbolInfo"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerOrderTrade": {
        "type": "object",
        "properties": {
          "tradeId": {
            "type": "string",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "value": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "price": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "fee": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "orderCategory": {
            "enum": [
              "order",
              "trade",
              "ledger",
              "historyAction"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderCategory"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerPreviewOrderResult": {
        "type": "object",
        "properties": {
          "brokerType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ]
          },
          "fee": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "feeText": {
            "type": "string",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "format": "double"
          },
          "side": {
            "enum": [
              "unknown",
              "buy",
              "sell"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderType"
              }
            ]
          },
          "status": {
            "enum": [
              "success",
              "failed"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderValidationStatus"
              }
            ]
          },
          "errorMessage": {
            "type": "string",
            "nullable": true
          },
          "paymentSymbol": {
            "type": "string",
            "nullable": true
          },
          "paymentIsCryptocurrency": {
            "type": "boolean"
          },
          "estimatedUnitPrice": {
            "type": "number",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerPreviewOrderResultApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerPreviewOrderResult"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerRefreshTokenResponse": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "failed",
              "succeeded",
              "mfaRequired"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerAuthStatus"
              }
            ]
          },
          "errorMessage": {
            "type": "string",
            "nullable": true
          },
          "account": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerAccount"
              }
            ],
            "nullable": true,
            "deprecated": true
          },
          "accessToken": {
            "type": "string",
            "nullable": true,
            "deprecated": true
          },
          "refreshToken": {
            "type": "string",
            "nullable": true,
            "deprecated": true
          },
          "expiresInSeconds": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "refreshTokenExpiresInSeconds": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "brokerAccountTokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerAccountTokens"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerRefreshTokenResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerRefreshTokenResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerSymbolInfoForOrderRequest": {
        "required": [
          "amount",
          "amountIsInPaymentSymbol",
          "authToken",
          "isCryptocurrency",
          "orderType",
          "paymentIsCryptocurrency",
          "paymentSymbol",
          "symbol",
          "timeInForce",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "symbol": {
            "minLength": 1,
            "type": "string",
            "description": "Symbol to trade. For example, `AAPL` or `ETH`"
          },
          "paymentSymbol": {
            "minLength": 1,
            "type": "string",
            "description": "Symbol to use for payment, defaults to `USD`."
          },
          "amount": {
            "type": "number",
            "description": "Amount of purchase.",
            "format": "double"
          },
          "price": {
            "type": "number",
            "description": "Price of the unit, used for `Limit` and `StopLoss` orders.",
            "format": "double"
          },
          "isCryptocurrency": {
            "type": "boolean",
            "description": "Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly."
          },
          "paymentIsCryptocurrency": {
            "type": "boolean",
            "description": "Indicates whether the `PaymentSymbol` is fiat or cryptocurrency"
          },
          "amountIsFiat": {
            "type": "boolean",
            "nullable": true,
            "deprecated": true
          },
          "amountInFiat": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "deprecated": true
          },
          "amountIsInPaymentSymbol": {
            "type": "boolean",
            "description": "This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be\r\nperformed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and\r\n`SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`\r\nvalue is passed."
          },
          "amountInPaymentSymbol": {
            "type": "number",
            "description": "Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`\r\nand `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.",
            "format": "double",
            "nullable": true
          },
          "extendedHours": {
            "type": "boolean",
            "description": "Specifies if the extended trading hours should be used."
          },
          "orderType": {
            "enum": [
              "market",
              "limit",
              "stopLoss"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderPlaceTypeTrade"
              }
            ]
          },
          "timeInForce": {
            "enum": [
              "goodTillCanceled",
              "immediateOrCancel",
              "fillOrKill",
              "goodForDay",
              "postOnly",
              "unknown"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderTimeInForceType"
              }
            ]
          },
          "mfaCode": {
            "type": "string",
            "description": "MFA Code to create an order (requested by Kraken if MFA is enabled in user settings)",
            "nullable": true
          },
          "side": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderType"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerTradingFeature": {
        "type": "object",
        "properties": {
          "supported": {
            "type": "boolean"
          },
          "supportsFiatCurrencyPayment": {
            "type": "boolean"
          },
          "supportsCryptocurrencyPayment": {
            "type": "boolean"
          },
          "supportsMarginOrders": {
            "type": "boolean"
          },
          "supportedCryptocurrencySymbols": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "supportedCryptocurrencySymbolsForPayment": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "supportedFiatCurrencies": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "nullable": true
          },
          "marketType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerTradingFeatureOrderType"
              }
            ],
            "nullable": true
          },
          "limitType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerTradingFeatureOrderType"
              }
            ],
            "nullable": true
          },
          "stopLossType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerTradingFeatureOrderType"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerTradingFeatureInfo": {
        "type": "object",
        "properties": {
          "brokerType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the integration."
          },
          "accountId": {
            "type": "string",
            "description": "Account Id of the integration.",
            "nullable": true
          },
          "cryptocurrencyOrders": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerTradingFeature"
              }
            ],
            "description": "Model, describing the ability to place cryptocurrency orders.",
            "nullable": true
          },
          "stockOrders": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerTradingFeature"
              }
            ],
            "description": "Model, describing the ability to place equity orders.",
            "nullable": true
          },
          "cryptocurrencyAssetPairTrading": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerCryptocurrencyPairTradeFeature"
              }
            ],
            "description": "Model, describing the asset pair trading ability",
            "nullable": true
          },
          "cryptocurrencyConversion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerConversionFeature"
              }
            ],
            "description": "Model, describing the conversion ability",
            "nullable": true
          },
          "status": {
            "enum": [
              "succeeded",
              "failed",
              "notAuthorized"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerRequestStatus"
              }
            ],
            "description": "Status of the request."
          },
          "supportsOrderPreview": {
            "type": "boolean",
            "description": "Indicates if the preview of orders (`preview order execution` endpoint) is provided by the institution.\r\nThis allows to validate the order using the API of the institution. If the order preview is not supported,\r\nFront API validates the order without calling the institution's API."
          },
          "supportsPriceQuotes": {
            "type": "boolean",
            "description": "Supports getting price information directly from the institution."
          },
          "supportsOrderCancellation": {
            "type": "boolean",
            "description": "Indicates if it is possible to cancel the placed order, while it's in the `InProgress` status."
          },
          "isIntegrationUp": {
            "type": "boolean",
            "description": "Indicates if the integration is available."
          },
          "isTradingSupported": {
            "type": "boolean",
            "description": "Indicates if trading is generally supported at this time."
          },
          "fiatBalances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/B2BBrokerAccountBalance"
            },
            "description": "List of fiat balances of the account.",
            "nullable": true
          },
          "historyRecordLimit": {
            "type": "integer",
            "description": "Limit for history records",
            "format": "int32",
            "nullable": true
          },
          "usesSpreads": {
            "type": "boolean",
            "description": "Indicates whether the current exchange uses spreads as costs for trading"
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerTradingFeatureInfoApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerTradingFeatureInfo"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerTradingFeatureOrderType": {
        "type": "object",
        "properties": {
          "supported": {
            "type": "boolean",
            "description": "Specifies if this order type is supported for this integration."
          },
          "supportsFractionalShares": {
            "type": "boolean",
            "description": "Specifies if this order type supports buying or selling in fractional amounts. If this value is `false`, then only whole shares can be traded."
          },
          "supportsExtendedMarketHours": {
            "type": "boolean",
            "description": "Indicates if pre-market trading or after-hours trading is supported."
          },
          "supportsPlacingBuyOrdersInFiatAmount": {
            "type": "boolean",
            "readOnly": true,
            "deprecated": true
          },
          "supportsPlacingSellOrdersInFiatAmount": {
            "type": "boolean",
            "readOnly": true,
            "deprecated": true
          },
          "supportedTimeInForceList": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerOrderTimeInForceType"
            },
            "description": "The list of supported Time-in-force instructions for this order type.",
            "nullable": true
          },
          "supportsPlacingBuyOrdersInPaymentSymbolAmount": {
            "type": "boolean",
            "description": "Specifies if this order type supports placing buy orders in payment/quote symbol amounts. For example,\r\nif payment/quote symbol is USD, and this capability is supported, then the API can be instructed to buy asset for $10 or other dollar amount."
          },
          "supportsPlacingSellOrdersInPaymentSymbolAmount": {
            "type": "boolean",
            "description": "Specifies if this order type supports placing sell orders in payment/quote symbol amounts. For example,\r\nif payment/quote symbol is USD, and this capability is supported, then the API can be instructed to sell asset for $10 or other dollar amount."
          },
          "supportsPlacingBuyOrdersInBaseSymbolAmount": {
            "type": "boolean",
            "description": "Specifies if this order type supports placing buy orders in base symbol amounts. For example,\r\nif payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to buy 1 or other amount of AAPL."
          },
          "supportsPlacingSellOrdersInBaseSymbolAmount": {
            "type": "boolean",
            "description": "Specifies if this order type supports placing sell orders in base symbol amounts. For example,\r\nif payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to sell 1 or other amount of AAPL."
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerTransactionsListModel": {
        "type": "object",
        "properties": {
          "transfers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/B2BBrokerCryptocurrencyTransaction"
            },
            "description": "List of obtained transfers.",
            "nullable": true
          },
          "total": {
            "type": "integer",
            "description": "Total amount of records.",
            "format": "int64"
          },
          "cursor": {
            "type": "string",
            "description": "The cursor to retrieve the next page of transfers.",
            "nullable": true
          },
          "earliestTimestamp": {
            "type": "integer",
            "description": "Earliest transfer timestamp.",
            "format": "int64"
          }
        },
        "additionalProperties": false
      },
      "B2BBrokerTransactionsListModelApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BBrokerTransactionsListModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokersHealthStatus": {
        "required": [
          "deFiWalletData"
        ],
        "type": "object",
        "properties": {
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the integration"
          },
          "name": {
            "type": "string",
            "description": "Name of the integration",
            "nullable": true
          },
          "isUp": {
            "type": "boolean",
            "description": "Is the communication with the integration up"
          },
          "description": {
            "type": "string",
            "description": "Description of the outage",
            "nullable": true
          },
          "downTimeStart": {
            "type": "integer",
            "description": "Unix timestamp in seconds indicating when the outage occurred",
            "format": "int64",
            "nullable": true
          },
          "downTimeEnd": {
            "type": "integer",
            "description": "Unix timestamp in seconds indicating expected end of the outage",
            "format": "int64",
            "nullable": true
          },
          "supportedProducts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerFeature"
            },
            "description": "Get products supported by the financial institution",
            "nullable": true
          },
          "deFiWalletData": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DeFiWalletHealthStatusInfo"
              }
            ],
            "description": "Short information about DeFiWallet",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BBrokersHealthStatusListApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/B2BBrokersHealthStatus"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BFiatPortfolioModel": {
        "type": "object",
        "properties": {
          "fiatBalances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PortfolioFiatBalance"
            },
            "description": "List of aggregated fiat balances",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BFiatPortfolioModelApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BFiatPortfolioModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BNftPosition": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "number",
            "format": "double"
          },
          "costBasis": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "contractAddress": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "marketplaceId": {
            "type": "string",
            "nullable": true
          },
          "tokenId": {
            "type": "string",
            "nullable": true
          },
          "marketplacePermalink": {
            "type": "string",
            "nullable": true
          },
          "addressType": {
            "enum": [
              "ethAddress",
              "btcAddress",
              "ltcAddress",
              "solAddress",
              "algoAddress",
              "celoAddress",
              "cardanoAddress",
              "polygonAddress",
              "bnbAddress",
              "elrondAddress",
              "neoAddress",
              "xrpAddress",
              "flowAddress",
              "harmonyOneAddress",
              "tronAddress",
              "dogeAddress",
              "opAddress"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "B2BOptionPosition": {
        "type": "object",
        "properties": {
          "symbol": {
            "type": "string",
            "description": "Symbol of the underlying stock",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Amount of options",
            "format": "double"
          },
          "averageOpenPrice": {
            "type": "number",
            "description": "Total average paid price",
            "format": "double"
          },
          "direction": {
            "enum": [
              "unknown",
              "buyToOpen",
              "buyToClose",
              "sellToOpen",
              "sellToClose",
              "buyToCover",
              "sellShort"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOptionDirection"
              }
            ],
            "description": "Side of the option, buy or sell"
          },
          "createdTimestamp": {
            "type": "integer",
            "format": "int64"
          },
          "updatedTimestamp": {
            "type": "integer",
            "format": "int64"
          },
          "numberOfSharesInContract": {
            "type": "number",
            "description": "Number of shares of the underlying stock",
            "format": "double"
          },
          "optionType": {
            "enum": [
              "unknown",
              "call",
              "put"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOptionType"
              }
            ],
            "description": "Type of the option, put or call"
          },
          "expirationTimestamp": {
            "type": "integer",
            "description": "The last day that the option contract is valid",
            "format": "int64"
          },
          "strikePrice": {
            "type": "number",
            "description": "The price at which a put or call option can be exercised",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "B2BPortfolioModel": {
        "type": "object",
        "properties": {
          "portfolioCostBasis": {
            "type": "number",
            "description": "Amount of money spent to buy all positions of the portfolio.",
            "format": "double",
            "nullable": true
          },
          "actualPortfolioPerformance": {
            "type": "number",
            "description": "Actual performance based on the cost basis.",
            "format": "double",
            "nullable": true
          },
          "equitiesValue": {
            "type": "number",
            "description": "Total USD portfolio value of all equities (sum(equity price * equity amount)). Does not include cash balance.",
            "format": "double"
          },
          "cryptocurrenciesValue": {
            "type": "number",
            "description": "Total USD value of all cryptocurrencies in the portfolio.",
            "format": "double"
          },
          "nftsValue": {
            "type": "number",
            "description": "Total USD value of all NFTs in the portfolio.",
            "format": "double"
          },
          "equityPositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PositionWithReturn"
            },
            "description": "List of equity positions",
            "nullable": true
          },
          "cryptocurrencyPositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PositionWithReturn"
            },
            "description": "List of cryptocurrency positions",
            "nullable": true
          },
          "nftPositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NftPositionWithMarketValues"
            },
            "description": "List of NFT positions",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BPortfolioModelApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/B2BPortfolioModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "B2BTransactionType": {
        "enum": [
          "order",
          "conversionTo",
          "conversionFrom",
          "ownAccountDeposit",
          "ownAccountWithdraw",
          "stake",
          "dividendReinvestment",
          "interest",
          "reward",
          "unknown",
          "conversionToFiat",
          "conversionFromFiat"
        ],
        "type": "string"
      },
      "BalanceBrokerBaseRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```KuCoinDirect```\n```OkxOAuth```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BitsoDirect```\n```BybitDirect```\n```ParibuOAuth```\n```BinanceTrDirect```\n```BybitDirectMobile```\n"
          }
        },
        "additionalProperties": false
      },
      "BridgingDetails": {
        "type": "object",
        "properties": {
          "bridgingDirectionId": {
            "type": "string",
            "description": "The ID of the bridging direction that was used to generate the preview.",
            "format": "uuid"
          },
          "targetAddress": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BridgingOperationStatus": {
        "enum": [
          "recordCreated",
          "registeredInProvider",
          "sourceTransferStarted",
          "inReview",
          "providerAwaitingSourceTransfer",
          "providerFundsReceived",
          "providerProcessingPayment",
          "providerProcessedPayment",
          "providerSetUndeliverable",
          "returned",
          "refunded",
          "canceled",
          "succeeded",
          "failed"
        ],
        "type": "string"
      },
      "BridgingTimelineEvent": {
        "type": "object",
        "properties": {
          "eventType": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "timestamp": {
            "type": "integer",
            "format": "int64"
          }
        },
        "additionalProperties": false
      },
      "BridgingTransferDetailsModel": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "recordCreated",
              "registeredInProvider",
              "sourceTransferStarted",
              "inReview",
              "providerAwaitingSourceTransfer",
              "providerFundsReceived",
              "providerProcessingPayment",
              "providerProcessedPayment",
              "providerSetUndeliverable",
              "returned",
              "refunded",
              "canceled",
              "succeeded",
              "failed"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BridgingOperationStatus"
              }
            ]
          },
          "statusDescription": {
            "type": "string",
            "nullable": true
          },
          "targetSide": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BridgingTransferSide"
              }
            ],
            "nullable": true
          },
          "sourceSide": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BridgingTransferSide"
              }
            ],
            "nullable": true
          },
          "timeline": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BridgingTimelineEvent"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BridgingTransferSide": {
        "type": "object",
        "properties": {
          "networkName": {
            "type": "string",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "format": "double"
          },
          "transactionHash": {
            "type": "string",
            "nullable": true
          },
          "infoUrl": {
            "type": "string",
            "format": "uri",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerAccount": {
        "type": "object",
        "properties": {
          "meshAccountId": {
            "type": "string",
            "format": "uuid"
          },
          "frontAccountId": {
            "type": "string",
            "format": "uuid",
            "readOnly": true,
            "deprecated": true
          },
          "accountId": {
            "type": "string",
            "nullable": true
          },
          "accountName": {
            "type": "string",
            "nullable": true
          },
          "fund": {
            "type": "number",
            "description": "Buying power of the account. Typically consists of cash plus available margin.\r\nFor non-margin accounts fund contains cash only",
            "format": "double",
            "nullable": true
          },
          "cash": {
            "type": "number",
            "description": "Cash balance in USD",
            "format": "double",
            "nullable": true
          },
          "isReconnected": {
            "type": "boolean",
            "description": "Indicates if this account was already connected by the current user and device.\r\nCan be null.",
            "nullable": true
          },
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerFiatBalance"
            },
            "description": "The list of all asset balances of account",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerAccountTokens": {
        "type": "object",
        "properties": {
          "account": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerAccount"
              }
            ],
            "nullable": true
          },
          "accessToken": {
            "type": "string",
            "nullable": true
          },
          "refreshToken": {
            "type": "string",
            "nullable": true
          },
          "tokenId": {
            "type": "string",
            "description": "Token identifier provided by Mesh when the actual integration's token is managed by Mesh's Token Management System.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerAuthPromptStatus": {
        "enum": [
          "failed",
          "redirect",
          "openInBrokerModule"
        ],
        "type": "string"
      },
      "BrokerAuthStatus": {
        "enum": [
          "failed",
          "challengeFailed",
          "succeeded",
          "challengeIssued",
          "mfaRequired",
          "openInBrokerModule",
          "delayed",
          "deviceConfirmationRequired",
          "emailVerification",
          "emailReceived",
          "captchaChallenge",
          "faceVerification",
          "bindMfaRequired",
          "apiKeyGenerationError",
          "qrCodeRequired",
          "qrCodeExpired",
          "deviceLoginVerified"
        ],
        "type": "string"
      },
      "BrokerAuthenticationScheme": {
        "type": "object",
        "properties": {
          "brokerType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ]
          },
          "authenticationSchemeType": {
            "enum": [
              "usernamePassword",
              "oAuth",
              "apiKey",
              "blockchainAddress",
              "trueAuth"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/AuthenticationSchemeType"
              }
            ],
            "description": "Type of authentication for the integration."
          },
          "initialAuthenticationModel": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AuthenticationModel"
              }
            ],
            "description": "Set of fields that should be provided in the initial POST `authenticate` request.",
            "nullable": true
          },
          "authenticationSteps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AuthenticationModel"
            },
            "description": "Set of fields that should be provided depending on the status of the response of the first POST `authenticate` request.",
            "nullable": true
          },
          "mfaSchemes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MfaScheme"
            },
            "description": "Supported MFA schemes, can be none or multiple.",
            "nullable": true
          },
          "instructionsUrl": {
            "type": "string",
            "description": "Optional URL with the instructions explaining how to create a set of API key/secret for the integration, can be shown to the end user.",
            "nullable": true
          },
          "trueAuthAuthenticaion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerTrueAuthAuthenticationScheme"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerAuthenticationSchemeIReadOnlyCollectionApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerAuthenticationScheme"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerBaseRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          }
        },
        "additionalProperties": false
      },
      "BrokerCreateCryptocurrencyTransactionRequest": {
        "required": [
          "authToken",
          "targetAddress",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "data": {
            "type": "string",
            "description": "Additional data to send on-chain (optional, depends on an integration)",
            "nullable": true
          },
          "targetAddress": {
            "minLength": 1,
            "type": "string",
            "description": "Target address to transfer the asset to"
          },
          "amount": {
            "type": "number",
            "description": "Amount to transfer",
            "format": "double"
          },
          "fee": {
            "type": "number",
            "description": "On-chain fee (optional, depends on an integration)",
            "format": "double"
          },
          "addressType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ],
            "description": "Type of the address of symbol to be transferred. Providing `EthAddress` will initiate a transfer of ETH over Ethereum blockchain.\r\nCan be used instead of `Symbol` and `Chain` fields.\r\nTo transfer assets over non-default chains (e.g. sending USDT over ERC20) please `Symbol` and `Chain` fields.",
            "nullable": true
          },
          "mfaCode": {
            "type": "string",
            "description": "2 Factor auth code (optional, depends on an integration)",
            "nullable": true
          },
          "travelRuleTransactionId": {
            "type": "integer",
            "description": "Travel rule transaction id (optional, depends on an integration)",
            "format": "int32",
            "nullable": true
          },
          "mfaType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MfaType"
              }
            ],
            "description": "2 Factor auth type (optional, depends on an integration)",
            "nullable": true
          },
          "verificationSteps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MfaType"
            },
            "nullable": true
          },
          "password": {
            "type": "string",
            "description": "Password or pass-phrase, required to send transfers (optional, depends on an integration)",
            "nullable": true
          },
          "chain": {
            "type": "string",
            "description": "Custom chain name, required by some of the integrations. E.g. USDT can be sent over USDT-ERC20, USDT-TRC20, and USDT-Omni.\r\nCan be used to transfer assets over non-default chains (e.g. sending USDT over ERC20).\r\nPlease use `symbol/details` endpoint to get the list of all possible chains.",
            "nullable": true
          },
          "memo": {
            "type": "string",
            "description": "Memo (also called \"Tag\") - address remark.",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Symbol to be transferred. Can be provided instead of the `AddressType` field.",
            "nullable": true
          },
          "challengeId": {
            "type": "string",
            "nullable": true
          },
          "tryAnotherMfa": {
            "type": "boolean"
          },
          "travelRuleOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferTravelRuleOptions"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerCryptocurrencyChain": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "description": "Name of the chain, should be provided when initiating a transfer",
            "nullable": true
          },
          "feeDescription": {
            "type": "string",
            "nullable": true
          },
          "notes": {
            "type": "string",
            "description": "Notes or tips provided by the integration",
            "nullable": true
          },
          "fee": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "minWithdrawAmount": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "maxWithdrawAmount": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerCryptocurrencyDepositAddressRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the required cryptocurrency, e.g. ETH or BTC.\r\nCan be used instead of the `AddressType` field.",
            "nullable": true
          },
          "addressType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ],
            "description": "Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.\r\nCan be used instead of `Symbol` field.",
            "nullable": true
          },
          "chain": {
            "type": "string",
            "description": "Chain of the required cryptocurrency, e.g. USDT has USDT-ERC20, USDT-TRC20, and USDT-Omni",
            "nullable": true
          },
          "mfaCode": {
            "type": "string",
            "description": "Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerCryptocurrencyTransactionBlockchainMethod": {
        "enum": [
          "transfer",
          "swap",
          "mint",
          "withdraw",
          "claimRewards",
          "deposit",
          "approve",
          "forgeToken",
          "multicall",
          "migrateToken",
          "claim",
          "openSeaTransfer",
          "cancel",
          "commit",
          "run",
          "repay",
          "execute",
          "stake",
          "merge"
        ],
        "type": "string"
      },
      "BrokerCryptocurrencyTransactionDetailsRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "addressType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ],
            "description": "Type of the address of the transferred asset. Can be used instead of the `Symbol` field.",
            "nullable": true
          },
          "transactionId": {
            "type": "string",
            "description": "Transaction Id by the financial institution",
            "nullable": true
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction on the blockchain",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the transferred asset. Can be provided instead of the `AddressType` field.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerCryptocurrencyTransactionNetworkFee": {
        "type": "object",
        "properties": {
          "gasPrice": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "gasUsed": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerCryptocurrencyTransactionStatus": {
        "enum": [
          "unknown",
          "failed",
          "frozen",
          "succeeded",
          "mfaRequired",
          "pending",
          "expired",
          "canceled",
          "waitingForSignature",
          "waitingForClearing",
          "awaitingApproval",
          "awaitingConfirmation",
          "awaitingVerification",
          "rejected",
          "pendingCancel",
          "emailVerification",
          "deviceConfirmationRequired",
          "mfaFailed",
          "addressWhitelistRequired",
          "secondMfaRequired",
          "emailConfirmationApprovalRequired",
          "travelRuleRequired"
        ],
        "type": "string"
      },
      "BrokerCryptocurrencyTransactionType": {
        "enum": [
          "unknown",
          "deposit",
          "withdrawal"
        ],
        "type": "string"
      },
      "BrokerFeature": {
        "enum": [
          "holdings",
          "balance",
          "orders",
          "transfers",
          "identity",
          "cryptocurrencyDepositAddresses",
          "accountNumber",
          "paymentMethods",
          "conversions"
        ],
        "type": "string"
      },
      "BrokerFiatBalance": {
        "type": "object",
        "properties": {
          "symbol": {
            "type": "string",
            "description": "Account balance currency",
            "nullable": true
          },
          "buyingPower": {
            "type": "number",
            "description": "BuyingPower indicates total amount of money the user can spend for buying stock. Always includes cash and\r\ncan also include margin",
            "format": "double",
            "nullable": true
          },
          "cryptoBuyingPower": {
            "type": "number",
            "description": "BuyingPower indicates total amount of money the user can spend for buying crypto.",
            "format": "double",
            "nullable": true
          },
          "cash": {
            "type": "number",
            "description": "Account cash indicates total amount of money",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerOptionDirection": {
        "enum": [
          "unknown",
          "buyToOpen",
          "buyToClose",
          "sellToOpen",
          "sellToClose",
          "buyToCover",
          "sellShort"
        ],
        "type": "string"
      },
      "BrokerOptionType": {
        "enum": [
          "unknown",
          "call",
          "put"
        ],
        "type": "string"
      },
      "BrokerOrderCategory": {
        "enum": [
          "order",
          "trade",
          "ledger",
          "historyAction"
        ],
        "type": "string"
      },
      "BrokerOrderPlaceType": {
        "enum": [
          "unknown",
          "market",
          "limit",
          "stopLoss",
          "stopLimit",
          "takeProfit",
          "netDebit",
          "netCredit",
          "exercise"
        ],
        "type": "string"
      },
      "BrokerOrderPlaceTypeTrade": {
        "enum": [
          "market",
          "limit",
          "stopLoss"
        ],
        "type": "string"
      },
      "BrokerOrderStatus": {
        "enum": [
          "unknown",
          "inProgress",
          "cancelled",
          "rejected",
          "failed",
          "success",
          "partiallyFilled",
          "expired"
        ],
        "type": "string"
      },
      "BrokerOrderTimeInForceType": {
        "enum": [
          "goodTillCanceled",
          "immediateOrCancel",
          "fillOrKill",
          "goodForDay",
          "postOnly",
          "unknown"
        ],
        "type": "string"
      },
      "BrokerOrderType": {
        "enum": [
          "unknown",
          "buy",
          "sell"
        ],
        "type": "string"
      },
      "BrokerOrderValidationStatus": {
        "enum": [
          "success",
          "failed"
        ],
        "type": "string"
      },
      "BrokerPairTradeTimeInForceType": {
        "enum": [
          "immediateOrCancel",
          "goodTillCanceled",
          "goodTillDate",
          "fillOrKill"
        ],
        "type": "string"
      },
      "BrokerPaymentMethodType": {
        "enum": [
          "card",
          "bankAccount",
          "digitalWallet",
          "unknown"
        ],
        "type": "string"
      },
      "BrokerPortfolioValueModel": {
        "type": "object",
        "properties": {
          "totalValue": {
            "type": "number",
            "description": "Total USD value of portfolio.",
            "format": "double",
            "readOnly": true
          },
          "totalPerformance": {
            "type": "number",
            "description": "Total performance in percents based on the cost basis.",
            "format": "double"
          },
          "equitiesValue": {
            "type": "number",
            "description": "USD value of all equities in the portfolio.",
            "format": "double"
          },
          "equitiesPerformance": {
            "type": "number",
            "description": "Performance in percents of all equities based on the cost basis.",
            "format": "double"
          },
          "cryptocurrenciesValue": {
            "type": "number",
            "description": "USD value of all cryptocurrencies in the portfolio.",
            "format": "double"
          },
          "cryptocurrenciesPerformance": {
            "type": "number",
            "description": "Performance in percents of all cryptocurrencies in the portfolio based on the cost basis.",
            "format": "double"
          },
          "nftsValue": {
            "type": "number",
            "description": "USD value of all NFTs in the portfolio.",
            "format": "double"
          },
          "fiatValue": {
            "type": "number",
            "description": "USD value of all fiat currencies in the portfolio.",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "BrokerPortfolioValueModelApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerPortfolioValueModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerRefreshTokenRequest": {
        "required": [
          "refreshToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ]
          },
          "refreshToken": {
            "minLength": 1,
            "type": "string"
          },
          "createNewRefreshToken": {
            "type": "boolean",
            "description": "Optional, used when we the refresh token should be refreshed.\r\nCurrently this flow is supported by TD Ameritrade",
            "nullable": true
          },
          "accessToken": {
            "type": "string",
            "description": "Some institutions may require accessToken to be provided as well.\r\nIt's currently required by WeBull and Vanguard",
            "nullable": true
          },
          "tradeToken": {
            "type": "string",
            "description": "Currently used to update WeBull trade token.",
            "nullable": true
          },
          "mfaCode": {
            "type": "string",
            "description": "Optional, currently used by Vanguard if account has enforced MFA enabled.",
            "nullable": true
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "nullable": true
            },
            "description": "Additional metadata",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerRequestStatus": {
        "enum": [
          "succeeded",
          "failed",
          "notAuthorized"
        ],
        "type": "string"
      },
      "BrokerResponseStatus": {
        "enum": [
          "unknown",
          "mfaRequired",
          "kycRequired"
        ],
        "type": "string"
      },
      "BrokerTransactionsListRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "count": {
            "type": "integer",
            "description": "Number of records to include in the response. \n\r\nDefault: `100` \n\r\nMaximum: `250`",
            "format": "int32"
          },
          "cursor": {
            "type": "string",
            "description": "The cursor to retrieve the next page of transactions.\r\nProviding it will cause the response to only return changes after this update.\r\nIf this field is not provided, the history of transactions will be returned starting with the first-added transaction.",
            "nullable": true
          },
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerCryptocurrencyTransactionStatus"
            },
            "description": "If this value is provided, result set is filtered to only include transaction with the provided statuses.",
            "nullable": true
          },
          "cryptocurrencyAddressType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ],
            "description": "For cryptocurrency address the type of address is required.",
            "nullable": true
          },
          "from": {
            "type": "integer",
            "description": "If this value is provided, result set is filtered to only include transactions created after this timestamp",
            "format": "int64",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerTrueAuthAuthenticationScheme": {
        "required": [
          "cookieDomains",
          "loginUrl",
          "successfulLoginUri"
        ],
        "type": "object",
        "properties": {
          "loginUrl": {
            "type": "string",
            "description": "The login url page to show in the webview.",
            "nullable": true
          },
          "successfulLoginUri": {
            "type": "string",
            "description": "The login page to check against for successful login",
            "nullable": true
          },
          "cookieDomains": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The urls from where cookies are fetched.",
            "nullable": true
          },
          "requiredHeaderNames": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The headers that are required for authentication.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "BrokerType": {
        "enum": [
          "robinhood",
          "eTrade",
          "alpaca",
          "tdAmeritrade",
          "weBull",
          "stash",
          "interactiveBrokers",
          "public",
          "coinbase",
          "kraken",
          "coinbasePro",
          "cryptoCom",
          "openSea",
          "binanceUs",
          "gemini",
          "cryptocurrencyAddress",
          "cryptocurrencyWallet",
          "okCoin",
          "bittrex",
          "kuCoin",
          "etoro",
          "cexIo",
          "binanceInternational",
          "bitstamp",
          "gateIo",
          "acorns",
          "okx",
          "bitFlyer",
          "coinlist",
          "huobi",
          "bitfinex",
          "deFiWallet",
          "krakenDirect",
          "vanguard",
          "binanceInternationalDirect",
          "bitfinexDirect",
          "bybit",
          "paxos",
          "coinbasePrime",
          "btcTurkDirect",
          "kuCoinDirect",
          "okxOAuth",
          "paribuDirect",
          "robinhoodConnect",
          "blockchainCom",
          "bitsoDirect",
          "binanceConnect",
          "binanceOAuth",
          "revolutConnect",
          "binancePay",
          "bybitDirect",
          "paribuOAuth",
          "payPalConnect",
          "binanceTrDirect",
          "coinbaseRamp",
          "bybitDirectMobile"
        ],
        "type": "string"
      },
      "CatalogLink": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "Url to open Front catalog that should be presented to the end user.",
            "format": "uri",
            "nullable": true
          },
          "iFrameUrl": {
            "type": "string",
            "description": "Url to open Front catalog in iFrame that should be presented to the end user.",
            "format": "uri",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CatalogLinkApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CatalogLink"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ClientType": {
        "enum": [
          "undefined",
          "wallet",
          "exchange",
          "vasp",
          "merchant",
          "other",
          "psp",
          "neobank",
          "iGaming",
          "aggregator"
        ],
        "type": "string"
      },
      "ConfigureTransferRequest": {
        "required": [
          "fromAuthToken",
          "fromType"
        ],
        "type": "object",
        "properties": {
          "fromAuthToken": {
            "minLength": 1,
            "type": "string",
            "description": "The authentication token to send assets from."
          },
          "fromType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "The type of the integration to send assets from."
          },
          "toAuthToken": {
            "type": "string",
            "description": "The authentication token of the target integration. Can be used alternatively to the list of requested address (`toAddresses`).\r\nIf used, `toType` should also be provided.",
            "nullable": true
          },
          "toType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `toAddresses`.",
            "nullable": true
          },
          "toAddresses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransferToAddress"
            },
            "description": "A list of available addresses provided by the API client. The list can contain all supported addresses by the client.\r\nFront API validates the addresses and returns the list of supported tokens and networks as the result of the operation.",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "If provided, Front API returns only networks that support transferring of this symbol.",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "If provided, Front API configures the response to only return holdings with enough amount of this crypto for the transfer",
            "format": "double",
            "nullable": true
          },
          "amountInFiat": {
            "type": "number",
            "description": "If provided, Front API configures the response to only contain holdings with enough value (converted to fiat) for the transfer.",
            "format": "double",
            "nullable": true
          },
          "fiatCurrency": {
            "type": "string",
            "description": "Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`.",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "description": "If provided, from API configures the response to include the requested network only.",
            "format": "uuid",
            "nullable": true
          },
          "isInclusiveFeeEnabled": {
            "type": "boolean",
            "description": "Specifies if all the fees are included in the amount to transfer."
          }
        },
        "additionalProperties": false
      },
      "ConfigureTransferResponse": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "succeeded",
              "failed",
              "validationFailed",
              "notAuthorizedTo",
              "notAuthorizedFrom",
              "kycRequired",
              "fromIntegrationNotSupported",
              "toIntegrationNotSupported"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ConfigureTransferStatus"
              }
            ],
            "description": "Status of the operation."
          },
          "holdings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConfigureTransferResultHolding"
            },
            "description": "List of holdings on the source account.",
            "nullable": true
          },
          "amountInFiat": {
            "type": "number",
            "description": "Amount in USD to transfer.",
            "format": "double",
            "nullable": true
          },
          "fiatCurrency": {
            "type": "string",
            "description": "Used fiat currency.",
            "nullable": true
          },
          "minimumTransferAmountInFiat": {
            "type": "number",
            "description": "Minimum transfer amount in fiat.",
            "format": "double",
            "nullable": true
          },
          "maximumTransferAmountInFiat": {
            "type": "number",
            "description": "Maximum transfer amount in fiat",
            "format": "double",
            "nullable": true
          },
          "supportedFiatCurrencies": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Supported fiat currencies for this transfer",
            "nullable": true
          },
          "transferBalanceFundingAvailability": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferBalanceFundingAvailabilityBase"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConfigureTransferResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ConfigureTransferResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConfigureTransferResultHolding": {
        "type": "object",
        "properties": {
          "symbol": {
            "type": "string",
            "description": "The symbol of the digital asset on the source account.",
            "nullable": true
          },
          "availableBalance": {
            "type": "number",
            "description": "The available balance of the digital asset.",
            "format": "double"
          },
          "availableBalanceInFiat": {
            "type": "number",
            "description": "The available balance of the digital asset, converted to fiat currency.",
            "format": "double"
          },
          "eligibleForTransfer": {
            "type": "boolean",
            "description": "Specifies if the asset is eligible for a transfer."
          },
          "networks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConfigureTransferResultNetwork"
            },
            "description": "Supported networks.",
            "nullable": true
          },
          "ineligibilityReason": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HoldingTransferIneligibilityReason"
              }
            ],
            "description": "The reason indicating why the transfer of the current asset cannot be performed.",
            "nullable": true
          },
          "eligibleForTransferWithFunding": {
            "type": "boolean",
            "description": "Indicates that the asset is not eligible for a transfer with the current holding balance,\r\nbut can be made eligible after funding the balance using the cryptocurrency balance funding feature."
          },
          "logoUrl": {
            "type": "string",
            "description": "Logo url for holding.",
            "format": "uri",
            "nullable": true
          },
          "isBridgingAsset": {
            "type": "boolean",
            "description": "Specifies if the asset is used for bridging between networks.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConfigureTransferResultNetwork": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the network.",
            "nullable": true
          },
          "id": {
            "type": "string",
            "description": "The Id of the network in Front system.",
            "format": "uuid"
          },
          "minimumAmount": {
            "type": "number",
            "description": "Then minimum amount that can be withdrawn using this network.",
            "format": "double",
            "nullable": true
          },
          "maximumAmount": {
            "type": "number",
            "description": "The maximum amount that can be withdrawn using this network.",
            "format": "double",
            "nullable": true
          },
          "totalEstimatedTransferFeeInFiat": {
            "type": "number",
            "description": "Total estimated transfer fee converted to fiat. Can consist of the fee taken by the financial institution and the\r\ngas fee.",
            "format": "double",
            "nullable": true
          },
          "minimumAmountInFiat": {
            "type": "number",
            "description": "The minimum amount that can be withdrawn using this network, converted to fiat currency.",
            "format": "double",
            "nullable": true
          },
          "maximumAmountInFiat": {
            "type": "number",
            "description": "The maximum amount that can be withdrawn using this network, converted to fiat currency.",
            "format": "double",
            "nullable": true
          },
          "estimatedNetworkGasFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be\r\ncovered by the `InstitutionTransferFee`.",
            "nullable": true
          },
          "institutionTransferFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not\r\ntake the transfer fee and only network fee is used for the transfer.",
            "nullable": true
          },
          "eligibleForTransfer": {
            "type": "boolean",
            "description": "Specifies if the asset is eligible for a transfer over the current network."
          },
          "ineligibilityReason": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NetworkTransferIneligibilityReason"
              }
            ],
            "description": "The reason indicating why the transfer cannot be performed over this network.",
            "nullable": true
          },
          "eligibleForTransferWithFunding": {
            "type": "boolean"
          },
          "toAddress": {
            "type": "string",
            "description": "The designated destination for sending the asset.",
            "nullable": true
          },
          "transferAmount": {
            "type": "number",
            "description": "Token's amount to transfer specified by the client.",
            "format": "double",
            "nullable": true
          },
          "minimumRequiredForTransferAmount": {
            "type": "number",
            "description": "The minimum amount of cryptocurrency that is required to be present in the account to perform the transfer.\r\nUnlike `minimum` field that indicates the minimum amount that can generally be transferred, this field indicates the minimum\r\nthat can be transferred given the current transfer configuration values, such as `amountInFiat` and `clientFee`.",
            "format": "double",
            "nullable": true
          },
          "caipNetworkId": {
            "type": "string",
            "nullable": true
          },
          "logoUrl": {
            "type": "string",
            "description": "Logo url for network.",
            "format": "uri",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ConfigureTransferStatus": {
        "enum": [
          "succeeded",
          "failed",
          "validationFailed",
          "notAuthorizedTo",
          "notAuthorizedFrom",
          "kycRequired",
          "fromIntegrationNotSupported",
          "toIntegrationNotSupported"
        ],
        "type": "string"
      },
      "CountryInfo": {
        "type": "object",
        "properties": {
          "countryCode": {
            "type": "string",
            "nullable": true
          },
          "countryNumber": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CryptocurrencyAddressType": {
        "enum": [
          "ethAddress",
          "btcAddress",
          "ltcAddress",
          "solAddress",
          "algoAddress",
          "celoAddress",
          "cardanoAddress",
          "polygonAddress",
          "bnbAddress",
          "elrondAddress",
          "neoAddress",
          "xrpAddress",
          "flowAddress",
          "harmonyOneAddress",
          "tronAddress",
          "dogeAddress",
          "opAddress"
        ],
        "type": "string"
      },
      "CryptocurrencyFundingOptionType": {
        "enum": [
          "existingCryptocurrencyBalance",
          "buyingPowerPurchase",
          "paymentMethodDepositUsage",
          "cryptocurrencyConversion",
          "stableCoinNoFeeConversion",
          "cryptocurrencyBuyingPowerConversion",
          "cryptocurrencyMultiStepConversion"
        ],
        "type": "string"
      },
      "DeFiPositionDistribution": {
        "required": [
          "address",
          "amount",
          "caipNetworkId"
        ],
        "type": "object",
        "properties": {
          "caipNetworkId": {
            "type": "string",
            "description": "Cryptocurrency CAIP-2 network ID associated with this distribution.",
            "nullable": true
          },
          "address": {
            "type": "string",
            "description": "The wallet address on the specific network.",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Amount of cryptocurrency allocated to this network and address.",
            "format": "double"
          }
        },
        "additionalProperties": false,
        "description": "Represents the distribution of a DeFi position across different networks and addresses.\r\nThis class holds the network-specific information, wallet address, and the amount of cryptocurrency\r\nallocated to each network and address for self-custody (DeFi) wallets."
      },
      "DeFiWalletHealthStatusInfo": {
        "required": [
          "id",
          "name"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "DeFiWalletVerification": {
        "type": "object",
        "properties": {
          "userId": {
            "type": "string",
            "description": "User identifier.",
            "nullable": true
          },
          "address": {
            "type": "string",
            "description": "Wallet address.",
            "nullable": true
          },
          "xPubKey": {
            "type": "string",
            "description": "Wallet Xpub key for Bitcon wallets.",
            "nullable": true
          },
          "networkType": {
            "enum": [
              "unknown",
              "evm",
              "solana",
              "bitcoin",
              "cardano",
              "tron",
              "avalancheX",
              "tezos",
              "dogecoin",
              "ripple",
              "stellar",
              "litecoin",
              "sui",
              "aptos",
              "tvm",
              "injective"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/NetworkType"
              }
            ],
            "description": "Wallet network type."
          },
          "verificationMethod": {
            "enum": [
              "signedMessage"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/WalletVerificationMethod"
              }
            ],
            "description": "Verification method."
          },
          "message": {
            "type": "string",
            "description": "Original message.",
            "nullable": true
          },
          "signedMessageHash": {
            "type": "string",
            "description": "Message signature.",
            "nullable": true
          },
          "timestamp": {
            "type": "integer",
            "description": "Verification created timestamp.",
            "format": "int64"
          }
        },
        "additionalProperties": false,
        "description": "Verifications data."
      },
      "DeFiWalletVerificationResponse": {
        "type": "object",
        "properties": {
          "verifications": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeFiWalletVerification"
            },
            "description": "List of found verifications.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Verifications response."
      },
      "DeFiWalletVerificationResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DeFiWalletVerificationResponse"
              }
            ],
            "description": "Verifications response.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "DeviceType": {
        "enum": [
          "unknown",
          "android",
          "ios",
          "web"
        ],
        "type": "string"
      },
      "ExchangeAccountInfoRequest": {
        "type": "object",
        "properties": {
          "authToken": {
            "type": "string",
            "description": "Auth token that allows connecting to the target institution.",
            "nullable": true
          },
          "integrationId": {
            "type": "string",
            "description": "The Id which uniquely identifies the integration.",
            "format": "uuid"
          },
          "accountInfo": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AccountInfoType"
            },
            "description": "Account information to return.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Exchange account info request."
      },
      "ExecuteTransferMfaType": {
        "enum": [
          "unspecified",
          "phone",
          "email",
          "totp",
          "face",
          "tradingPin",
          "mobile"
        ],
        "type": "string"
      },
      "ExecuteTransferRequest": {
        "required": [
          "fromAuthToken",
          "fromType",
          "previewId"
        ],
        "type": "object",
        "properties": {
          "fromAuthToken": {
            "minLength": 1,
            "type": "string",
            "description": "The authentication token to send the asset from."
          },
          "fromType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "The type of the integration to send the asset from."
          },
          "previewId": {
            "type": "string",
            "description": "Id of the Preview of the transfer.",
            "format": "uuid"
          },
          "mfaCode": {
            "type": "string",
            "description": "Multi-factor auth code that should be provided if the status of the transfer was `MfaRequired`.",
            "nullable": true
          },
          "tryAnotherMfa": {
            "type": "boolean",
            "description": "When user is unable to provide the primary Mfa this should be passed in to use fallback Mfa."
          },
          "challengeId": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ExecuteTransferResponse": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "succeeded",
              "inProgress",
              "failed",
              "mfaRequired",
              "emailConfirmationRequired",
              "deviceConfirmationRequired",
              "mfaFailed",
              "addressWhitelistRequired",
              "secondMfaRequired",
              "deFiWalletConfirmationRequired",
              "emailConfirmationApprovalRequired"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ExecuteTransferStatus"
              }
            ],
            "description": "The status of the transfer."
          },
          "mfaType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExecuteTransferMfaType"
              }
            ],
            "description": "The type of the MFA when the status is `MfaRequired`.",
            "nullable": true
          },
          "verificationSteps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExecuteTransferMfaType"
            },
            "description": "The type of the MFA when the status is `MfaRequired`.",
            "nullable": true
          },
          "travelRuleTransactionId": {
            "type": "integer",
            "description": "The transaction number for Travel rule required clients (optional, depends on an integration).",
            "format": "int32",
            "nullable": true
          },
          "qrCode": {
            "type": "string",
            "nullable": true
          },
          "qrCodeLink": {
            "type": "string",
            "nullable": true
          },
          "errorMessage": {
            "type": "string",
            "description": "Error message, if the operation did not complete successfully.",
            "nullable": true
          },
          "executeTransferResult": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExecuteTransferResultResponse"
              }
            ],
            "description": "Result of the transfer initiation.",
            "nullable": true
          },
          "fallbackMfaAvailable": {
            "type": "boolean"
          },
          "challengeId": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ExecuteTransferResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExecuteTransferResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ExecuteTransferResultResponse": {
        "type": "object",
        "properties": {
          "transferId": {
            "type": "string",
            "description": "The Id of the transfer by the integration.",
            "nullable": true
          },
          "status": {
            "enum": [
              "unknown",
              "failed",
              "frozen",
              "succeeded",
              "mfaRequired",
              "pending",
              "expired",
              "canceled",
              "waitingForSignature",
              "waitingForClearing",
              "awaitingApproval",
              "awaitingConfirmation",
              "awaitingVerification",
              "rejected",
              "pendingCancel",
              "emailVerification",
              "deviceConfirmationRequired",
              "mfaFailed",
              "addressWhitelistRequired",
              "secondMfaRequired",
              "emailConfirmationApprovalRequired",
              "travelRuleRequired"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerCryptocurrencyTransactionStatus"
              }
            ],
            "description": "The current status of the transfer."
          },
          "statusDetails": {
            "type": "string",
            "description": "Details of the current status of the transfer, as provided by the integration.",
            "nullable": true
          },
          "fromAddress": {
            "type": "string",
            "description": "The address of the source account or wallet.",
            "nullable": true
          },
          "toAddress": {
            "type": "string",
            "description": "The address of the target account or wallet.",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Transferred symbol.",
            "nullable": true
          },
          "networkName": {
            "type": "string",
            "description": "The name of the used network.",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "description": "The Id of the used network in Front system.",
            "format": "uuid"
          },
          "hash": {
            "type": "string",
            "description": "The hash of the blockchain transaction.",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "The transferred amount, in the symbol of the transfer.",
            "format": "double"
          },
          "amountInFiat": {
            "type": "number",
            "description": "The transferred amount, converted to the fiat currency.",
            "format": "double"
          },
          "totalAmountInFiat": {
            "type": "number",
            "description": "Total amount of the transfer including all fees, converted to fiat.",
            "format": "double"
          },
          "completedConfirmations": {
            "type": "integer",
            "description": "Current number of network confirmations.",
            "format": "int64",
            "nullable": true
          },
          "institutionTransferFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "The fee that was taken by the institution.",
            "nullable": true
          },
          "networkGasFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "The gas fee that was taken by the network. Depending on the integration, the network gas fee might be\r\ncovered by the `InstitutionTransferFee`.",
            "nullable": true
          },
          "smartContract": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SmartContractTransferAllocation"
              }
            ],
            "description": "Details of the allocated Smart Contract in case of 'Deposit' type transfers.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ExecuteTransferStatus": {
        "enum": [
          "succeeded",
          "inProgress",
          "failed",
          "mfaRequired",
          "emailConfirmationRequired",
          "deviceConfirmationRequired",
          "mfaFailed",
          "addressWhitelistRequired",
          "secondMfaRequired",
          "deFiWalletConfirmationRequired",
          "emailConfirmationApprovalRequired"
        ],
        "type": "string"
      },
      "FailureReason": {
        "enum": [
          "notSupportedOnIntegration",
          "notSupportedOnNetwork",
          "invalidAddressFormat",
          "notSupportedOnToken"
        ],
        "type": "string"
      },
      "FinancialInstitutionIntegrationType": {
        "enum": [
          "brokerage",
          "bank",
          "exchange",
          "wallet",
          "address",
          "nftMarketplace",
          "deFiWallet"
        ],
        "type": "string"
      },
      "GetLinkTokenRequest": {
        "required": [
          "userId"
        ],
        "type": "object",
        "properties": {
          "userId": {
            "maxLength": 300,
            "minLength": 1,
            "type": "string",
            "description": "A unique Id representing the end user. Typically this will be a user Id from the\r\nclient application. Personally identifiable information, such as an email address or phone number,\r\nshould not be used. 300 characters length maximum."
          },
          "brokerType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of integration to redirect to. Will redirect to catalog if not provided.\r\nNot supported types: DeFiWallet, CryptocurrencyAddress, CryptocurrencyWallet.",
            "nullable": true,
            "deprecated": true
          },
          "restrictMultipleAccounts": {
            "type": "boolean",
            "description": "The final screen of Link allows users to “continue” back to your app or “Link another account.”\r\nIf this param is present then this button will be hidden."
          },
          "transferOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LinkTokenTransferOptions"
              }
            ],
            "description": "Encapsulates transaction-related parameters, including destination addresses and the amount to transfer in fiat currency.",
            "nullable": true
          },
          "integrationId": {
            "type": "string",
            "description": "A unique identifier representing a specific integration obtained from the list of available integrations.",
            "format": "uuid",
            "nullable": true
          },
          "disableApiKeyGeneration": {
            "type": "boolean",
            "description": "For direct integrations that also support API keys, Link presents the user with the option to generate an API key for seamless access.\r\nIf this param is true, this feature will be disabled."
          },
          "verifyWalletOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VerifyWalletOptions"
              }
            ],
            "description": "Encapsulates verify DeFi wallet parameters.",
            "nullable": true
          },
          "subClientId": {
            "type": "string",
            "description": "Sub Client ID, for B2B2B clients to tailor Link experience for their clients.",
            "format": "uuid",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "GoodsDetails": {
        "type": "object",
        "properties": {
          "goodsType": {
            "type": "string",
            "description": "The type of the goods for the order (01: Tangible Goods, 02: Virtual Goods).",
            "nullable": true
          },
          "goodsCategory": {
            "type": "string",
            "description": "The category of goods (e.g., Electronics, Food).",
            "nullable": true
          },
          "referenceGoodsId": {
            "type": "string",
            "description": "A unique reference ID to identify the goods.",
            "nullable": true
          },
          "goodsName": {
            "type": "string",
            "description": "The name of the goods.",
            "nullable": true
          },
          "goodsDetail": {
            "type": "string",
            "description": "Additional details about the goods (optional).",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "HoldingTransferIneligibilityReason": {
        "enum": [
          "noEligibleNetworks",
          "symbolDoesNotMatch",
          "notSupportedForTransferByTarget",
          "notSupportedForTransferBySource",
          "eligibleWithFunding",
          "amountNotSufficient",
          "noPrice"
        ],
        "type": "string"
      },
      "HoldingsModel": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "succeeded",
              "failed",
              "notAuthorized"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerRequestStatus"
              }
            ],
            "description": "Status of the request to the institution's API"
          },
          "errorMessage": {
            "type": "string",
            "description": "Error message specifying the problem",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly error message, optimized to be shown to the end user",
            "nullable": true
          },
          "notSupportedEquityPositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Position"
            },
            "description": "The equity positions Front could not recognize",
            "nullable": true
          },
          "notSupportedCryptocurrencyPositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Position"
            },
            "description": "The cryptocurrency positions Front could not recognize",
            "nullable": true
          },
          "nftPositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/B2BNftPosition"
            },
            "description": "NFT holdings on the account",
            "nullable": true
          },
          "optionPositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/B2BOptionPosition"
            },
            "description": "Option holdings on the account",
            "nullable": true
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution"
          },
          "accountId": {
            "type": "string",
            "description": "External institution's account id (returned by the institution)",
            "nullable": true
          },
          "institutionName": {
            "type": "string",
            "description": "Friendly name of the connected institution",
            "nullable": true
          },
          "accountName": {
            "type": "string",
            "description": "Name of the account as returned from the institution",
            "nullable": true
          },
          "equityPositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PositionWithMarketValue"
            },
            "description": "Equity holdings, such as stocks and ETFs",
            "nullable": true
          },
          "cryptocurrencyPositions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PositionWithMarketValue"
            },
            "description": "Cryptocurrency holdings on the account",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "HoldingsModelApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/HoldingsModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "HoldingsRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "includeMarketValue": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "InitializeTransfersForLinkRequest": {
        "type": "object",
        "properties": {
          "toAddresses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransferToAddressWithAmount"
            },
            "description": "The list of destination addresses with corresponding networks are asset symbols that\r\ncan be used to initiate incoming transfers.",
            "nullable": true
          },
          "amountInFiat": {
            "type": "number",
            "description": "Amount in USD to transfer. If not provided users can specify amount by themselves.",
            "format": "double",
            "nullable": true
          },
          "transactionId": {
            "maxLength": 128,
            "minLength": 0,
            "type": "string",
            "description": "Transaction ID Provided by client to track transaction in future calls",
            "nullable": true
          },
          "clientFee": {
            "maximum": 1,
            "minimum": 0,
            "type": "number",
            "description": "A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments to your company.\r\nThis will override any default fee entered in your Mesh dashboard for an individual transaction.\r\nPlease note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),\r\nand not for Deposits (when the transfer destination is an address owned by the end user).\r\nIf used for Deposits, it will increase the size of the user's Deposit by the fee amount,\r\nbut will incorrectly show to the user as a fee.",
            "format": "double"
          },
          "transferType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferTypeEnum"
              }
            ],
            "description": "Deposit (default): The user is transferring crypto to a wallet they own on your platform.\r\nPayment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.\r\nOnramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.",
            "nullable": true
          },
          "description": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Transaction description. (Binance Pay)",
            "nullable": true
          },
          "goodsDetails": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GoodsDetails"
            },
            "description": "Goods details for the transaction. (Binance Pay)",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "IntegrationLogo": {
        "type": "object",
        "properties": {
          "logoLightUrl": {
            "type": "string",
            "description": "Light logo url.",
            "nullable": true
          },
          "logoDarkUrl": {
            "type": "string",
            "description": "Dark logo url.",
            "nullable": true
          },
          "logoWhiteUrl": {
            "type": "string",
            "description": "White logo url.",
            "nullable": true
          },
          "logoBlackUrl": {
            "type": "string",
            "description": "Black logo url.",
            "nullable": true
          },
          "logoColorUrl": {
            "type": "string",
            "description": "Colored logo url.",
            "nullable": true
          },
          "iconLightUrl": {
            "type": "string",
            "description": "White icon url.",
            "nullable": true
          },
          "iconDarkUrl": {
            "type": "string",
            "description": "Light icon url.",
            "nullable": true
          },
          "iconWhiteUrl": {
            "type": "string",
            "description": "Dark icon url.",
            "nullable": true
          },
          "iconBlackUrl": {
            "type": "string",
            "description": "Balck icon url.",
            "nullable": true
          },
          "iconColorUrl": {
            "type": "string",
            "description": "Colored logo url.",
            "nullable": true
          },
          "base64Logo": {
            "type": "string",
            "description": "Base64 PNG logo.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Integreation logos."
      },
      "IntegrationModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Integration unique identifier.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "Integration name.",
            "nullable": true
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Integration type."
          },
          "deFiWalletProviderId": {
            "type": "string",
            "description": "DeFi wallet provider identifier.",
            "nullable": true
          },
          "categories": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FinancialInstitutionIntegrationType"
            },
            "description": "Integration categories.",
            "nullable": true
          },
          "style": {
            "allOf": [
              {
                "$ref": "#/components/schemas/IntegrationStyle"
              }
            ],
            "description": "Style object.",
            "nullable": true
          },
          "logo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/IntegrationLogo"
              }
            ],
            "description": "Logo object.",
            "nullable": true
          },
          "forgotPasswordLink": {
            "type": "string",
            "description": "Forgot Password Link.",
            "nullable": true
          },
          "cryptoTransfersSupported": {
            "type": "boolean",
            "description": "Indicates if crypto transfers supported by integration."
          }
        },
        "additionalProperties": false,
        "description": "Integration model."
      },
      "IntegrationNetwork": {
        "type": "object",
        "properties": {
          "networkId": {
            "type": "string",
            "format": "uuid"
          },
          "netwokName": {
            "type": "string",
            "nullable": true
          },
          "innerNetworkId": {
            "type": "string",
            "nullable": true
          },
          "networkLogo": {
            "type": "string",
            "nullable": true
          },
          "brokerType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "IntegrationNetworkResponse": {
        "type": "object",
        "properties": {
          "integrations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntegrationNetworksModelResponse"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "IntegrationNetworkResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/IntegrationNetworkResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "IntegrationNetworksModelResponse": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Integration unique identifier.",
            "format": "uuid"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the integration."
          },
          "name": {
            "type": "string",
            "description": "Name of the integration.",
            "nullable": true
          },
          "networks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NetworkResponseWithSupportedDevices"
            },
            "description": "The list of supported networks and corresponding tokens for the integration.",
            "nullable": true
          },
          "supportsOutgoingTransfers": {
            "type": "boolean",
            "description": "Specifies if the integration supports outgoing transfers."
          },
          "supportsIncomingTransfers": {
            "type": "boolean",
            "description": "Specifies if the integration supports incoming transfers."
          }
        },
        "additionalProperties": false
      },
      "IntegrationStyle": {
        "type": "object",
        "properties": {
          "fieldActiveLight": {
            "type": "string",
            "description": "Field Active Light Hex Color",
            "nullable": true
          },
          "buttonPrimaryLight": {
            "type": "string",
            "description": "Button Primary Light Hex Color",
            "nullable": true
          },
          "buttonHoverLight": {
            "type": "string",
            "description": "Button Hover Light Hex Color",
            "nullable": true
          },
          "buttonTextLight": {
            "type": "string",
            "description": "Button Text Light Hex Color",
            "nullable": true
          },
          "buttonTextHoverLight": {
            "type": "string",
            "description": "Button Text Hover Light Hex Color",
            "nullable": true
          },
          "fieldActiveDark": {
            "type": "string",
            "description": "Field Active Dark Hex Color",
            "nullable": true
          },
          "buttonPrimaryDark": {
            "type": "string",
            "description": "Button Primary Dark Hex Color",
            "nullable": true
          },
          "buttonHoverDark": {
            "type": "string",
            "description": "Button Hover Dark Hex Color",
            "nullable": true
          },
          "buttonTextDark": {
            "type": "string",
            "description": "Button Text Dark Hex Color",
            "nullable": true
          },
          "buttonTextHoverDark": {
            "type": "string",
            "description": "Button Text Hover Dark Hex Color",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Integration style"
      },
      "IntegrationsResponse": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntegrationModel"
            },
            "description": "Integrations list.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Integration response."
      },
      "IntegrationsResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/IntegrationsResponse"
              }
            ],
            "description": "Integration response.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LinkTokenModel": {
        "type": "object",
        "properties": {
          "linkToken": {
            "type": "string",
            "nullable": true
          },
          "paymentLink": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LinkTokenModelApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/LinkTokenModel"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "LinkTokenTransferOptions": {
        "type": "object",
        "properties": {
          "toAddresses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransferToAddressWithAmount"
            },
            "description": "The list of destination addresses with corresponding networks are asset symbols that\r\ncan be used to initiate incoming transfers. If this parameter is present, the Link\r\nsession will continue to transfer flow after connecting the origin account.",
            "nullable": true
          },
          "amountInFiat": {
            "type": "number",
            "description": "Amount in USD to transfer. If not provided users can specify amount by themselves.",
            "format": "double",
            "nullable": true
          },
          "transactionId": {
            "maxLength": 128,
            "minLength": 0,
            "type": "string",
            "description": "Transaction ID Provided by client to track transaction in future calls",
            "nullable": true
          },
          "clientFee": {
            "maximum": 1,
            "minimum": 0,
            "type": "number",
            "description": "A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments to your company.\r\nThis will override any default fee entered in your Mesh dashboard for an individual transaction.\r\nPlease note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),\r\nand not for Deposits (when the transfer destination is an address owned by the end user).\r\nIf used for Deposits, it will increase the size of the user's Deposit by the fee amount,\r\nbut will incorrectly show to the user as a fee.",
            "format": "double",
            "nullable": true
          },
          "transferType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferTypeEnum"
              }
            ],
            "description": "Deposit: The user is transferring crypto to a wallet they own on your platform.\r\nPayment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.\r\nOnramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.",
            "nullable": true
          },
          "fundingOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferCryptocurrencyFundingOptions"
              }
            ],
            "description": "Specifies the permitted options to use the end user's available buying power\r\nand/or payment methods to supplement the cryptocurrency balance if it is insufficient\r\nfor the transfer.",
            "nullable": true
          },
          "isInclusiveFeeEnabled": {
            "type": "boolean",
            "description": "Specifies if all the fees are included in the amount to transfer."
          },
          "description": {
            "maxLength": 256,
            "minLength": 0,
            "type": "string",
            "description": "Transaction description. (Binance Pay)",
            "nullable": true
          },
          "goodsDetails": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GoodsDetails"
            },
            "description": "Goods details for the transaction. (Binance Pay)",
            "nullable": true
          },
          "generatePayLink": {
            "type": "boolean",
            "description": "Link presents the user with the option to generate a unique payment link for Mesh pay scenarios.\r\nIf this param is true, a unique payment link will be returned."
          }
        },
        "additionalProperties": false
      },
      "ManagedBrokerCryptocurrencyDepositAddressRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the required cryptocurrency, e.g. ETH or BTC.\r\nCan be used instead of the `AddressType` field.",
            "nullable": true
          },
          "addressType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ],
            "description": "Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.\r\nCan be used instead of `Symbol` field.",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "description": "Specifies which the network to use to obtain the deposit address of the `Symbol` asset.",
            "format": "uuid"
          },
          "mfaCode": {
            "type": "string",
            "description": "Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "MfaScheme": {
        "enum": [
          "mfaCode",
          "challenge",
          "deviceConfirmation",
          "securityQuestion"
        ],
        "type": "string"
      },
      "MfaType": {
        "enum": [
          "phone",
          "email",
          "totp",
          "phoneAndEmail",
          "requireNextSecurityQuestion",
          "readEmail",
          "face",
          "tradingPin",
          "qrCode",
          "password",
          "roaming",
          "mobile"
        ],
        "type": "string"
      },
      "NetworkModelResponse": {
        "type": "object",
        "properties": {
          "networks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NetworkResponseWithIntegrations"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "NetworkModelResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NetworkModelResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "NetworkResponseBase": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Id of the network in Mesh system. Should be used to initiate transfers.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "The name if the network.",
            "nullable": true
          },
          "chainId": {
            "type": "string",
            "description": "The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137.",
            "nullable": true
          },
          "logoUrl": {
            "type": "string",
            "description": "Network logo URL.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Crypto network."
      },
      "NetworkResponseToken": {
        "type": "object",
        "properties": {
          "symbol": {
            "type": "string",
            "nullable": true
          },
          "logoUrl": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "NetworkResponseWithIntegrations": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Id of the network in Mesh system. Should be used to initiate transfers.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "The name if the network.",
            "nullable": true
          },
          "chainId": {
            "type": "string",
            "description": "The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137.",
            "nullable": true
          },
          "logoUrl": {
            "type": "string",
            "description": "Network logo URL.",
            "nullable": true
          },
          "supportedTokens": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of tokens that are currently supported to be transferred using the network.",
            "nullable": true
          },
          "nativeSymbol": {
            "type": "string",
            "description": "The symbol of the network's native cryptocurrency.",
            "nullable": true
          },
          "networkType": {
            "enum": [
              "unknown",
              "evm",
              "solana",
              "bitcoin",
              "cardano",
              "tron",
              "avalancheX",
              "tezos",
              "dogecoin",
              "ripple",
              "stellar",
              "litecoin",
              "sui",
              "aptos",
              "tvm",
              "injective"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/NetworkType"
              }
            ],
            "description": "Network type."
          },
          "tokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NetworkResponseToken"
            },
            "description": "The list of tokens that are currently supported to be transferred using the network.",
            "nullable": true
          },
          "supportedBrokerTypes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerType"
            },
            "description": "The list of types of integrations that are currently supported to perform transfers over the network.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Crypto network."
      },
      "NetworkResponseWithSupportedDevices": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Id of the network in Mesh system. Should be used to initiate transfers.",
            "format": "uuid"
          },
          "name": {
            "type": "string",
            "description": "The name if the network.",
            "nullable": true
          },
          "chainId": {
            "type": "string",
            "description": "The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137.",
            "nullable": true
          },
          "logoUrl": {
            "type": "string",
            "description": "Network logo URL.",
            "nullable": true
          },
          "supportedTokens": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of tokens that are currently supported to be transferred using the network.",
            "nullable": true
          },
          "nativeSymbol": {
            "type": "string",
            "description": "The symbol of the network's native cryptocurrency.",
            "nullable": true
          },
          "supportedDevices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeviceType"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "NetworkTransferIneligibilityReason": {
        "enum": [
          "amountNotSufficient",
          "gasFeeAssetBalanceNotEnough",
          "noTargetNetworkFound",
          "refusedByInstitution",
          "eligibleWithFunding",
          "balanceBelowRequestedAmount",
          "requestedAmountBelowMinimum",
          "balanceBelowMinimum",
          "requestedAmountBelowFees",
          "requestedAmountBelowClientMinimum",
          "requestedAmountAboveClientMaximum",
          "noPrice",
          "nyCoinbaseUserRestrictions"
        ],
        "type": "string"
      },
      "NetworkType": {
        "enum": [
          "unknown",
          "evm",
          "solana",
          "bitcoin",
          "cardano",
          "tron",
          "avalancheX",
          "tezos",
          "dogecoin",
          "ripple",
          "stellar",
          "litecoin",
          "sui",
          "aptos",
          "tvm",
          "injective"
        ],
        "type": "string"
      },
      "NftBlockchain": {
        "enum": [
          "ethereum",
          "polygon",
          "klaytn"
        ],
        "type": "string"
      },
      "NftOrder": {
        "type": "object",
        "properties": {
          "orderSide": {
            "enum": [
              "buy",
              "sell"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/NftOrderSide"
              }
            ]
          },
          "symbol": {
            "type": "string",
            "nullable": true
          },
          "price": {
            "type": "number",
            "format": "double"
          },
          "priceUsd": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "format": "double"
          },
          "createdTimestamp": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "updatedTimestamp": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "symbolLogo": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "NftOrderSide": {
        "enum": [
          "buy",
          "sell"
        ],
        "type": "string"
      },
      "NftPositionWithMarketValues": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "number",
            "format": "double"
          },
          "costBasis": {
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "contractAddress": {
            "type": "string",
            "nullable": true
          },
          "paymentTokenSymbol": {
            "type": "string",
            "nullable": true
          },
          "name": {
            "type": "string",
            "nullable": true
          },
          "description": {
            "type": "string",
            "nullable": true
          },
          "imageUrl": {
            "type": "string",
            "nullable": true
          },
          "imageOriginalUrl": {
            "type": "string",
            "nullable": true
          },
          "animationUrl": {
            "type": "string",
            "nullable": true
          },
          "backgroundColor": {
            "type": "string",
            "nullable": true
          },
          "marketplaceId": {
            "type": "string",
            "nullable": true
          },
          "tokenId": {
            "type": "string",
            "nullable": true
          },
          "numberOfSales": {
            "type": "integer",
            "format": "int64",
            "nullable": true
          },
          "contractType": {
            "type": "string",
            "nullable": true
          },
          "contractName": {
            "type": "string",
            "nullable": true
          },
          "contractSchemaName": {
            "type": "string",
            "nullable": true
          },
          "contractSymbol": {
            "type": "string",
            "nullable": true
          },
          "contractDescription": {
            "type": "string",
            "nullable": true
          },
          "marketplacePermalink": {
            "type": "string",
            "nullable": true
          },
          "contractExternalLink": {
            "type": "string",
            "nullable": true
          },
          "creatorAddress": {
            "type": "string",
            "nullable": true
          },
          "currentOffer": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NftOrder"
              }
            ],
            "nullable": true
          },
          "lastSale": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NftOrder"
              }
            ],
            "nullable": true
          },
          "blockchain": {
            "enum": [
              "ethereum",
              "polygon",
              "klaytn"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/NftBlockchain"
              }
            ]
          },
          "addressExplorerLink": {
            "type": "string",
            "nullable": true
          },
          "twitterUsername": {
            "type": "string",
            "nullable": true
          },
          "marketValue": {
            "type": "number",
            "description": "Amount of NFTs multiplied by NFT value",
            "format": "double",
            "nullable": true
          },
          "portfolioPercentage": {
            "type": "number",
            "description": "What percentage of total portfolio value is taken by this NFT",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PortfolioBrokerBaseRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```OpenSea```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```KuCoinDirect```\n```OkxOAuth```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BitsoDirect```\n```BinanceOAuth```\n```BybitDirect```\n```ParibuOAuth```\n```BinanceTrDirect```\n```BybitDirectMobile```\n```DeFiWallet```\n"
          }
        },
        "additionalProperties": false
      },
      "PortfolioFiatBalance": {
        "type": "object",
        "properties": {
          "symbol": {
            "type": "string",
            "description": "Balance currency",
            "nullable": true
          },
          "cash": {
            "type": "number",
            "description": "Amount of money in a specific currency from all brokers",
            "format": "double",
            "nullable": true
          },
          "buyingPower": {
            "type": "number",
            "description": "BuyingPower from all brokers, it indicates total amount of money the user can spend on buying stock.\r\nAlways includes cash and can also include margin",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PortfolioHoldingsRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```OpenSea```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```KuCoinDirect```\n```OkxOAuth```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BitsoDirect```\n```BinanceOAuth```\n```BybitDirect```\n```ParibuOAuth```\n```BinanceTrDirect```\n```BybitDirectMobile```\n```DeFiWallet```\n"
          },
          "includeMarketValue": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "Position": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the asset",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the asset",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Amount of the asset",
            "format": "double"
          },
          "costBasis": {
            "type": "number",
            "description": "The total original value (or purchase price) of the asset",
            "format": "double",
            "nullable": true
          },
          "distribution": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeFiPositionDistribution"
            },
            "description": "Breakdown of crypto distribution across different networks and addresses.\r\nThis data is populated only for self-custody (DeFi) wallets.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PositionWithMarketValue": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the asset",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the asset",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Amount of the asset",
            "format": "double"
          },
          "costBasis": {
            "type": "number",
            "description": "The total original value (or purchase price) of the asset",
            "format": "double",
            "nullable": true
          },
          "distribution": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeFiPositionDistribution"
            },
            "description": "Breakdown of crypto distribution across different networks and addresses.\r\nThis data is populated only for self-custody (DeFi) wallets.",
            "nullable": true
          },
          "marketValue": {
            "type": "number",
            "description": "Market value of the asset: amount of asset multiplied by last asset value.",
            "format": "double",
            "nullable": true
          },
          "lastPrice": {
            "type": "number",
            "description": "Current last price of the asset.",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PositionWithReturn": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the asset",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the asset",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Amount of the asset",
            "format": "double"
          },
          "costBasis": {
            "type": "number",
            "description": "The total original value (or purchase price) of the asset",
            "format": "double",
            "nullable": true
          },
          "distribution": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeFiPositionDistribution"
            },
            "description": "Breakdown of crypto distribution across different networks and addresses.\r\nThis data is populated only for self-custody (DeFi) wallets.",
            "nullable": true
          },
          "marketValue": {
            "type": "number",
            "description": "Market value of the asset: amount of asset multiplied by last asset value.",
            "format": "double",
            "nullable": true
          },
          "lastPrice": {
            "type": "number",
            "description": "Current last price of the asset.",
            "format": "double",
            "nullable": true
          },
          "portfolioPercentage": {
            "type": "number",
            "description": "What percentage of total portfolio value is taken by this asset.",
            "format": "double",
            "nullable": true
          },
          "totalReturn": {
            "type": "number",
            "description": "Total return of investment of this asset. Can be negative or null. Based on the cost basis of the asset, cost basis\r\nis not available by some of integrations.",
            "format": "double",
            "nullable": true
          },
          "returnPercentage": {
            "type": "number",
            "description": "Percent of return of investment for this asset. Can be negative or null.",
            "format": "double",
            "nullable": true
          },
          "companyName": {
            "type": "string",
            "description": "Company name of the relative asset.",
            "nullable": true
          },
          "totalDailyReturn": {
            "type": "number",
            "description": "Total daily return of investment for this asset. Can be negative.",
            "format": "double",
            "nullable": true
          },
          "dailyReturnPercentage": {
            "type": "number",
            "description": "Daily percent of return of investment for this asset. Can be negative.",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PreviewTransferRequest": {
        "required": [
          "fromAuthToken",
          "fromType"
        ],
        "type": "object",
        "properties": {
          "fromAuthToken": {
            "minLength": 1,
            "type": "string",
            "description": "The authentication token to send the asset from."
          },
          "fromType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "The type of the integration to send the asset from."
          },
          "toAuthToken": {
            "type": "string",
            "description": "The authentication token of the target integration. Can be used alternatively to the address in the `ToAddress` field.\r\nIf used, `toType` should also be provided.",
            "nullable": true
          },
          "toType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `ToAddress`.",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "description": "The network to send the asset over.",
            "format": "uuid"
          },
          "symbol": {
            "type": "string",
            "description": "The symbol of the digital asset to send.",
            "nullable": true
          },
          "toAddress": {
            "type": "string",
            "description": "The target address to send the asset to.",
            "nullable": true
          },
          "addressTag": {
            "type": "string",
            "description": "Secondary address identifier for coins like XRP,XMR etc.",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "The amount to send, in crypto.",
            "format": "double",
            "nullable": true
          },
          "amountInFiat": {
            "type": "number",
            "description": "The amount to send, in fiat currency. Can be used alternatively to `Amount`.",
            "format": "double",
            "nullable": true
          },
          "fiatCurrency": {
            "type": "string",
            "description": "Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`.",
            "nullable": true
          },
          "transactionId": {
            "maxLength": 128,
            "minLength": 0,
            "type": "string",
            "description": "Transaction ID Provided by client to track transaction in future calls.",
            "nullable": true
          },
          "isBridging": {
            "type": "boolean",
            "description": "Indicates that the transfer is a bridging transfer.",
            "nullable": true
          },
          "isInclusiveFeeEnabled": {
            "type": "boolean",
            "description": "Specifies if all the fees are included in the amount to transfer."
          }
        },
        "additionalProperties": false
      },
      "PreviewTransferResponse": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "succeeded",
              "failed",
              "requiresFunding"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/PreviewTransferStatus"
              }
            ],
            "description": "The status of the operation."
          },
          "previewResult": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PreviewTransferResult"
              }
            ],
            "description": "Result of the preview.",
            "nullable": true
          },
          "transferBalanceFundingAvailability": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferBalanceFundingAvailability"
              }
            ],
            "nullable": true
          },
          "transferFromAnotherAccountAvailabilityInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFromAnotherAccountAvailabilityInfo"
              }
            ],
            "description": "For instance if not enough assets in Spot account, and we can fill it from Funding account",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PreviewTransferResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PreviewTransferResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PreviewTransferResult": {
        "type": "object",
        "properties": {
          "previewId": {
            "type": "string",
            "description": "The Id of the preview of the transfer. Should be used to commit the transfer using `Execute` endpoint.",
            "format": "uuid",
            "nullable": true
          },
          "previewExpiresIn": {
            "type": "integer",
            "description": "The period of time in seconds during which the transfer can be committed.",
            "format": "int32"
          },
          "fromAddress": {
            "type": "string",
            "description": "Obtained address that will be used to send the transfer. Not guaranteed to be returned by some of integrations.",
            "nullable": true
          },
          "refundAddress": {
            "type": "string",
            "description": "Obtained address that will be used to refund the transfer. Not guaranteed to be returned by some of integrations.",
            "nullable": true
          },
          "toAddress": {
            "type": "string",
            "description": "The target address to send the asset to.",
            "nullable": true
          },
          "addressTag": {
            "type": "string",
            "description": "Secondary address identifier for coins like XRP, XMR etc.",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the asset to be sent.",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Amount in symbol. If the transfer was requested using `AmountInFiat` field, this field represents the exact amount\r\nof the asset that will be transferred.",
            "format": "double"
          },
          "amountInFiat": {
            "type": "number",
            "description": "Transfer amount in fiat. If the transfer was requested in crypto amount using the `Amount` field,\r\nthis field contains the corresponding converted to fiat value.",
            "format": "double"
          },
          "totalEstimatedAmount": {
            "type": "number",
            "description": "Total estimated amount of the transfer including all fees, in cryptocurrency.",
            "format": "double"
          },
          "totalEstimatedAmountInFiat": {
            "type": "number",
            "description": "Total estimated amount of the transfer including all fees, converted to fiat.",
            "format": "double"
          },
          "networkId": {
            "type": "string",
            "description": "Id of the network in Front system.",
            "format": "uuid"
          },
          "networkName": {
            "type": "string",
            "description": "Name of the network in Front system.",
            "nullable": true
          },
          "contractAddress": {
            "type": "string",
            "description": "Blockchain address of the transferred token's contract",
            "nullable": true
          },
          "institutionTransferFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not\r\ntake the transfer fee and only network fee is used for the transfer.",
            "nullable": true
          },
          "estimatedNetworkGasFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be\r\ncovered by the `InstitutionTransferFee`.",
            "nullable": true
          },
          "estimatedNetworkGasFeeDetails": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFeeDetails"
              }
            ],
            "description": "The gas fee values in EIP 1559 standard that is estimated to be taken by the network.",
            "nullable": true
          },
          "decimalPlaces": {
            "type": "integer",
            "description": "Number of decimal places used to represent the token's smallest unit",
            "format": "int32",
            "nullable": true
          },
          "unitPrice": {
            "type": "number",
            "description": "The price of the cryptocurrency asset in the fiat currency.",
            "format": "double"
          },
          "clientTransactionId": {
            "maxLength": 128,
            "minLength": 0,
            "type": "string",
            "description": "Transaction id provided by the client",
            "nullable": true
          },
          "clientFee": {
            "maximum": 1,
            "minimum": 0,
            "type": "number",
            "description": "A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments.\r\nThis will override any default fee entered in your Mesh dashboard for an individual transaction.\r\nPlease note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),\r\nand not for Deposits (when the transfer destination is an address owned by the end user).\r\nIf used for Deposits, it will increase the size of the user's Deposit by the fee amount,\r\nbut will incorrectly show to the user as a fee.",
            "format": "double",
            "nullable": true
          },
          "customClientFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "The client fee that is estimated to be added to the total estimated transfer amount, based on the user's requested transfer amount and client fee percentage.",
            "nullable": true
          },
          "processingFeeRetainMethod": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProcessingFeeRetainMethod"
              }
            ],
            "nullable": true
          },
          "transferType": {
            "enum": [
              "deposit",
              "payment",
              "onramp"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferTypeEnum"
              }
            ],
            "description": "Deposit: The user is transferring crypto to a wallet they own on your platform.\r\nPayment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.\r\nOnramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform."
          },
          "isCustomClientFeeProvided": {
            "type": "boolean"
          },
          "amountWithCustomClientFee": {
            "type": "number",
            "description": "Amount in symbol after the client fees are applied. This field represents the exact amount\r\nof the asset that will be requested for transfer.",
            "format": "double"
          },
          "isFeeIncluded": {
            "type": "boolean",
            "description": "Indicates if all the fees are included in the amount. For example, if this field's value is `true`\r\nand the user wants to send 1 BTC and the sum of all fees is 0.1 BTC, the user will be charged 1 BTC, and\r\nthe target address will receive 0.9 BTC.\r\nIf the fees are no inclusive, the user will be charged 1.1 BTC and the target address will receive 1 BTC."
          },
          "amountToReceive": {
            "type": "number",
            "description": "Indicates the final amount to receive after all fees are applied. In case fees are not inclusive (`IsFeeIncluded` is `false`),\r\nthis field will be equal to the `Amount` field.",
            "format": "double"
          },
          "amountToReceiveInFiat": {
            "type": "number",
            "description": "Indicates the final amount in fiat to receive after all fees are applied. In case fees are not inclusive (`IsFeeIncluded` is `false`),\r\nthis field will be equal to the `AmountInFiat` field.",
            "format": "double"
          },
          "transferAmountToRequest": {
            "type": "number",
            "description": "Exact amount in cryptocurrency requested to transfer to the destination address using the target integration.",
            "format": "double"
          },
          "isMaximumAmount": {
            "type": "boolean",
            "description": "Indicates if the transfer's intention is to transfer all available assets using the requested network and symbol."
          },
          "fiatCurrency": {
            "type": "string",
            "description": "Indicates the fiat currency that is used to calculate transfer amounts.",
            "nullable": true
          },
          "isBridging": {
            "type": "boolean",
            "description": "Indicates if the transfer is a bridging transfer, meaning that the transfer will be swapped between two different networks."
          },
          "bridgingDetails": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BridgingDetails"
              }
            ],
            "description": "Details of the bridging operation, in case the transfer is a bridging transfer.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "PreviewTransferStatus": {
        "enum": [
          "succeeded",
          "failed",
          "requiresFunding"
        ],
        "type": "string"
      },
      "ProblemDetails": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "nullable": true
          },
          "title": {
            "type": "string",
            "nullable": true
          },
          "status": {
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "detail": {
            "type": "string",
            "nullable": true
          },
          "instance": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": { }
      },
      "ProcessingFeeRetainMethod": {
        "type": "object",
        "properties": {
          "type": {
            "enum": [
              "default",
              "smartDeposit"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ProcessingFeeRetainType"
              }
            ]
          },
          "processingFeeAddress": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "ProcessingFeeRetainType": {
        "enum": [
          "default",
          "smartDeposit"
        ],
        "type": "string"
      },
      "QuoteFees": {
        "type": "object",
        "properties": {
          "inFiat": {
            "allOf": [
              {
                "$ref": "#/components/schemas/QuoteFeesInFiat"
              }
            ],
            "description": "Summary of all possible transfer fees in fiat",
            "nullable": true
          },
          "inCrypto": {
            "allOf": [
              {
                "$ref": "#/components/schemas/QuoteFeesInCrypto"
              }
            ],
            "description": "Summary of all possible transfer fees in crypto",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "QuoteFeesInCrypto": {
        "type": "object",
        "properties": {
          "paymentMethodFeeMax": {
            "type": "number",
            "description": "Max fee charged if funded by payment method",
            "format": "double"
          },
          "tradingFeeMax": {
            "type": "number",
            "description": "Max fee charged to buy crypto",
            "format": "double"
          },
          "withdrawalFee": {
            "type": "number",
            "description": "Fee charged to withdraw crypto",
            "format": "double"
          },
          "partnerFee": {
            "type": "number",
            "description": "Fee charged by partner",
            "format": "double"
          },
          "networkFee": {
            "type": "number",
            "description": "Fee charged for network transaction",
            "format": "double"
          },
          "minFees": {
            "type": "number",
            "description": "Min of total fees charged in crypto",
            "format": "double"
          },
          "maxFees": {
            "type": "number",
            "description": "Max of total fees charged in crypto",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "QuoteFeesInFiat": {
        "type": "object",
        "properties": {
          "paymentMethodFeeMaxFiat": {
            "type": "number",
            "description": "Max fee charged if funded by payment method",
            "format": "double"
          },
          "tradingFeeMaxFiat": {
            "type": "number",
            "description": "Max fee charged to buy crypto",
            "format": "double"
          },
          "withdrawalFeeFiat": {
            "type": "number",
            "description": "Fee charged to withdraw crypto",
            "format": "double"
          },
          "partnerFeeFiat": {
            "type": "number",
            "description": "Fee charged by partner",
            "format": "double"
          },
          "networkFeeFiat": {
            "type": "number",
            "description": "Fee charged for network transaction",
            "format": "double"
          },
          "minFeesFiat": {
            "type": "number",
            "description": "Min of total fees charged in fiat",
            "format": "double"
          },
          "maxFeesFiat": {
            "type": "number",
            "description": "Max of total fees charged in fiat",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "QuoteFundingOption": {
        "type": "object",
        "properties": {
          "fundingOption": {
            "enum": [
              "existingCryptocurrencyBalance",
              "buyingPowerPurchase",
              "paymentMethodDepositUsage",
              "cryptocurrencyConversion",
              "stableCoinNoFeeConversion",
              "cryptocurrencyBuyingPowerConversion",
              "cryptocurrencyMultiStepConversion"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyFundingOptionType"
              }
            ],
            "description": "Funding option being quoted"
          },
          "paymentMethodType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerPaymentMethodType"
              }
            ],
            "description": "Payment method being quoted for PaymentMethodDepositUsage funding option",
            "nullable": true
          },
          "paymentMethodFeeFiat": {
            "type": "number",
            "description": "Fee charged for this payment method",
            "format": "double"
          },
          "tradingFeeFiat": {
            "type": "number",
            "description": "Fee charged to buy crypto if necessary for this funding option",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "QuoteTransferRequest": {
        "required": [
          "amountInFiat",
          "brokerType",
          "fiatCurrency",
          "networkId",
          "symbol",
          "toAddress"
        ],
        "type": "object",
        "properties": {
          "amountInFiat": {
            "type": "number",
            "description": "Base amount of fiat currency being transferred",
            "format": "double"
          },
          "fiatCurrency": {
            "maxLength": 3,
            "minLength": 0,
            "type": "string",
            "description": "3 character currency code, e.g. USD"
          },
          "symbol": {
            "maxLength": 10,
            "minLength": 0,
            "type": "string",
            "description": "Symbol of destination cryptocurrency, e.g. ETH"
          },
          "networkId": {
            "type": "string",
            "description": "Unique id of destination network",
            "format": "uuid"
          },
          "toAddress": {
            "maxLength": 1024,
            "minLength": 0,
            "type": "string",
            "description": "The designated destination for sending the asset."
          },
          "brokerType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "The type of the integration to send the asset from"
          },
          "feeFlat": {
            "type": "number",
            "description": "Flat fee in crypto to be charged as a partner fee",
            "format": "double",
            "nullable": true
          },
          "feePercentage": {
            "type": "number",
            "description": "Percentage of transfer amount to be charged as a partner fee, expressed as decimal (ie 0.1 = 10%)",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "QuoteTransferResponse": {
        "type": "object",
        "properties": {
          "amountInFiat": {
            "type": "number",
            "description": "Base amount of fiat currency being transferred (provided in request)",
            "format": "double"
          },
          "fiatCurrency": {
            "type": "string",
            "description": "3 character currency code (provided in request)",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of destination cryptocurrency (provided in request)",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "description": "Unique id of destination network (provided in request)",
            "format": "uuid"
          },
          "toAddress": {
            "type": "string",
            "description": "The designated destination for sending the asset.",
            "nullable": true
          },
          "brokerType": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "The type of the integration to send the asset from (provided in request)"
          },
          "isEligible": {
            "type": "boolean",
            "description": "Is the transaction is possible based on the minimum transfer amount of the selected exchange"
          },
          "minEligibleAmount": {
            "type": "number",
            "description": "Minimum amount eligible to transfer with selected asset, exchange, and network",
            "format": "double"
          },
          "minEligibleAmountFiat": {
            "type": "number",
            "description": "Minimum amount in fiat eligible to transfer with selected asset, exchange, and network",
            "format": "double"
          },
          "maxEligibleAmount": {
            "type": "number",
            "description": "Maximum amount eligible to transfer with selected asset, exchange, and network",
            "format": "double",
            "nullable": true
          },
          "maxEligibleAmountFiat": {
            "type": "number",
            "description": "Maximum amount eligible in fiat to transfer with selected asset, exchange, and network",
            "format": "double",
            "nullable": true
          },
          "ineligibilityReason": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NetworkTransferIneligibilityReason"
              }
            ],
            "description": "The reason a transaction is ineligible, returns none if eligible",
            "nullable": true
          },
          "brokerPrice": {
            "type": "number",
            "description": "Price quote from the broker, falls back to reference price",
            "format": "double"
          },
          "price": {
            "type": "number",
            "description": "Reference price",
            "format": "double"
          },
          "minAmountFiat": {
            "type": "number",
            "description": "Min amount transferred in fiat",
            "format": "double"
          },
          "maxAmountFiat": {
            "type": "number",
            "description": "Max amount transferred in fiat",
            "format": "double"
          },
          "minAmount": {
            "type": "number",
            "description": "Min amount of crypto transferred",
            "format": "double"
          },
          "maxAmount": {
            "type": "number",
            "description": "Max amount of crypto transferred",
            "format": "double"
          },
          "fees": {
            "allOf": [
              {
                "$ref": "#/components/schemas/QuoteFees"
              }
            ],
            "description": "Summary of all possible transfer fees",
            "nullable": true
          },
          "fundingOptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/QuoteFundingOption"
            },
            "description": "Summary of all possible funding options",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "QuoteTransferResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/QuoteTransferResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SmartContractTransferAllocation": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "Blockchain address of the Smart Contract",
            "nullable": true
          },
          "expirationTimestamp": {
            "type": "integer",
            "description": "The timestamp by which the transfer must be completely initiated. Currently, this means solving the MFA steps",
            "format": "int64"
          }
        },
        "additionalProperties": false
      },
      "StringApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "SymbolTradingAllowance": {
        "enum": [
          "fractionalTradingAllowed",
          "fractionalTradingNotAllowed",
          "tradingNotAllowed",
          "fractionalTradingPossiblyAllowed"
        ],
        "type": "string"
      },
      "TokenNetworksModel": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "nullable": true
          },
          "networks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NetworkResponseBase"
            },
            "nullable": true
          },
          "supportedIntegrations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerType"
            },
            "nullable": true
          },
          "integrationNetworks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntegrationNetwork"
            },
            "nullable": true
          },
          "tokenLogoUrl": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TokenNetworksResponse": {
        "type": "object",
        "properties": {
          "tokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TokenNetworksModel"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TokenNetworksResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TokenNetworksResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransactionsB2BBrokerCreateOrderRequest": {
        "required": [
          "amount",
          "amountIsInPaymentSymbol",
          "authToken",
          "isCryptocurrency",
          "orderType",
          "paymentIsCryptocurrency",
          "paymentSymbol",
          "symbol",
          "timeInForce",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```Bybit```\n```CoinbasePrime```\n```RobinhoodConnect```\n"
          },
          "symbol": {
            "minLength": 1,
            "type": "string",
            "description": "Symbol to trade. For example, `AAPL` or `ETH`"
          },
          "paymentSymbol": {
            "minLength": 1,
            "type": "string",
            "description": "Symbol to use for payment, defaults to `USD`."
          },
          "amount": {
            "type": "number",
            "description": "Amount of purchase.",
            "format": "double"
          },
          "price": {
            "type": "number",
            "description": "Price of the unit, used for `Limit` and `StopLoss` orders.",
            "format": "double"
          },
          "isCryptocurrency": {
            "type": "boolean",
            "description": "Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly."
          },
          "paymentIsCryptocurrency": {
            "type": "boolean",
            "description": "Indicates whether the `PaymentSymbol` is fiat or cryptocurrency"
          },
          "amountIsFiat": {
            "type": "boolean",
            "nullable": true,
            "deprecated": true
          },
          "amountInFiat": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "deprecated": true
          },
          "amountIsInPaymentSymbol": {
            "type": "boolean",
            "description": "This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be\r\nperformed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and\r\n`SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`\r\nvalue is passed."
          },
          "amountInPaymentSymbol": {
            "type": "number",
            "description": "Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`\r\nand `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.",
            "format": "double",
            "nullable": true
          },
          "extendedHours": {
            "type": "boolean",
            "description": "Specifies if the extended trading hours should be used."
          },
          "orderType": {
            "enum": [
              "market",
              "limit",
              "stopLoss"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderPlaceTypeTrade"
              }
            ]
          },
          "timeInForce": {
            "enum": [
              "goodTillCanceled",
              "immediateOrCancel",
              "fillOrKill",
              "goodForDay",
              "postOnly",
              "unknown"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderTimeInForceType"
              }
            ]
          },
          "mfaCode": {
            "type": "string",
            "description": "MFA Code to create an order (requested by Kraken if MFA is enabled in user settings)",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransactionsB2BBrokerOrderListRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```Bybit```\n```CoinbasePrime```\n```RobinhoodConnect```\n"
          },
          "cursor": {
            "type": "string",
            "description": "The cursor to retrieve the next page of transactions.\r\nProviding it will cause the response to only return changes after this update.\r\nIf this field is not provided, the history of transactions will be returned starting with the first-added transaction.",
            "nullable": true
          },
          "count": {
            "type": "integer",
            "description": "Number of records to include in the response. \n\r\nDefault: `100` \n\r\nMaximum: `250`",
            "format": "int32"
          },
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerOrderStatus"
            },
            "description": "Return orders of this statuses only. If this field is not provided, orders with all available statuses will be returned.",
            "nullable": true
          },
          "from": {
            "type": "integer",
            "description": "Return orders created after this timestamp.\r\nIf this field is not provided, orders will be returned according to the default of the institution.",
            "format": "int64",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransactionsB2BBrokerOrderRequest": {
        "required": [
          "authToken",
          "id",
          "isCryptocurrency",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```Bybit```\n```CoinbasePrime```\n```RobinhoodConnect```\n"
          },
          "id": {
            "minLength": 1,
            "type": "string"
          },
          "side": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderType"
              }
            ],
            "description": "Should be provided for Coinbase.",
            "nullable": true
          },
          "isCryptocurrency": {
            "type": "boolean",
            "description": "Some Stock and Crypto symbols can intersect, so we need to explicitly specify what type of asset is requested to be bought."
          },
          "symbolPair": {
            "type": "string",
            "description": "Symbol pair of the order (requested by some brokers).",
            "nullable": true
          },
          "mfaCode": {
            "type": "string",
            "description": "MFA Code to cancel an order (requested by Kraken if MFA is enabled in user settings)",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransactionsB2BBrokerSymbolInfoForOrderRequest": {
        "required": [
          "amount",
          "amountIsInPaymentSymbol",
          "authToken",
          "isCryptocurrency",
          "orderType",
          "paymentIsCryptocurrency",
          "paymentSymbol",
          "symbol",
          "timeInForce",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```Bybit```\n```CoinbasePrime```\n```RobinhoodConnect```\n"
          },
          "symbol": {
            "minLength": 1,
            "type": "string",
            "description": "Symbol to trade. For example, `AAPL` or `ETH`"
          },
          "paymentSymbol": {
            "minLength": 1,
            "type": "string",
            "description": "Symbol to use for payment, defaults to `USD`."
          },
          "amount": {
            "type": "number",
            "description": "Amount of purchase.",
            "format": "double"
          },
          "price": {
            "type": "number",
            "description": "Price of the unit, used for `Limit` and `StopLoss` orders.",
            "format": "double"
          },
          "isCryptocurrency": {
            "type": "boolean",
            "description": "Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly."
          },
          "paymentIsCryptocurrency": {
            "type": "boolean",
            "description": "Indicates whether the `PaymentSymbol` is fiat or cryptocurrency"
          },
          "amountIsFiat": {
            "type": "boolean",
            "nullable": true,
            "deprecated": true
          },
          "amountInFiat": {
            "type": "number",
            "format": "double",
            "nullable": true,
            "deprecated": true
          },
          "amountIsInPaymentSymbol": {
            "type": "boolean",
            "description": "This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be\r\nperformed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and\r\n`SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`\r\nvalue is passed."
          },
          "amountInPaymentSymbol": {
            "type": "number",
            "description": "Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`\r\nand `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.",
            "format": "double",
            "nullable": true
          },
          "extendedHours": {
            "type": "boolean",
            "description": "Specifies if the extended trading hours should be used."
          },
          "orderType": {
            "enum": [
              "market",
              "limit",
              "stopLoss"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderPlaceTypeTrade"
              }
            ]
          },
          "timeInForce": {
            "enum": [
              "goodTillCanceled",
              "immediateOrCancel",
              "fillOrKill",
              "goodForDay",
              "postOnly",
              "unknown"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderTimeInForceType"
              }
            ]
          },
          "mfaCode": {
            "type": "string",
            "description": "MFA Code to create an order (requested by Kraken if MFA is enabled in user settings)",
            "nullable": true
          },
          "side": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerOrderType"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransactionsBrokerBaseRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```Bybit```\n```CoinbasePrime```\n```RobinhoodConnect```\n"
          }
        },
        "additionalProperties": false
      },
      "TransferBalanceFundingAvailability": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "disabled",
              "available",
              "requiresAmountLowering",
              "notApplicable",
              "unavailable"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferBalanceFundingAvailabilityStatus"
              }
            ]
          },
          "transferTotalAmount": {
            "type": "number",
            "description": "The total transfer amount in crypto after all fees are applied",
            "format": "double"
          },
          "unitPrice": {
            "type": "number",
            "description": "The price of the cryptocurrency asset in the fiat currency.",
            "format": "double"
          },
          "gasFeeBuffer": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "Represents the safety margin amount to cover gas fee volatility.",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "nullable": true
          },
          "transferTotalAmountInFiat": {
            "type": "number",
            "description": "The total transfer amount in fiat after all fees are applied.",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "TransferBalanceFundingAvailabilityBase": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "disabled",
              "available",
              "requiresAmountLowering",
              "notApplicable",
              "unavailable"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferBalanceFundingAvailabilityStatus"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "TransferBalanceFundingAvailabilityStatus": {
        "enum": [
          "disabled",
          "available",
          "requiresAmountLowering",
          "notApplicable",
          "unavailable"
        ],
        "type": "string"
      },
      "TransferCryptocurrencyFundingOptions": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Indicates whether the Link is permitted to use the end user's available buying power\r\nand/or payment methods to supplement the cryptocurrency balance if it is insufficient\r\nfor the transfer."
          }
        },
        "additionalProperties": false
      },
      "TransferFee": {
        "type": "object",
        "properties": {
          "fee": {
            "type": "number",
            "description": "The amount of the fee.",
            "format": "double"
          },
          "feeCurrency": {
            "type": "string",
            "description": "The currency of the fee. Does not match the currency of the transfer in some cases.",
            "nullable": true
          },
          "feeInFiat": {
            "type": "number",
            "description": "The value of the fee converted to the fiat currency.",
            "format": "double"
          }
        },
        "additionalProperties": false
      },
      "TransferFeeDetails": {
        "type": "object",
        "properties": {
          "gasLimit": {
            "type": "number",
            "description": "Units of gas used",
            "format": "double",
            "nullable": true
          },
          "maxPriorityFeePerGas": {
            "type": "number",
            "description": "The max amount of tip to be paid to validator",
            "format": "double",
            "nullable": true
          },
          "maxFeePerGas": {
            "type": "number",
            "description": "The max amount of fee to be paid per gas",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferFromAnotherAccountAvailabilityInfo": {
        "type": "object",
        "properties": {
          "transferFromAnotherAccountNeeded": {
            "type": "boolean"
          },
          "transferFromAnotherAccountAmount": {
            "type": "number",
            "format": "double"
          },
          "anotherAccountName": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferFundingModel": {
        "type": "object",
        "properties": {
          "type": {
            "enum": [
              "existingCryptocurrencyBalance",
              "buyingPowerPurchase",
              "paymentMethodDepositUsage",
              "cryptocurrencyConversion",
              "stableCoinNoFeeConversion",
              "cryptocurrencyBuyingPowerConversion",
              "cryptocurrencyMultiStepConversion"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyFundingOptionType"
              }
            ],
            "description": "Type of the funding method."
          },
          "amount": {
            "type": "number",
            "description": "Amount funded.",
            "format": "double"
          },
          "amountInFiat": {
            "type": "number",
            "description": "Amount in fiat.",
            "format": "double"
          },
          "toSymbol": {
            "type": "string",
            "description": "Symbol purchased.",
            "nullable": true
          },
          "fromAmount": {
            "type": "number",
            "description": "Amount used.",
            "format": "double"
          },
          "fromSymbol": {
            "type": "string",
            "description": "Symbol used.",
            "nullable": true
          },
          "paymentMethodType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerPaymentMethodType"
              }
            ],
            "description": "Payment method type",
            "nullable": true
          },
          "fee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "Fee of funding.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Funding method model."
      },
      "TransferIntegrationModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier of integration.",
            "format": "uuid"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of integration."
          },
          "name": {
            "type": "string",
            "description": "Name of integration.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "Integration model."
      },
      "TransferIntegrationWithLogoModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier of integration.",
            "format": "uuid"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of integration."
          },
          "name": {
            "type": "string",
            "description": "Name of integration.",
            "nullable": true
          },
          "logoUrl": {
            "type": "string",
            "description": "Integration logo URL.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferModel": {
        "required": [
          "id"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Mesh transfer identifier.",
            "format": "uuid"
          },
          "clientTransactionId": {
            "type": "string",
            "description": "Client transaction identifier.",
            "nullable": true
          },
          "institutionTransactionId": {
            "type": "string",
            "description": "Integration transaction identifier.",
            "nullable": true
          },
          "userId": {
            "type": "string",
            "description": "Client's user identifier.",
            "nullable": true
          },
          "status": {
            "enum": [
              "pending",
              "succeeded",
              "failed"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferStatus"
              }
            ],
            "description": "Transfer status."
          },
          "amountInFiat": {
            "type": "number",
            "description": "Transfer amount in fiat.",
            "format": "double"
          },
          "amountToReceiveInFiat": {
            "type": "number",
            "description": "Actual transfer amount without fees in fiat.",
            "format": "double"
          },
          "amountInFiatCurrencyCode": {
            "type": "string",
            "description": "Transfer amount in fiat currency code.",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Transfer amount.",
            "format": "double"
          },
          "amountToReceive": {
            "type": "number",
            "description": "Actual transfer amount without fees.",
            "format": "double"
          },
          "symbol": {
            "type": "string",
            "description": "Transfer cryptocurrency symbol.",
            "nullable": true
          },
          "tokenAddress": {
            "type": "string",
            "description": "Transfer cryptocurrency token contract address (e.g., for ERC20s).",
            "nullable": true
          },
          "networkName": {
            "type": "string",
            "description": "Transfer network name.",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "description": "Id of the transfer network.",
            "format": "uuid"
          },
          "networkLogoUrl": {
            "type": "string",
            "description": "Network logo URL.",
            "nullable": true
          },
          "createdTimestamp": {
            "type": "integer",
            "description": "Created timestamp.",
            "format": "int64"
          },
          "from": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferIntegrationWithLogoModel"
              }
            ],
            "description": "From integration.",
            "nullable": true
          },
          "hash": {
            "type": "string",
            "description": "Transfer hash.",
            "nullable": true
          },
          "subClientId": {
            "type": "string",
            "description": "Sub-client identifier.",
            "format": "uuid",
            "nullable": true
          },
          "infoUrl": {
            "type": "string",
            "description": "Transfer info url on blockchain explorer.",
            "format": "uri",
            "nullable": true
          },
          "gasFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "Transfer network gas fee.",
            "nullable": true
          },
          "withdrawalFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "Financial insitution withdrawal fee.",
            "nullable": true
          },
          "processingFee": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferFee"
              }
            ],
            "description": "Transfer processing fee.",
            "nullable": true
          },
          "executedTimestamp": {
            "type": "integer",
            "description": "Transfer executed Unix timestamp.",
            "format": "int64",
            "nullable": true
          },
          "transferType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferTypeEnum"
              }
            ],
            "description": "Type of a transfer.",
            "nullable": true
          },
          "isFeeIncluded": {
            "type": "boolean",
            "description": "Is fee included."
          },
          "sourceAmount": {
            "type": "number",
            "description": "Amount what was actually transferred from source account.",
            "format": "double",
            "nullable": true
          },
          "destinationAmount": {
            "type": "number",
            "description": "Amount what destination actually received.",
            "format": "double",
            "nullable": true
          },
          "destinationAmountInFiat": {
            "type": "number",
            "description": "Amount in fiat what destination actually received.",
            "format": "double",
            "nullable": true
          },
          "totalFeesAmountInFiat": {
            "type": "number",
            "description": "Total fees paid by user to execute this transaction.",
            "format": "double",
            "readOnly": true
          },
          "totalTransactionAmountInFiat": {
            "type": "number",
            "description": "Total fiat transaction amount in origin integration.",
            "format": "double",
            "readOnly": true
          },
          "fundingMethods": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransferFundingModel"
            },
            "description": "The funding methods that were used to fund the transaction.",
            "nullable": true
          },
          "destinationAddress": {
            "type": "string",
            "description": "Transfer Destination Address.",
            "nullable": true
          },
          "refundAddress": {
            "type": "string",
            "description": "Transfer Refund Address.",
            "nullable": true
          },
          "bridgingDetails": {
            "allOf": [
              {
                "$ref": "#/components/schemas/BridgingTransferDetailsModel"
              }
            ],
            "description": "Bridging operation details.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferModelPaginationResponse": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransferModel"
            },
            "description": "list of items",
            "nullable": true
          },
          "total": {
            "type": "integer",
            "description": "Total number of items",
            "format": "int32"
          }
        },
        "additionalProperties": false
      },
      "TransferModelPaginationResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferModelPaginationResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferOrderByFields": {
        "enum": [
          "id",
          "clientTransferId",
          "userId",
          "fromType",
          "amountInFiat",
          "status",
          "createdTimestamp",
          "symbol",
          "networkName"
        ],
        "type": "string"
      },
      "TransferStatus": {
        "enum": [
          "pending",
          "succeeded",
          "failed"
        ],
        "type": "string"
      },
      "TransferToAddress": {
        "type": "object",
        "properties": {
          "networkId": {
            "type": "string",
            "description": "The Id of the network in Front system. The list of all available networks can be obtained by\r\nusing `GET /transfers/managed/networks` endpoint.",
            "format": "uuid"
          },
          "symbol": {
            "type": "string",
            "description": "The symbol of the digital asset.",
            "nullable": true
          },
          "address": {
            "type": "string",
            "description": "The address to send the asset to.",
            "nullable": true
          },
          "addressTag": {
            "type": "string",
            "description": "Secondary address identifier for coins like XRP,XMR etc.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferToAddressWithAmount": {
        "type": "object",
        "properties": {
          "networkId": {
            "type": "string",
            "description": "The Id of the network in Front system. The list of all available networks can be obtained by\r\nusing `GET /transfers/managed/networks` endpoint.",
            "format": "uuid"
          },
          "symbol": {
            "type": "string",
            "description": "The symbol of the digital asset.",
            "nullable": true
          },
          "address": {
            "type": "string",
            "description": "The address to send the asset to.",
            "nullable": true
          },
          "addressTag": {
            "type": "string",
            "description": "Secondary address identifier for coins like XRP,XMR etc.",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Amount of tokens to transfer by specified network.",
            "format": "double",
            "nullable": true
          },
          "displayAmountInFiat": {
            "type": "number",
            "description": "Transfer amount in fiat which is requested by client to be shown as amount in fiat.\r\nIt will be shown to end-user if and only if it's difference with actual amount in fiat is less that 1%.",
            "format": "double",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferTravelRuleOptions": {
        "type": "object",
        "properties": {
          "transferType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferTypeEnum"
              }
            ],
            "nullable": true
          },
          "clientName": {
            "type": "string",
            "nullable": true
          },
          "clientType": {
            "enum": [
              "undefined",
              "wallet",
              "exchange",
              "vasp",
              "merchant",
              "other",
              "psp",
              "neobank",
              "iGaming",
              "aggregator"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ClientType"
              }
            ]
          },
          "clientId": {
            "type": "string",
            "format": "uuid"
          }
        },
        "additionalProperties": false
      },
      "TransferTypeEnum": {
        "enum": [
          "deposit",
          "payment",
          "onramp"
        ],
        "type": "string"
      },
      "TransferVerificationRequest": {
        "type": "object",
        "properties": {
          "integrationId": {
            "type": "string",
            "nullable": true
          },
          "token": {
            "type": "string",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "nullable": true
          },
          "targetAddress": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferVerificationResponse": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "succeeded",
              "failed"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferVerifyStatus"
              }
            ]
          },
          "errorMessage": {
            "type": "string",
            "nullable": true
          },
          "failureReason": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FailureReason"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferVerificationResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferVerificationResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransferVerifyStatus": {
        "enum": [
          "succeeded",
          "failed"
        ],
        "type": "string"
      },
      "TransfersBrokerCreateCryptocurrencyTransactionRequest": {
        "required": [
          "authToken",
          "targetAddress",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BinanceConnect```\n```RevolutConnect```\n```BinancePay```\n```ParibuOAuth```\n```PayPalConnect```\n```DeFiWallet```\n"
          },
          "data": {
            "type": "string",
            "description": "Additional data to send on-chain (optional, depends on an integration)",
            "nullable": true
          },
          "targetAddress": {
            "minLength": 1,
            "type": "string",
            "description": "Target address to transfer the asset to"
          },
          "amount": {
            "type": "number",
            "description": "Amount to transfer",
            "format": "double"
          },
          "fee": {
            "type": "number",
            "description": "On-chain fee (optional, depends on an integration)",
            "format": "double"
          },
          "addressType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ],
            "description": "Type of the address of symbol to be transferred. Providing `EthAddress` will initiate a transfer of ETH over Ethereum blockchain.\r\nCan be used instead of `Symbol` and `Chain` fields.\r\nTo transfer assets over non-default chains (e.g. sending USDT over ERC20) please `Symbol` and `Chain` fields.",
            "nullable": true
          },
          "mfaCode": {
            "type": "string",
            "description": "2 Factor auth code (optional, depends on an integration)",
            "nullable": true
          },
          "travelRuleTransactionId": {
            "type": "integer",
            "description": "Travel rule transaction id (optional, depends on an integration)",
            "format": "int32",
            "nullable": true
          },
          "mfaType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MfaType"
              }
            ],
            "description": "2 Factor auth type (optional, depends on an integration)",
            "nullable": true
          },
          "verificationSteps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MfaType"
            },
            "nullable": true
          },
          "password": {
            "type": "string",
            "description": "Password or pass-phrase, required to send transfers (optional, depends on an integration)",
            "nullable": true
          },
          "chain": {
            "type": "string",
            "description": "Custom chain name, required by some of the integrations. E.g. USDT can be sent over USDT-ERC20, USDT-TRC20, and USDT-Omni.\r\nCan be used to transfer assets over non-default chains (e.g. sending USDT over ERC20).\r\nPlease use `symbol/details` endpoint to get the list of all possible chains.",
            "nullable": true
          },
          "memo": {
            "type": "string",
            "description": "Memo (also called \"Tag\") - address remark.",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Symbol to be transferred. Can be provided instead of the `AddressType` field.",
            "nullable": true
          },
          "challengeId": {
            "type": "string",
            "nullable": true
          },
          "tryAnotherMfa": {
            "type": "boolean"
          },
          "travelRuleOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferTravelRuleOptions"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransfersBrokerCryptocurrencyDepositAddressRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BinanceConnect```\n```RevolutConnect```\n```BinancePay```\n```ParibuOAuth```\n```PayPalConnect```\n```DeFiWallet```\n"
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the required cryptocurrency, e.g. ETH or BTC.\r\nCan be used instead of the `AddressType` field.",
            "nullable": true
          },
          "addressType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ],
            "description": "Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.\r\nCan be used instead of `Symbol` field.",
            "nullable": true
          },
          "chain": {
            "type": "string",
            "description": "Chain of the required cryptocurrency, e.g. USDT has USDT-ERC20, USDT-TRC20, and USDT-Omni",
            "nullable": true
          },
          "mfaCode": {
            "type": "string",
            "description": "Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransfersBrokerCryptocurrencyTransactionDetailsRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BinanceConnect```\n```RevolutConnect```\n```BinancePay```\n```ParibuOAuth```\n```PayPalConnect```\n```DeFiWallet```\n"
          },
          "addressType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ],
            "description": "Type of the address of the transferred asset. Can be used instead of the `Symbol` field.",
            "nullable": true
          },
          "transactionId": {
            "type": "string",
            "description": "Transaction Id by the financial institution",
            "nullable": true
          },
          "transactionHash": {
            "type": "string",
            "description": "Hash of the transaction on the blockchain",
            "nullable": true
          },
          "symbol": {
            "type": "string",
            "description": "Symbol of the transferred asset. Can be provided instead of the `AddressType` field.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TransfersBrokerTransactionsListRequest": {
        "required": [
          "authToken",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BinanceConnect```\n```RevolutConnect```\n```BinancePay```\n```ParibuOAuth```\n```PayPalConnect```\n```DeFiWallet```\n"
          },
          "count": {
            "type": "integer",
            "description": "Number of records to include in the response. \n\r\nDefault: `100` \n\r\nMaximum: `250`",
            "format": "int32"
          },
          "cursor": {
            "type": "string",
            "description": "The cursor to retrieve the next page of transactions.\r\nProviding it will cause the response to only return changes after this update.\r\nIf this field is not provided, the history of transactions will be returned starting with the first-added transaction.",
            "nullable": true
          },
          "statuses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BrokerCryptocurrencyTransactionStatus"
            },
            "description": "If this value is provided, result set is filtered to only include transaction with the provided statuses.",
            "nullable": true
          },
          "cryptocurrencyAddressType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CryptocurrencyAddressType"
              }
            ],
            "description": "For cryptocurrency address the type of address is required.",
            "nullable": true
          },
          "from": {
            "type": "integer",
            "description": "If this value is provided, result set is filtered to only include transactions created after this timestamp",
            "format": "int64",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "TrueAuthAuthRequest": {
        "required": [
          "cookies",
          "requestHeaders",
          "userAgent"
        ],
        "type": "object",
        "properties": {
          "requestHeaders": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "nullable": true
            },
            "nullable": true
          },
          "cookies": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "nullable": true
          },
          "userAgent": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UpdateTransferModel": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Mesh transfer identifier.",
            "format": "uuid"
          },
          "clientTransactionId": {
            "type": "string",
            "description": "Client transaction identifier.",
            "nullable": true
          },
          "institutionTransactionId": {
            "type": "string",
            "description": "Integration transaction identifier.",
            "nullable": true
          },
          "userId": {
            "type": "string",
            "description": "Client's user identifier.",
            "nullable": true
          },
          "status": {
            "enum": [
              "pending",
              "succeeded",
              "failed"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferStatus"
              }
            ],
            "description": "Transfer status."
          },
          "amountInFiat": {
            "type": "number",
            "description": "Transfer amount in fiat.",
            "format": "double"
          },
          "amountInFiatCurrencyCode": {
            "type": "string",
            "description": "Transfer amount in fiat currency code.",
            "nullable": true
          },
          "amount": {
            "type": "number",
            "description": "Transfer amount.",
            "format": "double"
          },
          "symbol": {
            "type": "string",
            "description": "Transfer cryptocurrency symbol.",
            "nullable": true
          },
          "networkName": {
            "type": "string",
            "description": "Transfer network name.",
            "nullable": true
          },
          "createdTimestamp": {
            "type": "integer",
            "description": "Created timestamp.",
            "format": "int64"
          },
          "from": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferIntegrationModel"
              }
            ],
            "description": "From integration.",
            "nullable": true
          },
          "hash": {
            "type": "string",
            "description": "Transfer hash.",
            "nullable": true
          },
          "executedTimestamp": {
            "type": "integer",
            "description": "Transfer executed Unix timestamp.",
            "format": "int64",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UpdateTransferResponse": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "pending",
              "succeeded",
              "failed"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferStatus"
              }
            ],
            "description": "The status of the transfer."
          },
          "statusDetails": {
            "enum": [
              "unknown",
              "failed",
              "frozen",
              "succeeded",
              "mfaRequired",
              "pending",
              "expired",
              "canceled",
              "waitingForSignature",
              "waitingForClearing",
              "awaitingApproval",
              "awaitingConfirmation",
              "awaitingVerification",
              "rejected",
              "pendingCancel",
              "emailVerification",
              "deviceConfirmationRequired",
              "mfaFailed",
              "addressWhitelistRequired",
              "secondMfaRequired",
              "emailConfirmationApprovalRequired",
              "travelRuleRequired"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerCryptocurrencyTransactionStatus"
              }
            ],
            "description": "The status details of the transfer."
          },
          "errorMessage": {
            "type": "string",
            "description": "Error message, if the operation did not complete successfully.",
            "nullable": true
          },
          "transferResult": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UpdateTransferModel"
              }
            ],
            "description": "Result of the transfer initiation.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UpdateTransferResponseApiResult": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "ok",
              "serverFailure",
              "permissionDenied",
              "badRequest",
              "notFound",
              "conflict",
              "tooManyRequest",
              "locked",
              "unavailableForLegalReasons"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/ApiResultStatus"
              }
            ],
            "readOnly": true
          },
          "message": {
            "type": "string",
            "description": "A message generated by the API",
            "nullable": true
          },
          "displayMessage": {
            "type": "string",
            "description": "User-friendly display message that can be presented to the end user",
            "nullable": true
          },
          "errorType": {
            "type": "string",
            "description": "Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.\r\nAll possible error types are available in the documentation.",
            "nullable": true
          },
          "errorData": {
            "nullable": true,
            "readOnly": true
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UpdateTransferResponse"
              }
            ],
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UpdateTransferStatusRequest": {
        "required": [
          "authToken",
          "transactionId",
          "type"
        ],
        "type": "object",
        "properties": {
          "authToken": {
            "minLength": 1,
            "type": "string",
            "description": "Auth token that allows connecting to the target institution"
          },
          "type": {
            "enum": [
              "robinhood",
              "eTrade",
              "alpaca",
              "tdAmeritrade",
              "weBull",
              "stash",
              "interactiveBrokers",
              "public",
              "coinbase",
              "kraken",
              "coinbasePro",
              "cryptoCom",
              "openSea",
              "binanceUs",
              "gemini",
              "cryptocurrencyAddress",
              "cryptocurrencyWallet",
              "okCoin",
              "bittrex",
              "kuCoin",
              "etoro",
              "cexIo",
              "binanceInternational",
              "bitstamp",
              "gateIo",
              "acorns",
              "okx",
              "bitFlyer",
              "coinlist",
              "huobi",
              "bitfinex",
              "deFiWallet",
              "krakenDirect",
              "vanguard",
              "binanceInternationalDirect",
              "bitfinexDirect",
              "bybit",
              "paxos",
              "coinbasePrime",
              "btcTurkDirect",
              "kuCoinDirect",
              "okxOAuth",
              "paribuDirect",
              "robinhoodConnect",
              "blockchainCom",
              "bitsoDirect",
              "binanceConnect",
              "binanceOAuth",
              "revolutConnect",
              "binancePay",
              "bybitDirect",
              "paribuOAuth",
              "payPalConnect",
              "binanceTrDirect",
              "coinbaseRamp",
              "bybitDirectMobile"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/BrokerType"
              }
            ],
            "description": "Type of the institution to connect"
          },
          "transactionId": {
            "minLength": 1,
            "type": "string",
            "description": "Id of the executed transfer."
          }
        },
        "additionalProperties": false
      },
      "UserIdentificationType": {
        "enum": [
          "none",
          "idCard",
          "driversLicense",
          "passport"
        ],
        "type": "string"
      },
      "VerifyWalletOptions": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "Verification message to sign.\r\nRequired if `signedMessage` is provided in <paramref name=\"VerificationMethods\">VerificationMethods</paramref> list.",
            "nullable": true
          },
          "verificationMethods": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WalletVerificationMethod"
            },
            "description": "List or required verification methods. By default - sign message with wallet key.",
            "nullable": true
          },
          "addresses": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Addresses list to verify. If user verifies another address then verification will be failed.",
            "nullable": true
          },
          "networkId": {
            "type": "string",
            "description": "Network to verify. If user verifies another network address then verification will be failed.\r\nChecked only if Addresses is provided.",
            "format": "uuid",
            "nullable": true
          },
          "networkType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NetworkType"
              }
            ],
            "description": "Network type to verify. If user verifies another network address then verification will be failed.\r\nChecked only if Addresses is provided.",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "description": "DeFi wallet verification options."
      },
      "WalletVerificationMethod": {
        "enum": [
          "signedMessage"
        ],
        "type": "string",
        "description": "Verification method."
      }
    },
    "securitySchemes": {
      "Client-Secret": {
        "type": "apiKey",
        "description": "Contact Mesh to get client Secret",
        "name": "X-Client-Secret",
        "in": "header"
      },
      "Client-Id": {
        "type": "apiKey",
        "description": "Contact Mesh to get client Id",
        "name": "X-Client-Id",
        "in": "header"
      }
    }
  },
  "security": [
    {
      "Client-Secret": [ ],
      "Client-Id": [ ]
    }
  ],
  "tags": [
    {
      "name": "QuickNode"
    },
    {
      "name": "Integrations account information"
    },
    {
      "name": "Managed Account Authentication",
      "description": "The recommended approach for account authentication. Front manages multiple authentication flows and handles all authentication steps such as MFA codes and OAuth redirect through our web and mobile SDKs."
    },
    {
      "name": "Self Managed Account Authentication",
      "description": "Not recommended approach. Using this approach, the API client is responsible for handling multiple authentication flows and supporting future updates and changes."
    },
    {
      "name": "Portfolio",
      "description": "\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```OpenSea```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```KuCoinDirect```\n```OkxOAuth```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BitsoDirect```\n```BinanceOAuth```\n```BybitDirect```\n```ParibuOAuth```\n```BinanceTrDirect```\n```BybitDirectMobile```\n```DeFiWallet```\n"
    },
    {
      "name": "Balance",
      "description": "\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```KuCoinDirect```\n```OkxOAuth```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BitsoDirect```\n```BybitDirect```\n```ParibuOAuth```\n```BinanceTrDirect```\n```BybitDirectMobile```\n"
    },
    {
      "name": "Transactions",
      "description": "\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```CexIo```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```BitFlyer```\n```Coinlist```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```Bybit```\n```CoinbasePrime```\n```RobinhoodConnect```\n\n\n### Integration-specific notes:\n\n\n#### Binance:\n\n\nBecause of limitations of Binance API, initial loading of transaction history in Binance can take long time\n\ndepending on the size of the portfolio.\n\n\n#### OkCoin:\n\n\nGetting transactions history from OkCoin is not currently supported.\n"
    },
    {
      "name": "Transfers",
      "description": "\n\n### Supported integrations:\n```Robinhood```\n```Coinbase```\n```Kraken```\n```CryptoCom```\n```Binance```\n```Gemini```\n```OkCoin```\n```KuCoin```\n```BinanceInternational```\n```Bitstamp```\n```GateIo```\n```Okx```\n```Huobi```\n```Bitfinex```\n```KrakenDirect```\n```BinanceInternationalDirect```\n```BitfinexDirect```\n```Bybit```\n```Paxos```\n```CoinbasePrime```\n```BtcTurkDirect```\n```ParibuDirect```\n```RobinhoodConnect```\n```BlockchainCom```\n```BinanceConnect```\n```RevolutConnect```\n```BinancePay```\n```ParibuOAuth```\n```PayPalConnect```\n```DeFiWallet```\n\n\n### Integration-specific notes:\n\n\n#### Robinhood:\n\n\nCryptocurrency transfers should be enabled in Robinhood settings. Transfers are disabled by default, enabling them for end users requires a review from Robinhood.\n\nPlease note:\n * `MfaCode` parameter is required to initiate a transaction in Robinhood.\n * The user's security settings should be configured to use an authenticator application.\n * Robinhood doesn't allow initiation of transactions if the authenticator application is not configured.\n\n\n#### Coinbase:\n\n\n`MfaCode` parameter should be used to initiate transactions in Coinbase.\n * If the end user's Coinbase account is configured to use text messages (SMS) for two factor authentication, the API will return `MfaRequired` status, and a text code will then be sent by Coinbase. The code is expected to be provided in the subsequent call using the `MfaCode` request field\n * If the account is configured to use an authenticator application, the API is expecting to get the code in the `MfaCode` request field.\n\n\n#### Kraken:\n\n\nKraken requires the explicit chain name to be provided (e.g. `Dogecoin` or `Ethereum (ERC20)`). The list of possible chains can be obtained by calling `symbol/details` endpoint.\n\nTo initiate a transaction, a Kraken Address Key name should be provided in `TargetAddress` field. Target address should be added using Kraken UI, then its name should be used.\n\n\n#### Binance:\n\n\n`Enable Withdrawals` permission should be given to the user's API key to initiate transfers with Binance Us.\n\nBinance requires adding the IP address to the list of trusted IPs to be able to create API keys with transfer permission.\n * Please reach out to Front to get the static IP address. This address should be provided to the end user, and the user should be instructed to add it to the list of trusted IP addresses.\n * By default, the permission to enable withdrawals is turned off. If the end user's API key does not have the permission, asset transfers will not be available.\n\n\n#### KuCoin:\n\n\nKuCoin requires adding the IP address to the list of trusted IPs to be able to create API keys with transfer permission.\n\n`Fee` parameter should be used to initiate a transaction in KuCoin.\n\nPlease note:\n * Please reach out to Front to get the static IP address. This address should be provided to the end user, and the user should be instructed to add it to the list of trusted IP addresses.\n * All currencies have their minimum `fee` and `amount` requirements. Please use `symbol/details` endpoint to get this data for a particular symbol.\n * KuCoin requires chain name to be provided for getting deposit address or initiating a cryptocurrency transfer. Some cryptocurrencies are supported over multiple chains. It's recommended to use `symbol/details` endpoint to get the list of supported chains and show it to the end user to select a target one.\n\n\n#### BinanceInternational:\n\n\n`Enable Withdrawals` permission should be given to the user's API key to initiate transfers with Binance International.\n\nBinance requires adding the IP address to the list of trusted IPs to be able to create API keys with transfer permission.\n * Please reach out to Front to get the static IP address. This address should be provided to the end user, and the user should be instructed to add it to the list of trusted IP addresses.\n * By default, the permission to enable withdrawals is turned off. If the end user's API key does not have the permission, asset transfers will not be available.\n\n\n#### GateIo:\n\n\nGate.io requires adding IP address to the list of trusted IP addresses to be able to initiate a cryptocurrency transfers.\n\nWithdrawal address should be already verified or added on the Gate.io UI (in mobile application or on the web site).\n * Please reach out to Front to get the static IP address for withdrawals. This address should be provided to the end user, and the user should be instructed to add it to the list of trusted IP addresses.\n * Only verified withdrawal blockchain addresses are allowed for withdrawal with Gate.io API.\n * Gate.io requires chain name to be provided for getting deposit address or initiating a cryptocurrency transfer. Some cryptocurrencies are supported over multiple chains. It's recommended to use `symbol/details` endpoint to get the list of supported chains and show it to the end user to select a target one.\n\n\n#### Huobi:\n\n\nWarning: Huobi does not refund executed deposits that are below the `Minimum Deposit Amount`\n * Please check the MinimumDepositAmount in Get Deposit Address response in order to avoid making a deposit below the minimum amount\n * Huobi does not allow withdrawals to addresses that are not white-listed, please add the address that you would like to withdraw to the white list of addresses through the UI so that a withrawal can be processed\n\n\n#### Bitfinex:\n * The hash of transfer is not available when making a transfer in Bitfinex. To get the hash please re-query the transfer using the transaction id.\n * Bitfinex does not separate sub-accounts when returning the list of transfers.Therefore the same list of transfers is returned for all Bitfinex sub-accounts.\n\n\n#### KrakenDirect:\n\n\nKraken requires the explicit chain name to be provided (e.g. `Dogecoin` or `Ethereum (ERC20)`). The list of possible chains can be obtained by calling `symbol/details` endpoint.\n\nTo initiate a transaction, a Kraken Address Key name should be provided in `TargetAddress` field. Target address should be added using Kraken UI, then its name should be used.\n\n\n#### BitfinexDirect:\n * The hash of transfer is not available when making a transfer in Bitfinex. To get the hash please re-query the transfer using the transaction id.\n * Bitfinex does not separate sub-accounts when returning the list of transfers.Therefore the same list of transfers is returned for all Bitfinex sub-accounts.\n"
    },
    {
      "name": "Assets"
    },
    {
      "name": "Managed Transfers"
    },
    {
      "name": "Wallets"
    }
  ]
}
</file>

<file path="experimental_client/README.md">
# Experimental Client

A WIP [EffectTS](https://effect.website/) client for MeshConnect. Enables
type-level tracking of error types.
</file>

<file path="experimental_client/tsconfig.json">
{
  "extends": "../tsconfig.base",
  "compilerOptions": {
    "noEmit": false,
    "outDir": "./dist"
  },
  "exclude": ["dist"],
  "include": ["."]
}
</file>

<file path="playground/tsconfig.json">
{
  "extends": "../tsconfig.base",
  "include": ["."],
  "references": [{ "path": "../experimental_client" }]
}
</file>

<file path="server/tsconfig.json">
{
  "extends": "../tsconfig.base",
  "include": ["."],
  "references": [
    { "path": "../domain" },
    { "path": "../experimental_client" }
  ]
}
</file>

<file path="tasks/ensure_uuid_extension.ts">
import * as PgClient from "@effect/sql-pg/PgClient"
import * as Config from "effect/Config"
import * as Console from "effect/Console"
import * as Effect from "effect/Effect"

await Effect.gen(function*() {
  yield* Console.log("Register `uuid-ossp` extension.")
  const sql = yield* PgClient.PgClient
  yield* sql`CREATE EXTENSION if NOT EXISTS "uuid-ossp";`
}).pipe(
  Effect.provide(PgClient.layerConfig({
    url: Config.redacted("DATABASE_URL"),
  })),
  Effect.runPromise,
)
</file>

<file path="tasks/main.ts">
export {}
</file>

<file path="tasks/tsconfig.json">
{
  "extends": "../tsconfig.base",
  "include": ["."]
}
</file>

<file path="cspell.json">
{
  "$schema": "https://raw.githubusercontent.com/streetsidesoftware/cspell/main/cspell.schema.json",
  "version": "0.2",
  "dictionaryDefinitions": [
    {
      "name": "project-words",
      "path": "words.txt"
    }
  ],
  "enableGlobDot": true,
  "dictionaries": ["project-words"],
  "ignorePaths": [
    "app/components/ui",
    "experimental_client/Generated.ts"
  ],
  "useGitignore": true
}
</file>

<file path="tsconfig.base.json">
{
  "compilerOptions": {
    "composite": true,
    "declaration": true,
    "esModuleInterop": true,
    "exactOptionalPropertyTypes": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "lib": ["ESNext", "DOM", "DOM.AsyncIterable"],
    "module": "ESNext",
    "moduleDetection": "force",
    "moduleResolution": "bundler",
    "noEmit": true,
    "noErrorTruncation": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": true,
    "noImplicitThis": true,
    "noImplicitReturns": true,
    "noUncheckedIndexedAccess": true,
    "noUncheckedSideEffectImports": true,
    "noUnusedParameters": true,
    "plugins": [
      {
        "name": "@effect/language-service",
        "transform": "@effect/language-service/transform",
        "namespaceImportPackages": [
          "@effect/platform",
          "@effect/platform-browser",
          "@effect/platform-bun",
          "effect"
        ],
        "diagnosticSeverity": {
          "importFromBarrel": "error"
        }
      }
    ],
    "resolveJsonModule": true,
    "rewriteRelativeImportExtensions": true,
    "allowImportingTsExtensions": true,
    "skipLibCheck": true,
    "sourceMap": true,
    "strict": true,
    "strictBindCallApply": true,
    "strictFunctionTypes": true,
    "strictNullChecks": true,
    "strictPropertyInitialization": true,
    "target": "ESNext",
    "typeRoots": ["node_modules/@types"],
    "useDefineForClassFields": true,
    "verbatimModuleSyntax": true
  },
  "exclude": ["node_modules"]
}
</file>

<file path="app/components/ui/dialog.tsx">
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"
import * as React from "react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className,
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className,
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="domain/index.ts">
export * from "./Api.ts"
export * from "./common.ts"
</file>

<file path="domain/tsconfig.json">
{
  "extends": "../tsconfig.base",
  "compilerOptions": {
    "noEmit": false,
    "outDir": "./dist"
  },
  "exclude": ["dist"],
  "include": ["."],
  "references": [{ "path": "../experimental_client" }]
}
</file>

<file path="experimental_client/package.json">
{
  "name": "@1b1/experimental_client",
  "private": true,
  "type": "module",
  "exports": {
    "./Generated": "./dist/Generated.js",
    "./MeshClient": "./dist/MeshClient.js"
  },
  "peerDependencies": {
    "@effect/platform": "^0.87.13",
    "effect": "^3.16.13"
  }
}
</file>

<file path="tasks/generate_mesh_client.ts">
import * as BunContext from "@effect/platform-bun/BunContext"
import * as Command from "@effect/platform/Command"
import * as FetchHttpClient from "@effect/platform/FetchHttpClient"
import * as FileSystem from "@effect/platform/FileSystem"
import * as HttpClient from "@effect/platform/HttpClient"
import * as HttpClientRequest from "@effect/platform/HttpClientRequest"
import * as HttpClientResponse from "@effect/platform/HttpClientResponse"
import * as Console from "effect/Console"
import * as Effect from "effect/Effect"

const OPENAPI_SPEC_PATH = "experimental_client/openapi.json"

await Effect.gen(function*() {
  yield* Console.log("Generating `experimental_client/Generated.ts`.")
  const client = yield* HttpClient.HttpClient
  const spec = yield* HttpClientRequest.get("https://integration-api.meshconnect.com/swagger/v1/swagger.json").pipe(
    HttpClientRequest.accept("text/plain"),
    client.execute,
    Effect.flatMap(HttpClientResponse.filterStatusOk),
    Effect.flatMap((v) => v.text),
  )
  const fs = yield* FileSystem.FileSystem
  yield* fs.writeFileString(OPENAPI_SPEC_PATH, spec)
  const code = yield* Command.string(
    Command.make(`./node_modules/.bin/openapi-gen`, "-s", OPENAPI_SPEC_PATH),
  )
  yield* fs.writeFileString("experimental_client/Generated.ts", code)
}).pipe(
  Effect.provide(BunContext.layer),
  Effect.provide(FetchHttpClient.layer),
  Effect.runPromise,
)
</file>

<file path="dprint.json">
{
  "markdown": {
    "textWrap": "always"
  },
  "typescript": {
    "arrowFunction.useParentheses": "force",
    "lineWidth": 120,
    "quoteProps": "asNeeded",
    "semiColons": "asi"
  },
  "plugins": [
    "https://plugins.dprint.dev/g-plane/markup_fmt-v0.20.0.wasm",
    "https://plugins.dprint.dev/g-plane/pretty_yaml-v0.5.1.wasm",
    "https://plugins.dprint.dev/markdown-0.18.0.wasm",
    "https://plugins.dprint.dev/typescript-0.95.5.wasm",
    "https://plugins.dprint.dev/json-0.20.0.wasm",
    "https://plugins.dprint.dev/g-plane/malva-v0.12.1.wasm"
  ]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./app" },
    { "path": "./domain" },
    { "path": "./experimental_client" },
    { "path": "./playground" },
    { "path": "./server" },
    { "path": "./tasks" }
  ]
}
</file>

<file path="app/main.tsx">
import { Provider as JotaiProvider } from "jotai"
import { StrictMode } from "react"
import { createRoot } from "react-dom/client"
import { QueryClient, QueryClientProvider } from "react-query"
import "@fontsource/inconsolata/index.css"
import "./global.css"
import { ClerkProvider } from "@clerk/clerk-react"
import * as Schema from "effect/Schema"
import { App } from "./app.tsx"

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <QueryClientProvider client={new QueryClient()}>
      <JotaiProvider>
        <ClerkProvider
          afterSignOutUrl="/"
          publishableKey={Schema.decodeUnknownSync(Schema.String)(
            import.meta.env.VITE_CLERK_PUBLISHABLE_KEY,
          )}
        >
          <App />
        </ClerkProvider>
      </JotaiProvider>
    </QueryClientProvider>
  </StrictMode>,
)
</file>

<file path="domain/package.json">
{
  "name": "@1b1/domain",
  "private": true,
  "type": "module",
  "exports": {
    ".": "./dist/index.js"
  },
  "peerDependencies": {
    "@1b1/experimental_client": "workspace:*",
    "effect": "^3.16.13"
  }
}
</file>

<file path="words.txt">
inconsolata
linktoken
meshconnect
ossp
pgvector
tmpfs
traceparent
wagmi
</file>

<file path="app/client.ts">
import { Api } from "@1b1/domain"
import * as FetchHttpClient from "@effect/platform/FetchHttpClient"
import * as HttpApiClient from "@effect/platform/HttpApiClient"
import * as HttpClient from "@effect/platform/HttpClient"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"

class Client extends Effect.Service<Client>()("Client", {
  accessors: true,
  dependencies: [
    FetchHttpClient.layer.pipe(
      Layer.provide(
        Layer.succeed(FetchHttpClient.RequestInit, {
          credentials: "include",
        }),
      ),
    ),
  ],
  effect: HttpApiClient.make(Api, {
    baseUrl: import.meta.env.VITE_SERVER_URL,
    transformClient: HttpClient.retryTransient({
      times: 3,
    }),
  }),
}) {
}

export const client = Client.pipe(
  Effect.provide(Client.Default),
  Effect.runSync,
)
</file>

<file path="app/package.json">
{
  "name": "@1b1/app",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite"
  },
  "dependencies": {
    "@1b1/domain": "workspace:*",
    "@clerk/clerk-react": "^5.34.0",
    "@effect/platform": "^0.87.13",
    "@electric-sql/client": "^1.0.7",
    "@electric-sql/react": "^1.0.7",
    "@fontsource/inconsolata": "^5.2.6",
    "@hookform/resolvers": "^4.1.3",
    "@icons-pack/react-simple-icons": "^11.2.0",
    "@meshconnect/web-link-sdk": "^3.2.13",
    "@metamask/providers": "^22.1.0",
    "@radix-ui/react-accordion": "^1.2.11",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.2",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-context-menu": "^2.2.15",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-hover-card": "^1.1.14",
    "@radix-ui/react-icons": "^1.3.2",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-menubar": "^1.1.15",
    "@radix-ui/react-navigation-menu": "^1.2.13",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toggle": "^1.1.9",
    "@radix-ui/react-toggle-group": "^1.1.10",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@shikijs/transformers": "^2.5.0",
    "@tanstack/react-table": "^8.21.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^4.1.0",
    "dicons": "^1.1.7",
    "effect": "^3.16.13",
    "embla-carousel-react": "^8.6.0",
    "framer-motion": "^12.23.5",
    "hono": "4.7.2",
    "input-otp": "^1.4.2",
    "jotai": "^2.12.5",
    "lucide-react": "^0.475.0",
    "next-themes": "^0.4.6",
    "react": "^19.1.0",
    "react-code-blocks": "^0.1.6",
    "react-day-picker": "^8.10.1",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.60.0",
    "react-markdown": "^9.1.0",
    "react-query": "^3.39.3",
    "react-resizable-panels": "^2.1.9",
    "react-router": "^7.6.3",
    "react-scan": "^0.1.4",
    "recharts": "^2.15.4",
    "remark-gfm": "^4.0.1",
    "shiki": "^2.5.0",
    "simple-icons": "^14.15.0",
    "sonner": "^1.7.4",
    "tailwind-merge": "^3.3.1",
    "tailwindcss": "^4.1.11",
    "tailwindcss-animate": "^1.0.7",
    "use-debounce": "^10.0.5",
    "vaul": "^1.1.2"
  },
  "devDependencies": {
    "@tailwindcss/vite": "^4.1.11",
    "@types/node": "^22.16.3",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react-swc": "^3.10.2",
    "typescript": "^5.8.3",
    "vite": "^6.3.5",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
</file>

<file path="server/ConfigService.ts">
import * as Config from "effect/Config"
import * as Effect from "effect/Effect"

export class ConfigService extends Effect.Service<ConfigService>()("ConfigService", {
  effect: Config.all({
    clientId: Config.string("VITE_MESH_CLIENT_ID"),
    secret: Config.redacted("MESH_SECRET"),
    destinationAddress: Config.string("DESTINATION_ETHEREUM_ADDRESS"),
    clerkSecret: Config.redacted("CLERK_SECRET"),
  }),
  accessors: true,
}) {}
</file>

<file path="server/package.json">
{
  "name": "@1b1/server",
  "private": true,
  "type": "module",
  "dependencies": {
    "@1b1/domain": "workspace:*",
    "@1b1/experimental_client": "workspace:*",
    "@clerk/backend": "^2.4.1",
    "@effect/opentelemetry": "^0.51.2",
    "@effect/platform-bun": "^0.69.16",
    "@meshconnect/node-api": "^2.0.21",
    "@opentelemetry/sdk-logs": "^0.202.0",
    "@opentelemetry/sdk-metrics": "^2.0.1",
    "@opentelemetry/sdk-trace-base": "^2.0.1",
    "@opentelemetry/sdk-trace-node": "^2.0.1",
    "@opentelemetry/sdk-trace-web": "^2.0.1",
    "effect": "^3.16.13"
  }
}
</file>

<file path=".gitignore">
*.tsbuildinfo
.env
dist
node_modules
tmp
</file>

<file path="package.json">
{
  "private": true,
  "type": "module",
  "workspaces": ["app", "experimental_client", "domain", "server"],
  "scripts": {
    "prepare": "ts-patch install -s",
    "build": "tspc -b",
    "watch": "tspc -b -w"
  },
  "devDependencies": {
    "@effect/language-service": "^0.23.5",
    "@effect/platform-bun": "^0.69.16",
    "@effect/sql-pg": "^0.42.0",
    "@tim-smart/openapi-gen": "^0.4.13",
    "@types/bun": "^1.2.18",
    "@types/node": "^22.16.3",
    "@types/react": "~19.0.14",
    "dprint": "^0.50.1",
    "effect": "^3.16.13",
    "ts-patch": "^3.3.0",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="app/app.tsx">
import { Button } from "@/components/ui/button"
import { SignedIn, SignedOut, SignInButton, useAuth, UserButton } from "@clerk/clerk-react"
import { createLink } from "@meshconnect/web-link-sdk"
import * as Console from "effect/Console"
import * as Effect from "effect/Effect"
import * as Schema from "effect/Schema"
import { useEffect, useRef, useState } from "react"
import { useMutation, useQuery } from "react-query"
import { client } from "./client.ts"

const decodeString = Schema.decodeUnknownSync(Schema.String)

export const App = () => {
  const { isSignedIn, getToken } = useAuth()

  const { data: balances } = useQuery({
    queryKey: ["balances", isSignedIn],
    queryFn: async () =>
      isSignedIn
        ? client.v1.getBalances().pipe(Effect.runPromise)
        : undefined,
  })

  const createCoinbaseLinkToken = useMutation({
    mutationKey: ["createCoinbaseLinkToken"],
    mutationFn: async () =>
      client.v1
        .createLinkToken({
          payload: { _tag: "coinbase" },
        })
        .pipe(Effect.runPromise)
        .then(meshLinkRef.current.openLink),
  })

  const createMetamaskLinkToken = useMutation({
    mutationKey: ["createMetamaskLinkToken"],
    mutationFn: async () =>
      client.v1
        .createLinkToken({
          payload: { _tag: "metamask" },
        })
        .pipe(Effect.runPromise)
        .then(meshLinkRef.current.openLink),
  })

  // const refreshCoinbaseTokenDetails = async () => {
  //   const details = coinbaseAccessTokenDetails
  //     ? await client.v1
  //       .refreshCoinbaseToken({
  //         payload: coinbaseAccessTokenDetails,
  //       })
  //       .pipe(Effect.runPromise)
  //     : undefined
  //   setCoinbaseAccessTokenDetails(details)
  //   return details
  // }

  const meshLinkRef = useRef(createLink({
    clientId: import.meta.env.VITE_MESH_CLIENT_ID,
    onIntegrationConnected: async (payload) => {
      const { accessToken } = payload
      const token = accessToken?.accountTokens[0]
      if (!token) throw new Error()
      switch (accessToken?.brokerName) {
        case "Coinbase": {
          await client.v1.saveCoinbaseTokens({
            payload: {
              accessToken: decodeString(token.accessToken),
              refreshToken: decodeString(token.refreshToken),
            },
          }).pipe(Effect.runPromise)
          break
        }
        case "MetaMask": {
          await client.v1.saveMetamaskToken({
            payload: {
              accessToken: decodeString(token.accessToken),
            },
          }).pipe(Effect.runPromise)
          break
        }
      }
    },
    onTransferFinished: (transferFinishedPayload) => {
      console.log({ transferFinishedPayload })
    },
    onExit: (error, summary) => {
      console.log({ error, summary })
    },
  }))

  // const openLink = async (_tag: "metamask" | "coinbase") => {
  //   try {
  //     const token = await client.v1
  //       .createLinkToken({
  //         payload: {
  //           _tag: _tag as never,
  //         },
  //       })
  //       .pipe(Effect.runPromise)
  //     console.log({ token })
  //     meshLinkRef.current.openLink(token)
  //   } catch (error) {
  //     if (error instanceof Error) {
  //       console.log(error.stack)
  //     }
  //   }
  // }

  return (
    <>
      <SignedOut>
        <SignInButton />
      </SignedOut>
      <SignedIn>
        <UserButton />
      </SignedIn>
      <div className="max-w-4xl mx-auto p-6 space-y-8">
        <div className="flex flex-col sm:flex-row gap-4 justify-end pt-6">
          <div>
            MetaMask (Balance: {balances?.metamask})
            <Button onClick={() => createMetamaskLinkToken.mutate()} className="w-full sm:w-auto">
              {balances?.metamask ? "Disconnect MetaMask" : "Connect MetaMask"}
            </Button>
          </div>
          <div>
            Coinbase (Balance: {balances?.coinbase})
            <Button onClick={() => createCoinbaseLinkToken.mutate()}>
              {balances?.coinbase ? "Disconnect Coinbase" : "Connect Coinbase"}
            </Button>
          </div>
        </div>

        {
          /* {coinbaseAccessToken && (
          <div className="mt-8 p-4 border rounded-md shadow-md bg-white/10">
            <h2 className="text-xl font-semibold mb-2">
              Coinbase USDC Balance
            </h2>
            <p className="text-lg mb-4">
              {balances.coinbase !== null
                ? `${balances.coinbase} ETH`
                : "Balance not loaded"}
            </p>
            <div className="flex gap-4">
              {mfaRequired && (
                <div className="mt-4">
                  <input
                    type="text"
                    placeholder="MFA"
                    value={mfaCode}
                    onChange={(e) => setMfaCode(e.target.value)}
                    className="border p-2 rounded"
                  />
                  <Button
                    onClick={async () => {
                      const accessToken = localStorage.getItem("coinbaseAccessToken")!
                      const brokerType = localStorage.getItem("coinbaseBrokerType")!

                      const { executeTransferResult } = await client.v1.transferFromCoinbaseMfa({
                        payload: {
                          accessToken: Redacted.make(accessToken),
                          brokerType: brokerType as never,
                          previewId: previewId!,
                          mfaCode,
                        },
                      }).pipe(Effect.runPromise)
                      setMfaRequired(false)
                      setMfaCode("")
                      console.log({ executeTransferResult })
                    }}
                  >
                    Confirm MFA
                  </Button>
                </div>
              )}
            </div>
          </div>
        )} */
        }
      </div>

      {
        /* <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>
              {modalStage === "summary" && "Confirm Your Payment"}
              {modalStage === "mfa" && "Enter MFA Code"}
              {modalStage === "success" && "Payment Successful"}
              {modalStage === "error" && "Payment Failed"}
            </DialogTitle>
          </DialogHeader>

          {modalStage === "summary" && (
            <div className="space-y-4">
              <p>Total to pay something</p>
              <DialogFooter>
                <Button
                  onClick={async () => {
                    const accessToken = localStorage.getItem("coinbaseAccessToken")!
                    const brokerType = localStorage.getItem("coinbaseBrokerType")!

                    const result = await client.v1.transferFromCoinbase({
                      payload: {
                        accessToken: Redacted.make(accessToken),
                        brokerType: brokerType as never,
                        amount: .0001,
                      },
                    }).pipe(Effect.runPromise)
                    if (result._tag === "mfa") {
                      setPreviewId(result.previewId)
                      setModalStage("mfa")
                    } else if (result.content.status === "succeeded") {
                      setModalStage("success")
                    } else {
                      setTransferError("Transfer failed. Try again.")
                      setModalStage("error")
                    }
                  }}
                >
                  Confirm Payment
                </Button>
              </DialogFooter>
            </div>
          )}

          {modalStage === "mfa" && (
            <div className="space-y-4">
              <input
                type="text"
                placeholder="Enter MFA Code"
                value={mfaCode}
                onChange={(e) => setMfaCode(e.target.value)}
                className="border w-full p-2 rounded"
              />
              <DialogFooter>
                <Button
                  onClick={async () => {
                    const accessToken = localStorage.getItem("coinbaseAccessToken")!
                    const brokerType = localStorage.getItem("coinbaseBrokerType")!

                    const result = await client.v1.transferFromCoinbaseMfa({
                      payload: {
                        accessToken: Redacted.make(accessToken),
                        brokerType: brokerType as never,
                        previewId: previewId!,
                        mfaCode,
                      },
                    }).pipe(
                      Effect.map(Struct.get("executeTransferResult")),
                      Effect.flatMap(Effect.fromNullable),
                      Effect.runPromise,
                    )
                    if (result.status === "succeeded") {
                      setModalStage("success")
                    } else {
                      setTransferError("MFA failed. Try again.")
                      setModalStage("error")
                    }
                  }}
                >
                  Confirm MFA
                </Button>
              </DialogFooter>
            </div>
          )}

          {modalStage === "success" && (
            <div className="text-center space-y-4">
              <p>Your payment was processed successfully.</p>
              <DialogFooter>
                <Button onClick={() => setIsModalOpen(false)}>Close</Button>
              </DialogFooter>
            </div>
          )}

          {modalStage === "error" && (
            <div className="text-center space-y-4 text-red-600">
              <p>{transferError}</p>
              <DialogFooter>
                <Button onClick={() => setIsModalOpen(false)}>Close</Button>
              </DialogFooter>
            </div>
          )}
        </DialogContent>
      </Dialog> */
      }
    </>
  )
}
</file>

<file path="server/main.ts">
import { Api } from "@1b1/domain"
import * as MeshClient from "@1b1/experimental_client/MeshClient"
import * as NodeSdk from "@effect/opentelemetry/NodeSdk"
import * as BunHttpServer from "@effect/platform-bun/BunHttpServer"
// import {layerHttpLayerRouter} from "@effect/platform/HttpApiScalar"
import * as FetchHttpClient from "@effect/platform/FetchHttpClient"
import * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"
import * as HttpApiSwagger from "@effect/platform/HttpApiSwagger"
import * as HttpServer from "@effect/platform/HttpServer"
import { BatchSpanProcessor, ConsoleSpanExporter } from "@opentelemetry/sdk-trace-base"
import * as Config from "effect/Config"
import * as Effect from "effect/Effect"
import * as Layer from "effect/Layer"
import { ApiLive } from "./ApiLive.ts"
import { ConfigService } from "./ConfigService.ts"
import { MemoryDb } from "./MemoryDb.ts"

const OtelLive = NodeSdk.layer(() => ({
  resource: { serviceName: "example" },
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter()),
}))

const CorsLive = Layer.unwrapEffect(
  Config.string("APP_URL").pipe(
    Effect.map((url) =>
      HttpApiBuilder.middlewareCors({
        allowedOrigins: [url],
        allowedMethods: ["DELETE", "GET", "OPTIONS", "PATCH", "POST", "PUT"],
        allowedHeaders: ["Content-Type", "Authorization", "B3", "traceparent"],
        credentials: true,
      })
    ),
  ),
)

HttpApiBuilder.serve().pipe(
  HttpServer.withLogAddress,
  Layer.provide(CorsLive),
  Layer.provide(HttpApiBuilder.middlewareCors()),
  Layer.provide(HttpApiSwagger.layer()),
  Layer.provide(OtelLive),
  Layer.provide(
    HttpApiBuilder.api(Api).pipe(
      Layer.provide(ApiLive),
    ),
  ),
  Layer.provide(MeshClient.layerConfig({
    clientId: Config.string("VITE_MESH_CLIENT_ID"),
    secret: Config.redacted("MESH_SECRET"),
  })),
  Layer.provide(ConfigService.Default),
  Layer.provide(FetchHttpClient.layer),
  Layer.provide(BunHttpServer.layer({
    port: 3000,
  })),
  Layer.provide(FetchHttpClient.layer),
  Layer.provide(MemoryDb),
  Layer.launch,
  Effect.runPromise,
)
</file>

</files>
